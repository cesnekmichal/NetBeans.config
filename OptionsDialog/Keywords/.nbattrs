<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE attributes PUBLIC "-//NetBeans//DTD DefaultAttributes 1.0//EN" "http://www.netbeans.org/dtds/attributes-1_0.dtd">
<attributes version="1.0">
    <fileobject name="findbugs">
        <attr name="keywords" stringvalue="SYNCHRONIZATION ON FIELD IN FUTILE ATTEMPT TO GUARD THAT FIELDSYNCHRONIZATION ON {2.GIVENCLASS} IN FUTILE ATTEMPT TO GUARD ITMT_CORRECTNESSTHIS METHOD SYNCHRONIZES ON A FIELD IN WHAT APPEARS TO BE AN ATTEMPT TO GUARD \u000aAGAINST SIMULTANEOUS UPDATES TO THAT FIELD. BUT GUARDING A FIELD GETS A LOCK \u000aON THE REFERENCED OBJECT, NOT ON THE FIELD. THIS MAY NOT PROVIDE THE MUTUAL \u000aEXCLUSION YOU NEED, AND OTHER THREADS MIGHT BE OBTAINING LOCKS ON THE \u000aREFERENCED OBJECTS (FOR OTHER PURPOSES). AN EXAMPLE OF THIS PATTERN WOULD BE: \u000aPRIVATE LONG MYNTFSEQNBRCOUNTER = NEW LONG(0);\u000aPRIVATE LONG GETNOTIFICATIONSEQUENCENUMBER() {\u000a     LONG RESULT = NULL;\u000a     SYNCHRONIZED(MYNTFSEQNBRCOUNTER) {\u000a         RESULT = NEW LONG(MYNTFSEQNBRCOUNTER.LONGVALUE() + 1);\u000a         MYNTFSEQNBRCOUNTER = NEW LONG(RESULT.LONGVALUE());\u000a     }\u000a     RETURN RESULT;\u000a },USING NOTIFY() RATHER THAN NOTIFYALL()USING NOTIFY RATHER THAN NOTIFYALL IN {1}MT_CORRECTNESSTHIS METHOD CALLS NOTIFY() RATHER THAN NOTIFYALL().  JAVA MONITORS ARE OFTEN \u000aUSED FOR MULTIPLE CONDITIONS.  CALLING NOTIFY() ONLY WAKES UP ONE THREAD, \u000aMEANING THAT THE THREAD WOKEN UP MIGHT NOT BE THE ONE WAITING FOR THE \u000aCONDITION THAT THE CALLER JUST SATISFIED.\u000a,METHOD MAY FAIL TO CLEAN UP STREAM OR RESOURCE{1} MAY FAIL TO CLEAN UP {2}EXPERIMENTALTHIS METHOD MAY FAIL TO CLEAN UP (CLOSE, DISPOSE OF) A STREAM, DATABASE \u000aOBJECT, OR OTHER RESOURCE REQUIRING AN EXPLICIT CLEANUP OPERATION. \u000aIN GENERAL, IF A METHOD OPENS A STREAM OR OTHER RESOURCE, THE METHOD SHOULD \u000aUSE A TRY/FINALLY BLOCK TO ENSURE THAT THE STREAM OR RESOURCE IS CLEANED UP \u000aBEFORE THE METHOD RETURNS. \u000aTHIS BUG PATTERN IS ESSENTIALLY THE SAME AS THE OS_OPEN_STREAM AND \u000aODR_OPEN_DATABASE_RESOURCE BUG PATTERNS, BUT IS BASED ON A DIFFERENT (AND \u000aHOPEFULLY BETTER) STATIC ANALYSIS TECHNIQUE. WE ARE INTERESTED IS GETTING \u000aFEEDBACK ABOUT THE USEFULNESS OF THIS BUG PATTERN. TO SEND FEEDBACK, EITHER: \u000a  * SEND EMAIL TO FINDBUGS@CS.UMD.EDU \u000a  * FILE A BUG REPORT: HTTP://FINDBUGS.SOURCEFORGE.NET/REPORTINGBUGS.HTML \u000a  \u000aIN PARTICULAR, THE FALSE-POSITIVE SUPPRESSION HEURISTICS FOR THIS BUG PATTERN \u000aHAVE NOT BEEN EXTENSIVELY TUNED, SO REPORTS ABOUT FALSE POSITIVES ARE HELPFUL \u000aTO US. \u000aSEE WEIMER AND NECULA, FINDING AND PREVENTING RUN-TIME ERROR HANDLING MISTAKES, \u000aFOR A DESCRIPTION OF THE ANALYSIS TECHNIQUE.\u000a,FIELD SHOULD BE PACKAGE PROTECTED{1} SHOULD BE PACKAGE PROTECTEDMALICIOUS_CODEA MUTABLE STATIC FIELD COULD BE CHANGED BY MALICIOUS CODE OR BY ACCIDENT. THE \u000aFIELD COULD BE MADE PACKAGE PROTECTED TO AVOID THIS VULNERABILITY.\u000a,CLASS MAKES REFERENCE TO UNRESOLVABLE CLASS OR METHODUNRESOLVABLE REFERENCE TO {1} BY {0}CORRECTNESSTHIS CLASS MAKES A REFERENCE TO A CLASS OR METHOD THAT CAN NOT BE RESOLVED \u000aUSING AGAINST THE LIBRARIES IT IS BEING ANALYZED WITH.\u000a,UNINITIALIZED READ OF FIELD IN CONSTRUCTORUNINITIALIZED READ OF {2.NAME} IN {1}CORRECTNESSTHIS CONSTRUCTOR READS A FIELD WHICH HAS NOT YET BEEN ASSIGNED A VALUE.  THIS \u000aIS OFTEN CAUSED WHEN THE PROGRAMMER MISTAKENLY USES THE FIELD INSTEAD OF ONE \u000aOF THE CONSTRUCTOR&apos;S PARAMETERS.\u000a,BAD COMPARISON OF INT VALUE WITH LONG CONSTANTBAD COMPARISON OF INT WITH {2} IN {1}CORRECTNESSTHIS CODE COMPARES AN INT VALUE WITH A LONG CONSTANT THAT IS OUTSIDE THE RANGE \u000aOF VALUES THAT CAN BE REPRESENTED AS AN INT VALUE. THIS COMPARISON IS VACUOUS \u000aAND POSSIBILY TO BE INCORRECT.\u000a,NO PREVIOUS ARGUMENT FOR FORMAT STRINGNO PREVIOUS ARGUMENT FOR FORMAT STRING ARGUMENT TO {2} IN {1}CORRECTNESSTHE FORMAT STRING SPECIFIES A RELATIVE INDEX TO REQUEST THAT THE ARGUMENT FOR \u000aTHE PREVIOUS FORMAT SPECIFIER BE REUSED. HOWEVER, THERE IS NO PREVIOUS \u000aARGUMENT. FOR EXAMPLE, \u000aFORMATTER.FORMAT(&quot;%&lt;S %S&quot;, &quot;A&quot;, &quot;B&quot;) \u000aWOULD THROW A MISSINGFORMATARGUMENTEXCEPTION WHEN EXECUTED.\u000a,SIGNATURE DECLARES USE OF UNHASHABLE CLASS IN HASHED CONSTRUCT{2} DOESN&apos;T DEFINE A HASHCODE() METHOD BUT IT IS USED IN A HASHED CONTEXT IN {1}CORRECTNESSA METHOD, FIELD OR CLASS DECLARES A GENERIC SIGNATURE WHERE A NON-HASHABLE \u000aCLASS IS USED IN CONTEXT WHERE A HASHABLE CLASS IS REQUIRED. A CLASS THAT \u000aDECLARES AN EQUALS METHOD BUT INHERITS A HASHCODE() METHOD FROM OBJECT IS \u000aUNHASHABLE, SINCE IT DOESN&apos;T FULFILL THE REQUIREMENT THAT EQUAL OBJECTS HAVE \u000aEQUAL HASHCODES.\u000a,UNUSUAL EQUALS METHOD {1} IS UNUSUALSTYLETHIS CLASS DOESN&apos;T DO ANY OF THE PATTERNS WE RECOGNIZE FOR CHECKING THAT THE \u000aTYPE OF THE ARGUMENT IS COMPATIBLE WITH THE TYPE OF THE THIS OBJECT. THERE \u000aMIGHT NOT BE ANYTHING WRONG WITH THIS CODE, BUT IT IS WORTH REVIEWING.\u000a,SERIALVERSIONUID ISN&apos;T STATIC{1} ISN&apos;T STATICBAD_PRACTICETHIS CLASS DEFINES A SERIALVERSIONUID FIELD THAT IS NOT STATIC.  THE FIELD \u000aSHOULD BE MADE STATIC IF IT IS INTENDED TO SPECIFY THE VERSION UID FOR \u000aPURPOSES OF SERIALIZATION.\u000a,EXCEPTION CREATED AND DROPPED RATHER THAN THROWN{2.GIVENCLASS} NOT THROWN IN {1}CORRECTNESSTHIS CODE CREATES AN EXCEPTION (OR ERROR) OBJECT, BUT DOESN&apos;T DO ANYTHING WITH \u000aIT. FOR EXAMPLE, SOMETHING LIKE \u000aIF (X &lt; 0)\u000a  NEW ILLEGALARGUMENTEXCEPTION(&quot;X MUST BE NONNEGATIVE&quot;);\u000aIT WAS PROBABLY THE INTENT OF THE PROGRAMMER TO THROW THE CREATED EXCEPTION: \u000aIF (X &lt; 0)\u000a  THROW NEW ILLEGALARGUMENTEXCEPTION(&quot;X MUST BE NONNEGATIVE&quot;);,EQUALS METHOD OVERRIDES EQUALS IN SUPERCLASS AND MAY NOT BE SYMMETRIC{1.CLASS} OVERRIDES EQUALS IN {2.CLASS.GIVENCLASS} AND MAY NOT BE SYMMETRICCORRECTNESSTHIS CLASS DEFINES AN EQUALS METHOD THAT OVERRIDES AN EQUALS METHOD IN A \u000aSUPERCLASS. BOTH EQUALS METHODS METHODS USE INSTANCEOF IN THE DETERMINATION OF \u000aWHETHER TWO OBJECTS ARE EQUAL. THIS IS FRAUGHT WITH PERIL, SINCE IT IS \u000aIMPORTANT THAT THE EQUALS METHOD IS SYMMETRICAL (IN OTHER WORDS, A.EQUALS(B) \u000a== B.EQUALS(A)). IF B IS A SUBTYPE OF A, AND A&apos;S EQUALS METHOD CHECKS THAT THE \u000aARGUMENT IS AN INSTANCEOF A, AND B&apos;S EQUALS METHOD CHECKS THAT THE ARGUMENT IS \u000aAN INSTANCEOF B, IT IS QUITE LIKELY THAT THE EQUIVALENCE RELATION DEFINED BY \u000aTHESE METHODS IS NOT SYMMETRIC.\u000a,CONDITION.AWAIT() NOT IN LOOP CONDITION.AWAIT() NOT IN LOOP IN {1}MT_CORRECTNESSTHIS METHOD CONTAINS A CALL TO JAVA.UTIL.CONCURRENT.AWAIT() (OR VARIANTS) \u000aWHICH IS NOT IN A LOOP.  IF THE OBJECT IS USED FOR MULTIPLE CONDITIONS, THE \u000aCONDITION THE CALLER INTENDED TO WAIT FOR MIGHT NOT BE THE ONE THAT ACTUALLY \u000aOCCURRED.\u000a,MAY EXPOSE INTERNAL REPRESENTATION BY INCORPORATING REFERENCE TO MUTABLE OBJECT{1} MAY EXPOSE INTERNAL REPRESENTATION BY STORING AN EXTERNALLY MUTABLE OBJECT INTO {2.GIVENCLASS}MALICIOUS_CODETHIS CODE STORES A REFERENCE TO AN EXTERNALLY MUTABLE OBJECT INTO THE INTERNAL \u000aREPRESENTATION OF THE OBJECT.  IF INSTANCES ARE ACCESSED BY UNTRUSTED CODE, \u000aAND UNCHECKED CHANGES TO THE MUTABLE OBJECT WOULD COMPROMISE SECURITY OR OTHER \u000aIMPORTANT PROPERTIES, YOU WILL NEED TO DO SOMETHING DIFFERENT. STORING A COPY \u000aOF THE OBJECT IS BETTER APPROACH IN MANY SITUATIONS.\u000a,SELF COMPARISON OF FIELD WITH ITSELFSELF COMPARISON OF {2.GIVENCLASS} WITH ITSELF IN {1}CORRECTNESSTHIS METHOD COMPARES A FIELD WITH ITSELF, AND MAY INDICATE A TYPO OR A LOGIC \u000aERROR. MAKE SURE THAT YOU ARE COMPARING THE RIGHT THINGS.\u000a,NULL VALUE IS GUARANTEED TO BE DEREFERENCED{2.GIVENCLASS} COULD BE NULL AND IS GUARANTEED TO BE DEREFERENCED IN {1}CORRECTNESSTHERE IS A STATEMENT OR BRANCH THAT IF EXECUTED GUARANTEES THAT A VALUE IS \u000aNULL AT THIS POINT, AND THAT VALUE THAT IS GUARANTEED TO BE DEREFERENCED \u000a(EXCEPT ON FORWARD PATHS INVOLVING RUNTIME EXCEPTIONS). \u000aNOTE THAT A CHECK SUCH AS IF (X == NULL) THROW NEW NULLPOINTEREXCEPTION(); IS \u000aTREATED AS A DEREFERENCE OF X.\u000a,IMMEDIATE DEREFERENCE OF THE RESULT OF READLINE()IMMEDIATE DEREFERENCE OF THE RESULT OF READLINE() IN {1}STYLETHE RESULT OF INVOKING READLINE() IS IMMEDIATELY DEREFERENCED. IF THERE ARE NO \u000aMORE LINES OF TEXT TO READ, READLINE() WILL RETURN NULL AND DEREFERENCING THAT \u000aWILL GENERATE A NULL POINTER EXCEPTION.\u000a,FINALIZER NULLIFIES SUPERCLASS FINALIZER{1} IS NULLIFYING {2}.FINALIZE(); IS THIS INTENDED?BAD_PRACTICETHIS EMPTY FINALIZE() METHOD EXPLICITLY NEGATES THE EFFECT OF ANY FINALIZER \u000aDEFINED BY ITS SUPERCLASS.  ANY FINALIZER ACTIONS DEFINED FOR THE SUPERCLASS \u000aWILL NOT BE PERFORMED.  UNLESS THIS IS INTENDED, DELETE THIS METHOD.\u000a,PRIVATE READRESOLVE METHOD NOT INHERITED BY SUBCLASSESPRIVATE READRESOLVE METHOD IN {0} NOT INHERITED BY SUBCLASSES.STYLETHIS CLASS DEFINES A PRIVATE READRESOLVE METHOD. SINCE IT IS PRIVATE, IT WON&apos;T \u000aBE INHERITED BY SUBCLASSES. THIS MIGHT BE INTENTIONAL AND OK, BUT SHOULD BE \u000aREVIEWED TO ENSURE IT IS WHAT IS INTENDED.\u000a,EQUALS METHOD SHOULD NOT ASSUME ANYTHING ABOUT THE TYPE OF ITS ARGUMENTEQUALS METHOD FOR {0} ASSUMES THE ARGUMENT IS OF TYPE {0.GIVENCLASS}BAD_PRACTICETHE EQUALS(OBJECT O) METHOD SHOULDN&apos;T MAKE ANY ASSUMPTIONS ABOUT THE TYPE OF O. \u000aIT SHOULD SIMPLY RETURN FALSE IF O IS NOT THE SAME TYPE AS THIS.\u000a,METHOD TIGHTENS NULLNESS ANNOTATION ON PARAMETERMETHOD {1} OVERRIDES THE NULLNESS ANNOTATION OF PARAMETER {2} IN AN INCOMPATIBLE WAYSTYLEA METHOD SHOULD ALWAYS IMPLEMENT THE CONTRACT OF A METHOD IT OVERRIDES. THUS, \u000aIF A METHOD TAKES A PARAMETER THAT IS MARKED AS @NULLABLE, YOU SHOULDN&apos;T \u000aOVERRIDE THAT METHOD IN A SUBCLASS WITH A METHOD WHERE THAT PARAMETER IS \u000a@NONNULL. DOING SO VIOLATES THE CONTRACT THAT THE METHOD SHOULD HANDLE A NULL \u000aPARAMETER.\u000a,CLASS IMPLEMENTS CLONEABLE BUT DOES NOT DEFINE OR USE CLONE METHODCLASS {0} IMPLEMENTS CLONEABLE BUT DOES NOT DEFINE OR USE CLONE METHODBAD_PRACTICECLASS IMPLEMENTS CLONEABLE BUT DOES NOT DEFINE OR USE THE CLONE METHOD.\u000a,METHOD CALLS STATIC MATH CLASS METHOD ON A CONSTANT VALUEMETHOD CALLS STATIC MATH CLASS METHOD ON A CONSTANT VALUEPERFORMANCETHIS METHOD USES A STATIC METHOD FROM JAVA.LANG.MATH ON A CONSTANT VALUE. THIS \u000aMETHOD&apos;S RESULT IN THIS CASE, CAN BE DETERMINED STATICALLY, AND IS FASTER AND \u000aSOMETIMES MORE ACCURATE TO JUST USE THE CONSTANT. METHODS DETECTED ARE: \u000aMETHOD PARAMETER ABS -ANY- ACOS 0.0 OR 1.0 ASIN 0.0 OR 1.0 ATAN 0.0 OR 1.0 ATAN2 \u000a0.0 CBRT 0.0 OR 1.0 CEIL -ANY- COS 0.0 COSH 0.0 EXP 0.0 OR 1.0 EXPM1 0.0 FLOOR -ANY- \u000aLOG 0.0 OR 1.0 LOG10 0.0 OR 1.0 RINT -ANY- ROUND -ANY- SIN 0.0 SINH 0.0 SQRT 0.0 \u000aOR 1.0 TAN 0.0 TANH 0.0 TODEGREES 0.0 OR 1.0 TORADIANS 0.0,RETURN VALUE OF PUTIFABSENT IGNORED, VALUE PASSED TO PUTIFABSENT REUSEDRETURN VALUE OF PUTIFABSENT IS IGNORED, BUT {4} IS REUSED IN {1}MT_CORRECTNESSTHE PUTIFABSENT METHOD IS TYPICALLY USED TO ENSURE THAT A SINGLE VALUE IS \u000aASSOCIATED WITH A GIVEN KEY (THE FIRST VALUE FOR WHICH PUT IF ABSENT \u000aSUCCEEDS). IF YOU IGNORE THE RETURN VALUE AND RETAIN A REFERENCE TO THE VALUE \u000aPASSED IN, YOU RUN THE RISK OF RETAINING A VALUE THAT IS NOT THE ONE THAT IS \u000aASSOCIATED WITH THE KEY IN THE MAP. IF IT MATTERS WHICH ONE YOU USE AND YOU \u000aUSE THE ONE THAT ISN&apos;T STORED IN THE MAP, YOUR PROGRAM WILL BEHAVE INCORRECTLY.,VACUOUS COMPARISON OF INTEGER VALUEVACUOUS COMPARISON OF INTEGER VALUE {1} STYLETHERE IS AN INTEGER COMPARISON THAT ALWAYS RETURNS THE SAME VALUE (E.G., X &lt;= \u000aINTEGER.MAX_VALUE).\u000a,SUPERCLASS USES SUBCLASS DURING INITIALIZATIONINITIALIZATION OF {0} ACCESSES CLASS {2}, WHICH ISN&apos;T INITIALIZED YETBAD_PRACTICEDURING THE INITIALIZATION OF A CLASS, THE CLASS MAKES AN ACTIVE USE OF A \u000aSUBCLASS. THAT SUBCLASS WILL NOT YET BE INITIALIZED AT THE TIME OF THIS USE. \u000aFOR EXAMPLE, IN THE FOLLOWING CODE, FOO WILL BE NULL. \u000aPUBLIC CLASS CIRCULARCLASSINITIALIZATION {\u000a    STATIC CLASS INNERCLASSSINGLETON EXTENDS CIRCULARCLASSINITIALIZATION {\u000a        STATIC INNERCLASSSINGLETON SINGLETON = NEW INNERCLASSSINGLETON();\u000a    }\u000a\u000a    STATIC CIRCULARCLASSINITIALIZATION FOO = INNERCLASSSINGLETON.SINGLETON;\u000a},CLASS DOESN&apos;T OVERRIDE EQUALS IN SUPERCLASS{0} DOESN&apos;T OVERRIDE {2.GIVENCLASS}STYLETHIS CLASS EXTENDS A CLASS THAT DEFINES AN EQUALS METHOD AND ADDS FIELDS, BUT \u000aDOESN&apos;T DEFINE AN EQUALS METHOD ITSELF. THUS, EQUALITY ON INSTANCES OF THIS \u000aCLASS WILL IGNORE THE IDENTITY OF THE SUBCLASS AND THE ADDED FIELDS. BE SURE \u000aTHIS IS WHAT IS INTENDED, AND THAT YOU DON&apos;T NEED TO OVERRIDE THE EQUALS \u000aMETHOD. EVEN IF YOU DON&apos;T NEED TO OVERRIDE THE EQUALS METHOD, CONSIDER \u000aOVERRIDING IT ANYWAY TO DOCUMENT THE FACT THAT THE EQUALS METHOD FOR THE \u000aSUBCLASS JUST RETURN THE RESULT OF INVOKING SUPER.EQUALS(O).\u000a,INCONSISTENT SYNCHRONIZATIONINCONSISTENT SYNCHRONIZATION OF {1}; LOCKED {2}% OF THE TIMEMT_CORRECTNESSTHE FIELDS OF THIS CLASS APPEAR TO BE ACCESSED INCONSISTENTLY WITH RESPECT TO \u000aSYNCHRONIZATION.  THIS BUG REPORT INDICATES THAT THE BUG PATTERN DETECTOR \u000aJUDGED THAT \u000a  * THE CLASS CONTAINS A MIX OF LOCKED AND UNLOCKED ACCESSES, \u000a  * AT LEAST ONE LOCKED ACCESS WAS PERFORMED BY ONE OF THE CLASS&apos;S OWN \u000a    METHODS, AND \u000a  * THE NUMBER OF UNSYNCHRONIZED FIELD ACCESSES (READS AND WRITES) WAS NO MORE \u000a    THAN ONE THIRD OF ALL ACCESSES, WITH WRITES BEING WEIGHED TWICE AS HIGH AS \u000a    READS \u000a  \u000aA TYPICAL BUG MATCHING THIS BUG PATTERN IS FORGETTING TO SYNCHRONIZE ONE OF \u000aTHE METHODS IN A CLASS THAT IS INTENDED TO BE THREAD-SAFE. \u000aNOTE THAT THERE ARE VARIOUS SOURCES OF INACCURACY IN THIS DETECTOR; FOR \u000aEXAMPLE, THE DETECTOR CANNOT STATICALLY DETECT ALL SITUATIONS IN WHICH A LOCK \u000aIS HELD.  ALSO, EVEN WHEN THE DETECTOR IS ACCURATE IN DISTINGUISHING LOCKED \u000aVS. UNLOCKED ACCESSES, THE CODE IN QUESTION MAY STILL BE CORRECT.\u000a,SYNCHRONIZATION ON BOOLEANSYNCHRONIZATION ON BOOLEAN IN {1}MT_CORRECTNESSTHE CODE SYNCHRONIZES ON A BOXED PRIMITIVE CONSTANT, SUCH AS AN BOOLEAN. \u000aPRIVATE STATIC BOOLEAN INITED = BOOLEAN.FALSE;\u000a...\u000a  SYNCHRONIZED(INITED) {\u000a    IF (!INITED) {\u000a       INIT();\u000a       INITED = BOOLEAN.TRUE;\u000a       }\u000a     }\u000a...\u000aSINCE THERE NORMALLY EXIST ONLY TWO BOOLEAN OBJECTS, THIS CODE COULD BE \u000aSYNCHRONIZING ON THE SAME OBJECT AS OTHER, UNRELATED CODE, LEADING TO \u000aUNRESPONSIVENESS AND POSSIBLE DEADLOCK \u000aSEE CERT CON08-J. DO NOT SYNCHRONIZE ON OBJECTS THAT MAY BE REUSED FOR MORE \u000aINFORMATION.\u000a,DUBIOUS CATCHING OF ILLEGALMONITORSTATEEXCEPTIONDUBIOUS CATCHING OF ILLEGALMONITORSTATEEXCEPTION IN {1}BAD_PRACTICEILLEGALMONITORSTATEEXCEPTION IS GENERALLY ONLY THROWN IN CASE OF A DESIGN FLAW \u000aIN YOUR CODE (CALLING WAIT OR NOTIFY ON AN OBJECT YOU DO NOT HOLD A LOCK ON).\u000a,SYNCHRONIZATION PERFORMED ON UTIL.CONCURRENT INSTANCESYNCHRONIZATION PERFORMED ON {2} IN {1}MT_CORRECTNESSTHIS METHOD PERFORMS SYNCHRONIZATION AN OBJECT THAT IS AN INSTANCE OF A CLASS \u000aFROM THE JAVA.UTIL.CONCURRENT PACKAGE (OR ITS SUBCLASSES). INSTANCES OF THESE \u000aCLASSES HAVE THEIR OWN CONCURRENCY CONTROL MECHANISMS THAT ARE ORTHOGONAL TO \u000aTHE SYNCHRONIZATION PROVIDED BY THE JAVA KEYWORD SYNCHRONIZED. FOR EXAMPLE, \u000aSYNCHRONIZING ON AN ATOMICBOOLEAN WILL NOT PREVENT OTHER THREADS FROM \u000aMODIFYING THE ATOMICBOOLEAN. \u000aSUCH CODE MAY BE CORRECT, BUT SHOULD BE CAREFULLY REVIEWED AND DOCUMENTED, AND \u000aMAY CONFUSE PEOPLE WHO HAVE TO MAINTAIN THE CODE AT A LATER DATE.\u000a,STORE OF NULL VALUE INTO FIELD ANNOTATED NONNULLSTORE OF NULL VALUE INTO FIELD {2.GIVENCLASS} ANNOTATED NONNULL IN {1}CORRECTNESSA VALUE THAT COULD BE NULL IS STORED INTO A FIELD THAT HAS BEEN ANNOTATED AS \u000aNONNULL.\u000a,DON&apos;T USE REMOVEALL TO CLEAR A COLLECTIONREMOVEALL USED TO CLEAR A COLLECTION IN {1}BAD_PRACTICEIF YOU WANT TO REMOVE ALL ELEMENTS FROM A COLLECTION C, USE C.CLEAR, NOT C.REMOVEALL(C). \u000aCALLING C.REMOVEALL(C) TO CLEAR A COLLECTION IS LESS CLEAR, SUSCEPTIBLE TO \u000aERRORS FROM TYPOS, LESS EFFICIENT AND FOR SOME COLLECTIONS, MIGHT THROW A CONCURRENTMODIFICATIONEXCEPTION.\u000a,CLASS IS NOT DERIVED FROM AN EXCEPTION, EVEN THOUGH IT IS NAMED AS SUCHCLASS {0} IS NOT DERIVED FROM AN EXCEPTION, EVEN THOUGH IT IS NAMED AS SUCHBAD_PRACTICETHIS CLASS IS NOT DERIVED FROM ANOTHER EXCEPTION, BUT ENDS WITH &apos;EXCEPTION&apos;. \u000aTHIS WILL BE CONFUSING TO USERS OF THIS CLASS.\u000a,DON&apos;T REUSE ENTRY OBJECTS IN ITERATORS{0} IS BOTH AN ITERATOR AND A MAP.ENTRY BAD_PRACTICETHE ENTRYSET() METHOD IS ALLOWED TO RETURN A VIEW OF THE UNDERLYING MAP IN \u000aWHICH AN ITERATOR AND MAP.ENTRY. THIS CLEVER IDEA WAS USED IN SEVERAL MAP \u000aIMPLEMENTATIONS, BUT INTRODUCES THE POSSIBILITY OF NASTY CODING MISTAKES. IF A \u000aMAP M RETURNS SUCH AN ITERATOR FOR AN ENTRYSET, THEN C.ADDALL(M.ENTRYSET()) \u000aWILL GO BADLY WRONG. ALL OF THE MAP IMPLEMENTATIONS IN OPENJDK 1.7 HAVE BEEN \u000aREWRITTEN TO AVOID THIS, YOU SHOULD TO.\u000a,NUMBER OF FORMAT-STRING ARGUMENTS DOES NOT CORRESPOND TO NUMBER OF PLACEHOLDERSFORMAT-STRING METHOD {2} CALLED WITH FORMAT STRING &quot;{3}&quot; WANTS {4} ARGUMENTS BUT IS GIVEN {5} IN {1}CORRECTNESSA FORMAT-STRING METHOD WITH A VARIABLE NUMBER OF ARGUMENTS IS CALLED, BUT THE \u000aNUMBER OF ARGUMENTS PASSED DOES NOT MATCH WITH THE NUMBER OF % PLACEHOLDERS IN \u000aTHE FORMAT STRING. THIS IS PROBABLY NOT WHAT THE AUTHOR INTENDED.\u000a,BOGUS WARNING ABOUT A METHOD CALLBOGUS WARNING ABOUT A METHOD CALL {2} IN {1}NOISEBOGUS WARNING.\u000a,ROUGH VALUE OF KNOWN CONSTANT FOUNDROUGH VALUE OF {4} FOUND: {3}BAD_PRACTICEIT&apos;S RECOMMENDED TO USE THE PREDEFINED LIBRARY CONSTANT FOR CODE CLARITY AND \u000aBETTER PRECISION.\u000a,CONSIDER USING LOCALE PARAMETERIZED VERSION OF INVOKED METHODUSE OF NON-LOCALIZED STRING.TOUPPERCASE() OR STRING.TOLOWERCASE() IN {1}I18NA STRING IS BEING CONVERTED TO UPPER OR LOWERCASE, USING THE PLATFORM&apos;S \u000aDEFAULT ENCODING. THIS MAY RESULT IN IMPROPER CONVERSIONS WHEN USED WITH \u000aINTERNATIONAL CHARACTERS. USE THE \u000a  * STRING.TOUPPERCASE( LOCALE L ) \u000a  * STRING.TOLOWERCASE( LOCALE L ) \u000a  \u000aVERSIONS INSTEAD.\u000a,METHOD MAY FAIL TO CLOSE STREAM{1} MAY FAIL TO CLOSE STREAMBAD_PRACTICETHE METHOD CREATES AN IO STREAM OBJECT, DOES NOT ASSIGN IT TO ANY FIELDS, PASS \u000aIT TO OTHER METHODS THAT MIGHT CLOSE IT, OR RETURN IT, AND DOES NOT APPEAR TO \u000aCLOSE THE STREAM ON ALL PATHS OUT OF THE METHOD.  THIS MAY RESULT IN A FILE \u000aDESCRIPTOR LEAK.  IT IS GENERALLY A GOOD IDEA TO USE A FINALLY BLOCK TO ENSURE \u000aTHAT STREAMS ARE CLOSED.\u000a,CLONE METHOD DOES NOT CALL SUPER.CLONE(){1} DOES NOT CALL SUPER.CLONE()BAD_PRACTICETHIS NON-FINAL CLASS DEFINES A CLONE() METHOD THAT DOES NOT CALL \u000aSUPER.CLONE(). IF THIS CLASS (&quot;A&quot;) IS EXTENDED BY A SUBCLASS (&quot;B&quot;), AND THE \u000aSUBCLASS B CALLS SUPER.CLONE(), THEN IT IS LIKELY THAT B&apos;S CLONE() METHOD WILL \u000aRETURN AN OBJECT OF TYPE A, WHICH VIOLATES THE STANDARD CONTRACT FOR CLONE(). \u000aIF ALL CLONE() METHODS CALL SUPER.CLONE(), THEN THEY ARE GUARANTEED TO USE \u000aOBJECT.CLONE(), WHICH ALWAYS RETURNS AN OBJECT OF THE CORRECT TYPE.\u000a,COVARIANT COMPARETO() METHOD DEFINED{0} DEFINES COMPARETO({0.GIVENCLASS}) METHOD BUT NOT COMPARETO(OBJECT)BAD_PRACTICETHIS CLASS DEFINES A COVARIANT VERSION OF COMPARETO().  TO CORRECTLY OVERRIDE \u000aTHE COMPARETO() METHOD IN THE COMPARABLE INTERFACE, THE PARAMETER OF COMPARETO() \u000aMUST HAVE TYPE JAVA.LANG.OBJECT.\u000a,SHOULD BE A STATIC INNER CLASSSHOULD {0} BE A _STATIC_ INNER CLASS?PERFORMANCETHIS CLASS IS AN INNER CLASS, BUT DOES NOT USE ITS EMBEDDED REFERENCE TO THE \u000aOBJECT WHICH CREATED IT.  THIS REFERENCE MAKES THE INSTANCES OF THE CLASS \u000aLARGER, AND MAY KEEP THE REFERENCE TO THE CREATOR OBJECT ALIVE LONGER THAN \u000aNECESSARY.  IF POSSIBLE, THE CLASS SHOULD BE MADE STATIC.\u000a,METHOD NAMES SHOULD START WITH A LOWER CASE LETTERTHE METHOD NAME {1} DOESN&apos;T START WITH A LOWER CASE LETTERBAD_PRACTICEMETHODS SHOULD BE VERBS, IN MIXED CASE WITH THE FIRST LETTER LOWERCASE, WITH \u000aTHE FIRST LETTER OF EACH INTERNAL WORD CAPITALIZED.\u000a,RESULT OF INTEGER MULTIPLICATION CAST TO LONGRESULT OF INTEGER MULTIPLICATION CAST TO LONG IN {1}STYLETHIS CODE PERFORMS INTEGER MULTIPLY AND THEN CONVERTS THE RESULT TO A LONG, AS \u000aIN: \u000a    LONG CONVERTDAYSTOMILLISECONDS(INT DAYS) { RETURN 1000*3600*24*DAYS; }\u000aIF THE MULTIPLICATION IS DONE USING LONG ARITHMETIC, YOU CAN AVOID THE \u000aPOSSIBILITY THAT THE RESULT WILL OVERFLOW. FOR EXAMPLE, YOU COULD FIX THE \u000aABOVE CODE TO: \u000a    LONG CONVERTDAYSTOMILLISECONDS(INT DAYS) { RETURN 1000L*3600*24*DAYS; }\u000aOR     STATIC FINAL LONG MILLISECONDS_PER_DAY = 24L*3600*1000;\u000a    LONG CONVERTDAYSTOMILLISECONDS(INT DAYS) { RETURN DAYS * MILLISECONDS_PER_DAY; },BOXED VALUE IS UNBOXED AND THEN IMMEDIATELY REBOXEDBOXED VALUE IS UNBOXED AND THEN IMMEDIATELY REBOXED IN {1}PERFORMANCEA BOXED VALUE IS UNBOXED AND THEN IMMEDIATELY REBOXED.\u000a,SELF ASSIGNMENT OF FIELDSELF ASSIGNMENT OF FIELD {2.GIVENCLASS} IN {1}CORRECTNESSTHIS METHOD CONTAINS A SELF ASSIGNMENT OF A FIELD; E.G. \u000a  INT X;\u000a  PUBLIC VOID FOO() {\u000a    X = X;\u000a  }\u000aSUCH ASSIGNMENTS ARE USELESS, AND MAY INDICATE A LOGIC ERROR OR TYPO.\u000a,USE THE NEXTINT METHOD OF RANDOM RATHER THAN NEXTDOUBLE TO GENERATE A RANDOM INTEGER{1} USES THE NEXTDOUBLE METHOD OF RANDOM TO GENERATE A RANDOM INTEGER; USING NEXTINT IS MORE EFFICIENTPERFORMANCEIF R IS A JAVA.UTIL.RANDOM, YOU CAN GENERATE A RANDOM NUMBER FROM 0 TO N-1 \u000aUSING R.NEXTINT(N), RATHER THAN USING (INT)(R.NEXTDOUBLE() * N). \u000aTHE ARGUMENT TO NEXTINT MUST BE POSITIVE. IF, FOR EXAMPLE, YOU WANT TO \u000aGENERATE A RANDOM VALUE FROM -99 TO 0, USE -R.NEXTINT(100).\u000a,POSSIBLE NULL POINTER DEREFERENCE IN METHOD ON EXCEPTION PATHPOSSIBLE NULL POINTER DEREFERENCE OF {2.GIVENCLASS} IN {1} ON EXCEPTION PATHCORRECTNESSA REFERENCE VALUE WHICH IS NULL ON SOME EXCEPTION CONTROL PATH IS DEREFERENCED \u000aHERE.  THIS MAY LEAD TO A NULLPOINTEREXCEPTION WHEN THE CODE IS EXECUTED.  \u000aNOTE THAT BECAUSE FINDBUGS CURRENTLY DOES NOT PRUNE INFEASIBLE EXCEPTION \u000aPATHS, THIS MAY BE A FALSE WARNING. \u000aALSO NOTE THAT FINDBUGS CONSIDERS THE DEFAULT CASE OF A SWITCH STATEMENT TO BE \u000aAN EXCEPTION PATH, SINCE THE DEFAULT CASE IS OFTEN INFEASIBLE.\u000a,METHOD WITH OPTIONAL RETURN TYPE RETURNS EXPLICIT NULL{1} HAS OPTIONAL RETURN TYPE AND RETURNS EXPLICIT NULLCORRECTNESSTHE USAGE OF OPTIONAL RETURN TYPE ALWAYS MEAN THAT EXPLICIT NULL RETURNS WERE \u000aNOT DESIRED BY DESIGN. RETURNING A NULL VALUE IN SUCH CASE IS A CONTRACT \u000aVIOLATION AND WILL MOST LIKELY BREAK CLIENTS CODE.\u000a,FORMAT STRING REFERENCES MISSING ARGUMENTFORMAT STRING &quot;{3}&quot; NEEDS ARGUMENT {5} BUT ONLY {6} ARE PROVIDED IN {1}CORRECTNESSNOT ENOUGH ARGUMENTS ARE PASSED TO SATISFY A PLACEHOLDER IN THE FORMAT STRING. \u000aA RUNTIME EXCEPTION WILL OCCUR WHEN THIS STATEMENT IS EXECUTED.\u000a,METHOD SPINS ON FIELDSPINNING ON {2.GIVENCLASS} IN {1}MT_CORRECTNESSTHIS METHOD SPINS IN A LOOP WHICH READS A FIELD.  THE COMPILER MAY LEGALLY \u000aHOIST THE READ OUT OF THE LOOP, TURNING THE CODE INTO AN INFINITE LOOP.  THE \u000aCLASS SHOULD BE CHANGED SO IT USES PROPER SYNCHRONIZATION (INCLUDING WAIT AND \u000aNOTIFY CALLS).\u000a,VALUE REQUIRED TO HAVE TYPE QUALIFIER, BUT MARKED AS UNKNOWNVALUE IS REQUIRED TO ALWAYS BE {2.SIMPLENAME}, BUT IS EXPLICITLY ANNOTATED AS UNKNOWN WITH REGARDS TO {2.SIMPLENAME}STYLEA VALUE IS USED IN A WAY THAT REQUIRES IT TO BE ALWAYS BE A VALUE DENOTED BY A \u000aTYPE QUALIFIER, BUT THERE IS AN EXPLICIT ANNOTATION STATING THAT IT IS NOT \u000aKNOWN WHERE THE VALUE IS REQUIRED TO HAVE THAT TYPE QUALIFIER. EITHER THE \u000aUSAGE OR THE ANNOTATION IS INCORRECT.\u000a,BAD COMPARISON OF NONNEGATIVE VALUE WITH NEGATIVE CONSTANTBAD COMPARISON OF NONNEGATIVE VALUE WITH {2} IN {1}CORRECTNESSTHIS CODE COMPARES A VALUE THAT IS GUARANTEED TO BE NON-NEGATIVE WITH A \u000aNEGATIVE CONSTANT.\u000a,TESTCASE DEFINES SETUP THAT DOESN&apos;T CALL SUPER.SETUP()TESTCASE {0} DEFINES SETUP THAT DOESN&apos;T CALL SUPER.SETUP()CORRECTNESSCLASS IS A JUNIT TESTCASE AND IMPLEMENTS THE SETUP METHOD. THE SETUP METHOD \u000aSHOULD CALL SUPER.SETUP(), BUT DOESN&apos;T.\u000a,TESTCASE HAS NO TESTSTESTCASE {0} HAS NO TESTSCORRECTNESSCLASS IS A JUNIT TESTCASE BUT HAS NOT IMPLEMENTED ANY TEST METHODS\u000a,INSTANCEOF WILL ALWAYS RETURN TRUEINSTANCEOF WILL ALWAYS RETURN TRUE FOR ALL NONNULL VALUES IN {1}, SINCE ALL {2} ARE INSTANCES OF {3}STYLETHIS INSTANCEOF TEST WILL ALWAYS RETURN TRUE (UNLESS THE VALUE BEING TESTED IS \u000aNULL). ALTHOUGH THIS IS SAFE, MAKE SURE IT ISN&apos;T AN INDICATION OF SOME \u000aMISUNDERSTANDING OR SOME OTHER LOGIC ERROR. IF YOU REALLY WANT TO TEST THE \u000aVALUE FOR BEING NULL, PERHAPS IT WOULD BE CLEARER TO DO BETTER TO DO A NULL \u000aTEST RATHER THAN AN INSTANCEOF TEST.\u000a,FIELD NAMES SHOULD START WITH A LOWER CASE LETTERTHE FIELD NAME {1} DOESN&apos;T START WITH A LOWER CASE LETTERBAD_PRACTICENAMES OF FIELDS THAT ARE NOT FINAL SHOULD BE IN MIXED CASE WITH A LOWERCASE \u000aFIRST LETTER AND THE FIRST LETTERS OF SUBSEQUENT WORDS CAPITALIZED.\u000a,CLASS NAMES SHOULD START WITH AN UPPER CASE LETTERTHE CLASS NAME {0} DOESN&apos;T START WITH AN UPPER CASE LETTERBAD_PRACTICECLASS NAMES SHOULD BE NOUNS, IN MIXED CASE WITH THE FIRST LETTER OF EACH \u000aINTERNAL WORD CAPITALIZED. TRY TO KEEP YOUR CLASS NAMES SIMPLE AND \u000aDESCRIPTIVE. USE WHOLE WORDS-AVOID ACRONYMS AND ABBREVIATIONS (UNLESS THE \u000aABBREVIATION IS MUCH MORE WIDELY USED THAN THE LONG FORM, SUCH AS URL OR HTML).\u000a,HASNEXT METHOD INVOKES NEXT{1} INVOKES {2.GIVENCLASS}CORRECTNESSTHE HASNEXT() METHOD INVOKES THE NEXT() METHOD. THIS IS ALMOST CERTAINLY \u000aWRONG, SINCE THE HASNEXT() METHOD IS NOT SUPPOSED TO CHANGE THE STATE OF THE \u000aITERATOR, AND THE NEXT METHOD IS SUPPOSED TO CHANGE THE STATE OF THE ITERATOR.\u000a,FORMAT STRING PLACEHOLDER INCOMPATIBLE WITH PASSED ARGUMENTTHE PLACEHOLDER {4} IS INCOMPATIBLE WITH\u000aCORRESPONDING ARGUMENT IN {1}CORRECTNESSTHE FORMAT STRING PLACEHOLDER IS INCOMPATIBLE WITH THE CORRESPONDING ARGUMENT. \u000aFOR EXAMPLE, SYSTEM.OUT.PRINTLN(&quot;%D\N&quot;, &quot;HELLO&quot;);  \u000aTHE %D PLACEHOLDER REQUIRES A NUMERIC ARGUMENT, BUT A STRING VALUE IS PASSED \u000aINSTEAD. A RUNTIME EXCEPTION WILL OCCUR WHEN THIS STATEMENT IS EXECUTED.\u000a,METHOD CONCATENATES STRINGS USING + IN A LOOP{1} CONCATENATES STRINGS USING + IN A LOOPPERFORMANCETHE METHOD SEEMS TO BE BUILDING A STRING USING CONCATENATION IN A LOOP. IN \u000aEACH ITERATION, THE STRING IS CONVERTED TO A STRINGBUFFER/STRINGBUILDER, \u000aAPPENDED TO, AND CONVERTED BACK TO A STRING. THIS CAN LEAD TO A COST QUADRATIC \u000aIN THE NUMBER OF ITERATIONS, AS THE GROWING STRING IS RECOPIED IN EACH \u000aITERATION. \u000aBETTER PERFORMANCE CAN BE OBTAINED BY USING A STRINGBUFFER (OR STRINGBUILDER \u000aIN JAVA 1.5) EXPLICITLY. \u000aFOR EXAMPLE: \u000a  // THIS IS BAD\u000a  STRING S = &quot;&quot;;\u000a  FOR (INT I = 0; I &lt; FIELD.LENGTH; ++I) {\u000a    S = S + FIELD[I];\u000a  }\u000a\u000a  // THIS IS BETTER\u000a  STRINGBUFFER BUF = NEW STRINGBUFFER();\u000a  FOR (INT I = 0; I &lt; FIELD.LENGTH; ++I) {\u000a    BUF.APPEND(FIELD[I]);\u000a  }\u000a  STRING S = BUF.TOSTRING();,NONSENSICAL SELF COMPUTATION INVOLVING A FIELD (E.G., X &amp; X)NONSENSICAL SELF COMPUTATION OF {2.GIVENCLASS} WITH ITSELF IN {1}CORRECTNESSTHIS METHOD PERFORMS A NONSENSICAL COMPUTATION OF A FIELD WITH ANOTHER \u000aREFERENCE TO THE SAME FIELD (E.G., X&amp;X OR X-X). BECAUSE OF THE NATURE OF THE \u000aCOMPUTATION, THIS OPERATION DOESN&apos;T SEEM TO MAKE SENSE, AND MAY INDICATE A \u000aTYPO OR A LOGIC ERROR. DOUBLE CHECK THE COMPUTATION.\u000a,USE OF CLASS WITHOUT A HASHCODE() METHOD IN A HASHED DATA STRUCTURE{2} DOESN&apos;T DEFINE A HASHCODE() METHOD BUT IS USED IN A HASHED DATA STRUCTURE IN {1}CORRECTNESSA CLASS DEFINES AN EQUALS(OBJECT) METHOD BUT NOT A HASHCODE() METHOD, AND THUS \u000aDOESN&apos;T FULFILL THE REQUIREMENT THAT EQUAL OBJECTS HAVE EQUAL HASHCODES. AN \u000aINSTANCE OF THIS CLASS IS USED IN A HASH DATA STRUCTURE, MAKING THE NEED TO \u000aFIX THIS PROBLEM OF HIGHEST IMPORTANCE.\u000a,DEAD STORE OF NULL TO LOCAL VARIABLEDEAD STORE OF NULL TO {2} IN {1}STYLETHE CODE STORES NULL INTO A LOCAL VARIABLE, AND THE STORED VALUE IS NOT READ. \u000aTHIS STORE MAY HAVE BEEN INTRODUCED TO ASSIST THE GARBAGE COLLECTOR, BUT AS OF \u000aJAVA SE 6.0, THIS IS NO LONGER NEEDED OR USEFUL.\u000a,CLASS IS SERIALIZABLE BUT ITS SUPERCLASS DOESN&apos;T DEFINE A VOID CONSTRUCTOR{0} IS SERIALIZABLE BUT ITS SUPERCLASS DOESN&apos;T DEFINE AN ACCESSIBLE VOID CONSTRUCTORBAD_PRACTICETHIS CLASS IMPLEMENTS THE SERIALIZABLE INTERFACE AND ITS SUPERCLASS DOES NOT. \u000aWHEN SUCH AN OBJECT IS DESERIALIZED, THE FIELDS OF THE SUPERCLASS NEED TO BE \u000aINITIALIZED BY INVOKING THE VOID CONSTRUCTOR OF THE SUPERCLASS. SINCE THE \u000aSUPERCLASS DOES NOT HAVE ONE, SERIALIZATION AND DESERIALIZATION WILL FAIL AT \u000aRUNTIME.\u000a,REDUNDANT COMPARISON OF NON-NULL VALUE TO NULLREDUNDANT COMPARISON OF NON-NULL VALUE TO NULL IN {1}STYLETHIS METHOD CONTAINS A REFERENCE KNOWN TO BE NON-NULL WITH ANOTHER REFERENCE \u000aKNOWN TO BE NULL.\u000a,FIELD NOT INITIALIZED IN CONSTRUCTOR BUT DEREFERENCED WITHOUT NULL CHECK{1.GIVENCLASS} NOT INITIALIZED IN CONSTRUCTOR AND DEREFERENCED IN {2}STYLETHIS FIELD IS NEVER INITIALIZED WITHIN ANY CONSTRUCTOR, AND IS THEREFORE COULD \u000aBE NULL AFTER THE OBJECT IS CONSTRUCTED. ELSEWHERE, IT IS LOADED AND \u000aDEREFERENCED WITHOUT A NULL CHECK. THIS COULD BE A EITHER AN ERROR OR A \u000aQUESTIONABLE DESIGN, SINCE IT MEANS A NULL POINTER EXCEPTION WILL BE GENERATED \u000aIF THAT FIELD IS DEREFERENCED BEFORE BEING INITIALIZED.\u000a,METHOD RELAXES NULLNESS ANNOTATION ON RETURN VALUEMETHOD {1} OVERRIDES THE RETURN VALUE NULLNESS ANNOTATION IN AN INCOMPATIBLE WAY.STYLEA METHOD SHOULD ALWAYS IMPLEMENT THE CONTRACT OF A METHOD IT OVERRIDES. THUS, \u000aIF A METHOD TAKES IS ANNOTATED AS RETURNING A @NONNULL VALUE, YOU SHOULDN&apos;T \u000aOVERRIDE THAT METHOD IN A SUBCLASS WITH A METHOD ANNOTATED AS RETURNING A \u000a@NULLABLE OR @CHECKFORNULL VALUE. DOING SO VIOLATES THE CONTRACT THAT THE \u000aMETHOD SHOULDN&apos;T RETURN NULL.\u000a,REMAINDER OF HASHCODE COULD BE NEGATIVEREMAINDER OF HASHCODE COULD BE NEGATIVE IN {1}STYLETHIS CODE COMPUTES A HASHCODE, AND THEN COMPUTES THE REMAINDER OF THAT VALUE \u000aMODULO ANOTHER VALUE. SINCE THE HASHCODE CAN BE NEGATIVE, THE RESULT OF THE \u000aREMAINDER OPERATION CAN ALSO BE NEGATIVE. \u000aASSUMING YOU WANT TO ENSURE THAT THE RESULT OF YOUR COMPUTATION IS \u000aNONNEGATIVE, YOU MAY NEED TO CHANGE YOUR CODE. IF YOU KNOW THE DIVISOR IS A \u000aPOWER OF 2, YOU CAN USE A BITWISE AND OPERATOR INSTEAD (I.E., INSTEAD OF USING X.HASHCODE()%N, \u000aUSE X.HASHCODE()&amp;(N-1). THIS IS PROBABLY FASTER THAN COMPUTING THE REMAINDER \u000aAS WELL. IF YOU DON&apos;T KNOW THAT THE DIVISOR IS A POWER OF 2, TAKE THE ABSOLUTE \u000aVALUE OF THE RESULT OF THE REMAINDER OPERATION (I.E., USE MATH.ABS(X.HASHCODE()%N)\u000a,SUSPICIOUS REFERENCE COMPARISON TO CONSTANTSUSPICIOUS COMPARISON OF A {2} REFERENCE TO CONSTANT IN {1}BAD_PRACTICETHIS METHOD COMPARES A REFERENCE VALUE TO A CONSTANT USING THE == OR != \u000aOPERATOR, WHERE THE CORRECT WAY TO COMPARE INSTANCES OF THIS TYPE IS GENERALLY \u000aWITH THE EQUALS() METHOD. IT IS POSSIBLE TO CREATE DISTINCT INSTANCES THAT ARE \u000aEQUAL BUT DO NOT COMPARE AS == SINCE THEY ARE DIFFERENT OBJECTS. EXAMPLES OF \u000aCLASSES WHICH SHOULD GENERALLY NOT BE COMPARED BY REFERENCE ARE \u000aJAVA.LANG.INTEGER, JAVA.LANG.FLOAT, ETC.\u000a,FIELD ISN&apos;T FINAL BUT SHOULD BE{1} ISN&apos;T FINAL BUT SHOULD BEMALICIOUS_CODETHIS STATIC FIELD PUBLIC BUT NOT FINAL, AND COULD BE CHANGED BY MALICIOUS CODE \u000aOR BY ACCIDENT FROM ANOTHER PACKAGE. THE FIELD COULD BE MADE FINAL TO AVOID \u000aTHIS VULNERABILITY.\u000a,INCORRECT LAZY INITIALIZATION OF STATIC FIELDINCORRECT LAZY INITIALIZATION OF STATIC FIELD {2} IN {1}MT_CORRECTNESSTHIS METHOD CONTAINS AN UNSYNCHRONIZED LAZY INITIALIZATION OF A NON-VOLATILE \u000aSTATIC FIELD. BECAUSE THE COMPILER OR PROCESSOR MAY REORDER INSTRUCTIONS, \u000aTHREADS ARE NOT GUARANTEED TO SEE A COMPLETELY INITIALIZED OBJECT, IF THE \u000aMETHOD CAN BE CALLED BY MULTIPLE THREADS. YOU CAN MAKE THE FIELD VOLATILE TO \u000aCORRECT THE PROBLEM. FOR MORE INFORMATION, SEE THE JAVA MEMORY MODEL WEB SITE.\u000a,UNEXPECTED/UNDESIRED WARNING FROM FINDBUGSUNEXPECTED/UNDESIRED {2} FINDBUGS WARNING IN {1}CORRECTNESSFINDBUGS GENERATED A WARNING THAT, ACCORDING TO A @NOWARNING ANNOTATED, IS \u000aUNEXPECTED OR UNDESIRED\u000a,SYNCHRONIZATION ON INTERNED STRING SYNCHRONIZATION ON INTERNED STRING IN {1}MT_CORRECTNESSTHE CODE SYNCHRONIZES ON INTERNED STRING. \u000aPRIVATE STATIC STRING LOCK = &quot;LOCK&quot;;\u000a...\u000a  SYNCHRONIZED(LOCK) { ...}\u000a...\u000aCONSTANT STRINGS ARE INTERNED AND SHARED ACROSS ALL OTHER CLASSES LOADED BY \u000aTHE JVM. THUS, THIS COULD IS LOCKING ON SOMETHING THAT OTHER CODE MIGHT ALSO \u000aBE LOCKING. THIS COULD RESULT IN VERY STRANGE AND HARD TO DIAGNOSE BLOCKING \u000aAND DEADLOCK BEHAVIOR. SEE HTTP://WWW.JAVALOBBY.ORG/JAVA/FORUMS/T96352.HTML \u000aAND HTTP://JIRA.CODEHAUS.ORG/BROWSE/JETTY-352. \u000aSEE CERT CON08-J. DO NOT SYNCHRONIZE ON OBJECTS THAT MAY BE REUSED FOR MORE \u000aINFORMATION.\u000a,NO RELATIONSHIP BETWEEN GENERIC PARAMETER AND METHOD ARGUMENT{2.GIVENCLASS} IS INCOMPATIBLE WITH EXPECTED ARGUMENT TYPE {3.GIVENCLASS} IN {1}CORRECTNESSTHIS CALL TO A GENERIC COLLECTION METHOD CONTAINS AN ARGUMENT WITH AN \u000aINCOMPATIBLE CLASS FROM THAT OF THE COLLECTION&apos;S PARAMETER (I.E., THE TYPE OF \u000aTHE ARGUMENT IS NEITHER A SUPERTYPE NOR A SUBTYPE OF THE CORRESPONDING GENERIC \u000aTYPE ARGUMENT). THEREFORE, IT IS UNLIKELY THAT THE COLLECTION CONTAINS ANY \u000aOBJECTS THAT ARE EQUAL TO THE METHOD ARGUMENT USED HERE. MOST LIKELY, THE \u000aWRONG VALUE IS BEING PASSED TO THE METHOD. \u000aIN GENERAL, INSTANCES OF TWO UNRELATED CLASSES ARE NOT EQUAL. FOR EXAMPLE, IF \u000aTHE FOO AND BAR CLASSES ARE NOT RELATED BY SUBTYPING, THEN AN INSTANCE OF FOO \u000aSHOULD NOT BE EQUAL TO AN INSTANCE OF BAR. AMONG OTHER ISSUES, DOING SO WILL \u000aLIKELY RESULT IN AN EQUALS METHOD THAT IS NOT SYMMETRICAL. FOR EXAMPLE, IF YOU \u000aDEFINE THE FOO CLASS SO THAT A FOO CAN BE EQUAL TO A STRING, YOUR EQUALS \u000aMETHOD ISN&apos;T SYMMETRICAL SINCE A STRING CAN ONLY BE EQUAL TO A STRING. \u000aIN RARE CASES, PEOPLE DO DEFINE NONSYMMETRICAL EQUALS METHODS AND STILL MANAGE \u000aTO MAKE THEIR CODE WORK. ALTHOUGH NONE OF THE APIS DOCUMENT OR GUARANTEE IT, \u000aIT IS TYPICALLY THE CASE THAT IF YOU CHECK IF A COLLECTION&lt;STRING> CONTAINS A FOO, \u000aTHE EQUALS METHOD OF ARGUMENT (E.G., THE EQUALS METHOD OF THE FOO CLASS) USED \u000aTO PERFORM THE EQUALITY CHECKS.\u000a,NON-SERIALIZABLE CLASS HAS A SERIALIZABLE INNER CLASS{0} IS SERIALIZABLE BUT ALSO AN INNER CLASS OF A NON-SERIALIZABLE CLASSBAD_PRACTICETHIS SERIALIZABLE CLASS IS AN INNER CLASS OF A NON-SERIALIZABLE CLASS. THUS, \u000aATTEMPTS TO SERIALIZE IT WILL ALSO ATTEMPT TO ASSOCIATE INSTANCE OF THE OUTER \u000aCLASS WITH WHICH IT IS ASSOCIATED, LEADING TO A RUNTIME ERROR. \u000aIF POSSIBLE, MAKING THE INNER CLASS A STATIC INNER CLASS SHOULD SOLVE THE \u000aPROBLEM. MAKING THE OUTER CLASS SERIALIZABLE MIGHT ALSO WORK, BUT THAT WOULD \u000aMEAN SERIALIZING AN INSTANCE OF THE INNER CLASS WOULD ALWAYS ALSO SERIALIZE \u000aTHE INSTANCE OF THE OUTER CLASS, WHICH IT OFTEN NOT WHAT YOU REALLY WANT.\u000a,USELESS INCREMENT IN RETURN STATEMENTUSELESS INCREMENT IN RETURN FROM {1}CORRECTNESSTHIS STATEMENT HAS A RETURN SUCH AS RETURN X++;. A POSTFIX INCREMENT/DECREMENT \u000aDOES NOT IMPACT THE VALUE OF THE EXPRESSION, SO THIS INCREMENT/DECREMENT HAS \u000aNO EFFECT. PLEASE VERIFY THAT THIS STATEMENT DOES THE RIGHT THING.\u000a,FINALIZER SHOULD BE PROTECTED, NOT PUBLIC{1} IS PUBLIC; SHOULD BE PROTECTEDMALICIOUS_CODEA CLASS&apos;S FINALIZE() METHOD SHOULD HAVE PROTECTED ACCESS, NOT PUBLIC.\u000a,BITWISE ADD OF SIGNED BYTE VALUEBITWISE ADD OF SIGNED BYTE VALUE COMPUTED IN {1} CORRECTNESSADDS A BYTE VALUE AND A VALUE WHICH IS KNOWN TO HAVE THE 8 LOWER BITS CLEAR. \u000aVALUES LOADED FROM A BYTE ARRAY ARE SIGN EXTENDED TO 32 BITS BEFORE ANY ANY \u000aBITWISE OPERATIONS ARE PERFORMED ON THE VALUE. THUS, IF B[0] CONTAINS THE \u000aVALUE 0XFF, AND X IS INITIALLY 0, THEN THE CODE ((X &lt;&lt; 8) + B[0]) WILL SIGN \u000aEXTEND 0XFF TO GET 0XFFFFFFFF, AND THUS GIVE THE VALUE 0XFFFFFFFF AS THE \u000aRESULT. \u000aIN PARTICULAR, THE FOLLOWING CODE FOR PACKING A BYTE ARRAY INTO AN INT IS \u000aBADLY WRONG: \u000aINT RESULT = 0;\u000aFOR(INT I = 0; I &lt; 4; I++)\u000a  RESULT = ((RESULT &lt;&lt; 8) + B[I]);\u000aTHE FOLLOWING IDIOM WILL WORK INSTEAD: \u000aINT RESULT = 0;\u000aFOR(INT I = 0; I &lt; 4; I++)\u000a  RESULT = ((RESULT &lt;&lt; 8) + (B[I] &amp; 0XFF));,METHOD CALL PASSES NULL TO A NONNULL PARAMETER NULL PASSED FOR NONNULL PARAMETER OF {2.GIVENCLASS} IN {1}CORRECTNESSTHIS METHOD PASSES A NULL VALUE AS THE PARAMETER OF A METHOD WHICH MUST BE \u000aNONNULL. EITHER THIS PARAMETER HAS BEEN EXPLICITLY MARKED AS @NONNULL, OR \u000aANALYSIS HAS DETERMINED THAT THIS PARAMETER IS ALWAYS DEREFERENCED.\u000a,LOAD OF KNOWN NULL VALUELOAD OF KNOWN NULL VALUE IN {1}STYLETHE VARIABLE REFERENCED AT THIS POINT IS KNOWN TO BE NULL DUE TO AN EARLIER \u000aCHECK AGAINST NULL. ALTHOUGH THIS IS VALID, IT MIGHT BE A MISTAKE (PERHAPS YOU \u000aINTENDED TO REFER TO A DIFFERENT VARIABLE, OR PERHAPS THE EARLIER CHECK TO SEE \u000aIF THE VARIABLE IS NULL SHOULD HAVE BEEN A CHECK TO SEE IF IT WAS NONNULL).\u000a,STATIC DATEFORMAT{1} IS A STATIC FIELD OF TYPE JAVA.TEXT.DATEFORMAT, WHICH ISN&apos;T THREAD SAFEMT_CORRECTNESSAS THE JAVADOC STATES, DATEFORMATS ARE INHERENTLY UNSAFE FOR MULTITHREADED \u000aUSE. SHARING A SINGLE INSTANCE ACROSS THREAD BOUNDARIES WITHOUT PROPER \u000aSYNCHRONIZATION WILL RESULT IN ERRATIC BEHAVIOR OF THE APPLICATION. \u000aYOU MAY ALSO EXPERIENCE SERIALIZATION PROBLEMS. \u000aUSING AN INSTANCE FIELD IS RECOMMENDED. \u000aFOR MORE INFORMATION ON THIS SEE SUN BUG #6231579 AND SUN BUG #6178997.\u000a,MISMATCHED WAIT()MISMATCHED WAIT() IN {1}MT_CORRECTNESSTHIS METHOD CALLS OBJECT.WAIT() WITHOUT OBVIOUSLY HOLDING A LOCK ON THE \u000aOBJECT.  CALLING WAIT() WITHOUT A LOCK HELD WILL RESULT IN AN ILLEGALMONITORSTATEEXCEPTION \u000aBEING THROWN.\u000a,MESSAGEFORMAT SUPPLIED WHERE PRINTF STYLE FORMAT EXPECTED{2} NEEDS PRINTF-STYLE FORMAT BUT CALLED WITH MESSAGEFORMATCORRECTNESSA METHOD IS CALLED THAT EXPECTS A JAVA PRINTF FORMAT STRING AND A LIST OF \u000aARGUMENTS. HOWEVER, THE FORMAT STRING DOESN&apos;T CONTAIN ANY FORMAT SPECIFIERS \u000a(E.G., %S) BUT DOES CONTAIN MESSAGE FORMAT ELEMENTS (E.G., {0}). IT IS LIKELY \u000aTHAT THE CODE IS SUPPLYING A MESSAGEFORMAT STRING WHEN A PRINTF-STYLE FORMAT \u000aSTRING IS REQUIRED. AT RUNTIME, ALL OF THE ARGUMENTS WILL BE IGNORED AND THE \u000aFORMAT STRING WILL BE RETURNED EXACTLY AS PROVIDED WITHOUT ANY FORMATTING.\u000a,INT VALUE CAST TO FLOAT AND THEN PASSED TO MATH.ROUNDINT VALUE CAST TO FLOAT AND THEN PASSED TO MATH.ROUND IN {1}CORRECTNESSTHIS CODE CONVERTS AN INT VALUE TO A FLOAT PRECISION FLOATING POINT NUMBER AND \u000aTHEN PASSING THE RESULT TO THE MATH.ROUND() FUNCTION, WHICH RETURNS THE \u000aINT/LONG CLOSEST TO THE ARGUMENT. THIS OPERATION SHOULD ALWAYS BE A NO-OP, \u000aSINCE THE CONVERTING AN INTEGER TO A FLOAT SHOULD GIVE A NUMBER WITH NO \u000aFRACTIONAL PART. IT IS LIKELY THAT THE OPERATION THAT GENERATED THE VALUE TO \u000aBE PASSED TO MATH.ROUND WAS INTENDED TO BE PERFORMED USING FLOATING POINT \u000aARITHMETIC.\u000a,INVALID SYNTAX FOR REGULAR EXPRESSIONINVALID SYNTAX FOR REGULAR EXPRESSION IN {1}CORRECTNESSTHE CODE HERE USES A REGULAR EXPRESSION THAT IS INVALID ACCORDING TO THE \u000aSYNTAX FOR REGULAR EXPRESSIONS. THIS STATEMENT WILL THROW A \u000aPATTERNSYNTAXEXCEPTION WHEN EXECUTED.\u000a,METHOD USES TOARRAY() WITH ZERO-LENGTH ARRAY ARGUMENT{1} USES COLLECTION.TOARRAY() WITH ZERO-LENGTH ARRAY ARGUMENTPERFORMANCETHIS METHOD USES THE TOARRAY() METHOD OF A COLLECTION DERIVED CLASS, AND \u000aPASSES IN A ZERO-LENGTH PROTOTYPE ARRAY ARGUMENT. IT IS MORE EFFICIENT TO USE MYCOLLECTION.TOARRAY(NEW \u000aFOO[MYCOLLECTION.SIZE()]) IF THE ARRAY PASSED IN IS BIG ENOUGH TO STORE ALL OF \u000aTHE ELEMENTS OF THE COLLECTION, THEN IT IS POPULATED AND RETURNED DIRECTLY. \u000aTHIS AVOIDS THE NEED TO CREATE A SECOND ARRAY (BY REFLECTION) TO RETURN AS THE \u000aRESULT.\u000a,QUESTIONABLE CAST TO ABSTRACT COLLECTION QUESTIONABLE CAST FROM COLLECTION TO ABSTRACT CLASS {3} IN {1}STYLETHIS CODE CASTS A COLLECTION TO AN ABSTRACT COLLECTION (SUCH AS LIST, SET, OR MAP). \u000aENSURE THAT YOU ARE GUARANTEED THAT THE OBJECT IS OF THE TYPE YOU ARE CASTING \u000aTO. IF ALL YOU NEED IS TO BE ABLE TO ITERATE THROUGH A COLLECTION, YOU DON&apos;T \u000aNEED TO CAST IT TO A SET OR LIST.\u000a,UNNECESSARY TYPE CHECK DONE USING INSTANCEOF OPERATOR{1} DOES AN UNNECESSARY TYPE CHECK USING INSTANCEOF OPERATOR WHEN IT CAN BE DETERMINED STATICALLYCORRECTNESSTYPE CHECK PERFORMED USING THE INSTANCEOF OPERATOR WHERE IT CAN BE STATICALLY \u000aDETERMINED WHETHER THE OBJECT IS OF THE TYPE REQUESTED.\u000a,RANDOM VALUE FROM 0 TO 1 IS COERCED TO THE INTEGER 0{1} USES GENERATES A RANDOM VALUE FROM 0 TO 1 AND THEN COERCES THAT VALUE TO THE INTEGER 0CORRECTNESSA RANDOM VALUE FROM 0 TO 1 IS BEING COERCED TO THE INTEGER VALUE 0. YOU \u000aPROBABLY WANT TO MULTIPLE THE RANDOM VALUE BY SOMETHING ELSE BEFORE COERCING \u000aIT TO AN INTEGER, OR USE THE RANDOM.NEXTINT(N) METHOD.\u000a,METHOD IGNORES RETURN VALUE, IS THIS OK?RETURN VALUE OF {2.GIVENCLASS} IGNORED, IS THIS OK IN {1}STYLETHIS CODE CALLS A METHOD AND IGNORES THE RETURN VALUE. THE RETURN VALUE IS THE \u000aSAME TYPE AS THE TYPE THE METHOD IS INVOKED ON, AND FROM OUR ANALYSIS IT LOOKS \u000aLIKE THE RETURN VALUE MIGHT BE IMPORTANT (E.G., LIKE IGNORING THE RETURN VALUE \u000aOF STRING.TOLOWERCASE()). \u000aWE ARE GUESSING THAT IGNORING THE RETURN VALUE MIGHT BE A BAD IDEA JUST FROM A \u000aSIMPLE ANALYSIS OF THE BODY OF THE METHOD. YOU CAN USE A @CHECKRETURNVALUE \u000aANNOTATION TO INSTRUCT FINDBUGS AS TO WHETHER IGNORING THE RETURN VALUE OF \u000aTHIS METHOD IS IMPORTANT OR ACCEPTABLE. \u000aPLEASE INVESTIGATE THIS CLOSELY TO DECIDE WHETHER IT IS OK TO IGNORE THE \u000aRETURN VALUE.\u000a,CLASS DEFINES EQUALS() AND USES OBJECT.HASHCODE(){0} DEFINES EQUALS AND USES OBJECT.HASHCODE()BAD_PRACTICETHIS CLASS OVERRIDES EQUALS(OBJECT), BUT DOES NOT OVERRIDE HASHCODE(), AND \u000aINHERITS THE IMPLEMENTATION OF HASHCODE() FROM JAVA.LANG.OBJECT (WHICH RETURNS \u000aTHE IDENTITY HASH CODE, AN ARBITRARY VALUE ASSIGNED TO THE OBJECT BY THE VM).  \u000aTHEREFORE, THE CLASS IS VERY LIKELY TO VIOLATE THE INVARIANT THAT EQUAL \u000aOBJECTS MUST HAVE EQUAL HASHCODES. \u000aIF YOU DON&apos;T THINK INSTANCES OF THIS CLASS WILL EVER BE INSERTED INTO A \u000aHASHMAP/HASHTABLE, THE RECOMMENDED HASHCODE IMPLEMENTATION TO USE IS: \u000aPUBLIC INT HASHCODE() {\u000a  ASSERT FALSE : &quot;HASHCODE NOT DESIGNED&quot;;\u000a  RETURN 42; // ANY ARBITRARY CONSTANT WILL DO\u000a  },IMPOSSIBLE DOWNCAST OF TOARRAY() RESULTIMPOSSIBLE DOWNCAST OF TOARRAY() RESULT TO {3} IN {1}CORRECTNESSTHIS CODE IS CASTING THE RESULT OF CALLING TOARRAY() ON A COLLECTION TO A TYPE \u000aMORE SPECIFIC THAN OBJECT[], AS IN: \u000aSTRING[] GETASARRAY(COLLECTION&lt;STRING> C) {\u000a  RETURN (STRING[]) C.TOARRAY();\u000a  }\u000aTHIS WILL USUALLY FAIL BY THROWING A CLASSCASTEXCEPTION. THE TOARRAY() OF \u000aALMOST ALL COLLECTIONS RETURN AN OBJECT[]. THEY CAN&apos;T REALLY DO ANYTHING ELSE, \u000aSINCE THE COLLECTION OBJECT HAS NO REFERENCE TO THE DECLARED GENERIC TYPE OF \u000aTHE COLLECTION. \u000aTHE CORRECT WAY TO DO GET AN ARRAY OF A SPECIFIC TYPE FROM A COLLECTION IS TO \u000aUSE C.TOARRAY(NEW STRING[]); OR C.TOARRAY(NEW STRING[C.SIZE()]); (THE LATTER \u000aIS SLIGHTLY MORE EFFICIENT). \u000aTHERE IS ONE COMMON/KNOWN EXCEPTION EXCEPTION TO THIS. THE TOARRAY() METHOD OF \u000aLISTS RETURNED BY ARRAYS.ASLIST(...) WILL RETURN A COVARIANTLY TYPED ARRAY. \u000aFOR EXAMPLE, ARRAYS.ASARRAY(NEW STRING[] { &quot;A&quot; }).TOARRAY() WILL RETURN A STRING \u000a[]. FINDBUGS ATTEMPTS TO DETECT AND SUPPRESS SUCH CASES, BUT MAY MISS SOME.\u000a,UNSIGNED RIGHT SHIFT CAST TO SHORT/BYTEUNSIGNED RIGHT SHIFT CAST TO SHORT/BYTE IN {1}STYLETHE CODE PERFORMS AN UNSIGNED RIGHT SHIFT, WHOSE RESULT IS THEN CAST TO A \u000aSHORT OR BYTE, WHICH DISCARDS THE UPPER BITS OF THE RESULT. SINCE THE UPPER \u000aBITS ARE DISCARDED, THERE MAY BE NO DIFFERENCE BETWEEN A SIGNED AND UNSIGNED \u000aRIGHT SHIFT (DEPENDING UPON THE SIZE OF THE SHIFT).\u000a,UNWRITTEN PUBLIC OR PROTECTED FIELDUNWRITTEN PUBLIC OR PROTECTED FIELD: {1}STYLENO WRITES WERE SEEN TO THIS PUBLIC/PROTECTED FIELD.  ALL READS OF IT WILL \u000aRETURN THE DEFAULT VALUE. CHECK FOR ERRORS (SHOULD IT HAVE BEEN INITIALIZED?), \u000aOR REMOVE IT IF IT IS USELESS.\u000a,VALUE WITHOUT A TYPE QUALIFIER USED WHERE A VALUE IS REQUIRED TO HAVE THAT QUALIFIERVALUE WITHOUT A TYPE QUALIFIER IS USED IN A PLACE THAT REQUIRES A {2.SIMPLENAME} ANNOTATIONCORRECTNESSA VALUE IS BEING USED IN A WAY THAT REQUIRES THE VALUE BE ANNOTATION WITH A \u000aTYPE QUALIFIER. THE TYPE QUALIFIER IS STRICT, SO THE TOOL REJECTS ANY VALUES \u000aTHAT DO NOT HAVE THE APPROPRIATE ANNOTATION. \u000aTO COERCE A VALUE TO HAVE A STRICT ANNOTATION, DEFINE AN IDENTITY FUNCTION \u000aWHERE THE RETURN VALUE IS ANNOTATED WITH THE STRICT ANNOTATION. THIS IS THE \u000aONLY WAY TO TURN A NON-ANNOTATED VALUE INTO A VALUE WITH A STRICT TYPE \u000aQUALIFIER ANNOTATION.\u000a,DOOMED TEST FOR EQUALITY TO NANDOOMED TEST FOR EQUALITY TO NAN IN {1}CORRECTNESSTHIS CODE CHECKS TO SEE IF A FLOATING POINT VALUE IS EQUAL TO THE SPECIAL NOT \u000aA NUMBER VALUE (E.G., IF (X == DOUBLE.NAN)). HOWEVER, BECAUSE OF THE SPECIAL \u000aSEMANTICS OF NAN, NO VALUE IS EQUAL TO NAN, INCLUDING NAN. THUS, X == \u000aDOUBLE.NAN ALWAYS EVALUATES TO FALSE. TO CHECK TO SEE IF A VALUE CONTAINED IN X \u000aIS THE SPECIAL NOT A NUMBER VALUE, USE DOUBLE.ISNAN(X) (OR FLOAT.ISNAN(X) IF X \u000aIS FLOATING POINT PRECISION).\u000a,NEGATING THE RESULT OF COMPARETO()/COMPARE(){1} NEGATES THE RETURN VALUE OF {2}BAD_PRACTICETHIS CODE NEGATIVES THE RETURN VALUE OF A COMPARETO OR COMPARE METHOD. THIS IS \u000aA QUESTIONABLE OR BAD PROGRAMMING PRACTICE, SINCE IF THE RETURN VALUE IS \u000aINTEGER.MIN_VALUE, NEGATING THE RETURN VALUE WON&apos;T NEGATE THE SIGN OF THE \u000aRESULT. YOU CAN ACHIEVE THE SAME INTENDED RESULT BY REVERSING THE ORDER OF THE \u000aOPERANDS RATHER THAN BY NEGATING THE RESULTS.\u000a,MORE ARGUMENTS ARE PASSED THAN ARE ACTUALLY USED IN THE FORMAT STRINGFORMAT-STRING METHOD {2} CALLED WITH FORMAT STRING &quot;{3}&quot; WANTS {4} ARGUMENTS BUT IS GIVEN {5} IN {1}CORRECTNESSA FORMAT-STRING METHOD WITH A VARIABLE NUMBER OF ARGUMENTS IS CALLED, BUT MORE \u000aARGUMENTS ARE PASSED THAN ARE ACTUALLY USED BY THE FORMAT STRING. THIS WON&apos;T \u000aCAUSE A RUNTIME EXCEPTION, BUT THE CODE MAY BE SILENTLY OMITTING INFORMATION \u000aTHAT WAS INTENDED TO BE INCLUDED IN THE FORMATTED STRING.\u000a,VALUE THAT MIGHT CARRY A TYPE QUALIFIER IS ALWAYS USED IN A WAY PROHIBITS IT FROM HAVING THAT TYPE QUALIFIERVALUE THAT MIGHT CARRY THE {2.SIMPLENAME} ANNOTATION IS ALWAYS USED IN A WAY THAT PROHIBITS IT FROM HAVING THAT TYPE QUALIFIERCORRECTNESSA VALUE THAT IS ANNOTATED AS POSSIBILITY BEING AN INSTANCE OF THE VALUES \u000aDENOTED BY THE TYPE QUALIFIER, AND THE VALUE IS GUARANTEED TO BE USED IN A WAY \u000aTHAT PROHIBITS VALUES DENOTED BY THAT TYPE QUALIFIER.\u000a,VALUE ANNOTATED AS NEVER CARRYING A TYPE QUALIFIER USED WHERE VALUE CARRYING THAT QUALIFIER IS REQUIREDVALUE ANNOTATED AS NEVER CARRYING TYPE QUALIFIER {2.SIMPLENAME} USED WHERE VALUE CARRYING THAT QUALIFIER IS REQUIREDCORRECTNESSA VALUE SPECIFIED AS NOT CARRYING A TYPE QUALIFIER ANNOTATION IS GUARANTEED TO \u000aBE CONSUMED IN A LOCATION OR LOCATIONS REQUIRING THAT THE VALUE DOES CARRY \u000aTHAT ANNOTATION. \u000aMORE PRECISELY, A VALUE ANNOTATED WITH A TYPE QUALIFIER SPECIFYING WHEN=NEVER \u000aIS GUARANTEED TO REACH A USE OR USES WHERE THE SAME TYPE QUALIFIER SPECIFIES \u000aWHEN=ALWAYS. \u000aTODO: EXAMPLE\u000a,DEAD STORE OF CLASS LITERALDEAD STORE OF {3}.CLASS IN {1}CORRECTNESSTHIS INSTRUCTION ASSIGNS A CLASS LITERAL TO A VARIABLE AND THEN NEVER USES IT. THE \u000aBEHAVIOR OF THIS DIFFERS IN JAVA 1.4 AND IN JAVA 5. IN JAVA 1.4 AND EARLIER, A \u000aREFERENCE TO FOO.CLASS WOULD FORCE THE STATIC INITIALIZER FOR FOO TO BE \u000aEXECUTED, IF IT HAS NOT BEEN EXECUTED ALREADY. IN JAVA 5 AND LATER, IT DOES \u000aNOT. \u000aSEE SUN&apos;S ARTICLE ON JAVA SE COMPATIBILITY FOR MORE DETAILS AND EXAMPLES, AND \u000aSUGGESTIONS ON HOW TO FORCE CLASS INITIALIZATION IN JAVA 5.\u000a,METHOD ATTEMPTS TO ACCESS A RESULT SET FIELD WITH INDEX 0{1} ATTEMPTS TO ACCESS A RESULT SET FIELD WITH INDEX 0CORRECTNESSA CALL TO GETXXX OR UPDATEXXX METHODS OF A RESULT SET WAS MADE WHERE THE FIELD \u000aINDEX IS 0. AS RESULTSET FIELDS START AT INDEX 1, THIS IS ALWAYS A MISTAKE.\u000a,DOUBLE ASSIGNMENT OF LOCAL VARIABLE DOUBLE ASSIGNMENT OF {2} IN {1}STYLETHIS METHOD CONTAINS A DOUBLE ASSIGNMENT OF A LOCAL VARIABLE; E.G. \u000a  PUBLIC VOID FOO() {\u000a    INT X,Y;\u000a    X = X = 17;\u000a  }\u000aASSIGNING THE SAME VALUE TO A VARIABLE TWICE IS USELESS, AND MAY INDICATE A \u000aLOGIC ERROR OR TYPO.\u000a,BAD ATTEMPT TO COMPUTE ABSOLUTE VALUE OF SIGNED 32-BIT HASHCODE BAD ATTEMPT TO COMPUTE ABSOLUTE VALUE OF SIGNED 32-BIT HASHCODE IN {1}CORRECTNESSTHIS CODE GENERATES A HASHCODE AND THEN COMPUTES THE ABSOLUTE VALUE OF THAT \u000aHASHCODE. IF THE HASHCODE IS INTEGER.MIN_VALUE, THEN THE RESULT WILL BE \u000aNEGATIVE AS WELL (SINCE MATH.ABS(INTEGER.MIN_VALUE) == INTEGER.MIN_VALUE). \u000aONE OUT OF 2^32 STRINGS HAVE A HASHCODE OF INTEGER.MIN_VALUE, INCLUDING \u000a&quot;POLYGENELUBRICANTS&quot; &quot;GYDZG_&quot; AND &quot;&quot;DESIGNING WORKHOUSES&quot;.\u000a,INCOMPATIBLE BIT MASKSINCOMPATIBLE BIT MASKS IN (E | {2} == {3}) YIELDS CONSTANT RESULT IN {1}CORRECTNESSTHIS METHOD COMPARES AN EXPRESSION OF THE FORM (E | C) TO D. WHICH WILL ALWAYS \u000aCOMPARE UNEQUAL DUE TO THE SPECIFIC VALUES OF CONSTANTS C AND D. THIS MAY \u000aINDICATE A LOGIC ERROR OR TYPO. \u000aTYPICALLY, THIS BUG OCCURS BECAUSE THE CODE WANTS TO PERFORM A MEMBERSHIP TEST \u000aIN A BIT SET, BUT USES THE BITWISE OR OPERATOR (&quot;|&quot;) INSTEAD OF BITWISE AND \u000a(&quot;&amp;&quot;).\u000a,EQUALS() METHOD DEFINED THAT DOESN&apos;T OVERRIDE OBJECT.EQUALS(OBJECT){0} DEFINES {1.GIVENCLASS} METHOD AND USES OBJECT.EQUALS(OBJECT)CORRECTNESSTHIS CLASS DEFINES AN EQUALS() METHOD, THAT DOESN&apos;T OVERRIDE THE NORMAL EQUALS(OBJECT) \u000aMETHOD DEFINED IN THE BASE JAVA.LANG.OBJECT CLASS.  THE CLASS SHOULD PROBABLY \u000aDEFINE A BOOLEAN EQUALS(OBJECT) METHOD.\u000a,VERY CONFUSING METHOD NAMESVERY CONFUSING TO HAVE METHODS {1} AND {3}CORRECTNESSTHE REFERENCED METHODS HAVE NAMES THAT DIFFER ONLY BY CAPITALIZATION. THIS IS \u000aVERY CONFUSING BECAUSE IF THE CAPITALIZATION WERE IDENTICAL THEN ONE OF THE \u000aMETHODS WOULD OVERRIDE THE OTHER.\u000a,ABSTRACT METHOD IS ALREADY DEFINED IN IMPLEMENTED INTERFACEABSTRACT METHOD {1} IS ALREADY DEFINED IN IMPLEMENTED INTERFACESTYLETHIS ABSTRACT METHOD IS ALREADY DEFINED IN AN INTERFACE THAT IS IMPLEMENTED BY \u000aTHIS ABSTRACT CLASS. THIS METHOD CAN BE REMOVED, AS IT PROVIDES NO ADDITIONAL \u000aVALUE.\u000a,ILLEGAL FORMAT STRINGILLEGAL FORMAT STRING &quot;{3}&quot; IN {1}CORRECTNESSTHE FORMAT STRING IS SYNTACTICALLY INVALID, AND A RUNTIME EXCEPTION WILL OCCUR \u000aWHEN THIS STATEMENT IS EXECUTED.\u000a,ITERATOR NEXT() METHOD CAN&apos;T THROW NOSUCHELEMENTEXCEPTION{1} CAN&apos;T THROW NOSUCHELEMENTEXCEPTIONBAD_PRACTICETHIS CLASS IMPLEMENTS THE JAVA.UTIL.ITERATOR INTERFACE.  HOWEVER, ITS NEXT() \u000aMETHOD IS NOT CAPABLE OF THROWING JAVA.UTIL.NOSUCHELEMENTEXCEPTION.  THE NEXT() \u000aMETHOD SHOULD BE CHANGED SO IT THROWS NOSUCHELEMENTEXCEPTION IF IS CALLED WHEN \u000aTHERE ARE NO MORE ELEMENTS TO RETURN.\u000a,FIELD IS A MUTABLE ARRAY{1} IS A MUTABLE ARRAYMALICIOUS_CODEA FINAL STATIC FIELD REFERENCES AN ARRAY AND CAN BE ACCESSED BY MALICIOUS CODE \u000aOR BY ACCIDENT FROM ANOTHER PACKAGE. THIS CODE CAN FREELY MODIFY THE CONTENTS \u000aOF THE ARRAY.\u000a,INVOCATION OF SUBSTRING(0), WHICH RETURNS THE ORIGINAL VALUE{1} INVOKES SUBSTRING(0), WHICH RETURNS THE ORIGINAL VALUESTYLETHIS CODE INVOKES SUBSTRING(0) ON A STRING, WHICH RETURNS THE ORIGINAL VALUE.\u000a,METHOD INVOKES INEFFICIENT FLOATING-POINT NUMBER CONSTRUCTOR; USE STATIC VALUEOF INSTEAD{1} INVOKES INEFFICIENT {2} CONSTRUCTOR; USE {3} INSTEADPERFORMANCEUSING NEW DOUBLE(DOUBLE) IS GUARANTEED TO ALWAYS RESULT IN A NEW OBJECT \u000aWHEREAS DOUBLE.VALUEOF(DOUBLE) ALLOWS CACHING OF VALUES TO BE DONE BY THE \u000aCOMPILER, CLASS LIBRARY, OR JVM. USING OF CACHED VALUES AVOIDS OBJECT \u000aALLOCATION AND THE CODE WILL BE FASTER. \u000aUNLESS THE CLASS MUST BE COMPATIBLE WITH JVMS PREDATING JAVA 1.5, USE EITHER \u000aAUTOBOXING OR THE VALUEOF() METHOD WHEN CREATING INSTANCES OF DOUBLE AND FLOAT.\u000a,32 BIT INT SHIFTED BY AN AMOUNT NOT IN THE RANGE -31..3132 BIT INT SHIFTED BY {2} BITS IN {1}CORRECTNESSTHE CODE PERFORMS SHIFT OF A 32 BIT INT BY A CONSTANT AMOUNT OUTSIDE THE RANGE \u000a-31..31. THE EFFECT OF THIS IS TO USE THE LOWER 5 BITS OF THE INTEGER VALUE TO \u000aDECIDE HOW MUCH TO SHIFT BY (E.G., SHIFTING BY 40 BITS IS THE SAME AS SHIFTING \u000aBY 8 BITS, AND SHIFTING BY 32 BITS IS THE SAME AS SHIFTING BY ZERO BITS). THIS \u000aPROBABLY ISN&apos;T WHAT WAS EXPECTED, AND IT IS AT LEAST CONFUSING.\u000a,UNREAD FIELD: SHOULD THIS FIELD BE STATIC?UNREAD FIELD: {1}; SHOULD THIS FIELD BE STATIC?PERFORMANCETHIS CLASS CONTAINS AN INSTANCE FINAL FIELD THAT IS INITIALIZED TO A \u000aCOMPILE-TIME STATIC VALUE. CONSIDER MAKING THE FIELD STATIC.\u000a,METHOD MIGHT DROP EXCEPTION{1} MIGHT DROP {2}BAD_PRACTICETHIS METHOD MIGHT DROP AN EXCEPTION.  IN GENERAL, EXCEPTIONS SHOULD BE HANDLED \u000aOR REPORTED IN SOME WAY, OR THEY SHOULD BE THROWN OUT OF THE METHOD.\u000a,EMPTY SYNCHRONIZED BLOCKEMPTY SYNCHRONIZED BLOCK IN {1}MT_CORRECTNESSTHE CODE CONTAINS AN EMPTY SYNCHRONIZED BLOCK: \u000aSYNCHRONIZED() {}\u000aEMPTY SYNCHRONIZED BLOCKS ARE FAR MORE SUBTLE AND HARD TO USE CORRECTLY THAN \u000aMOST PEOPLE RECOGNIZE, AND EMPTY SYNCHRONIZED BLOCKS ARE ALMOST NEVER A BETTER \u000aSOLUTION THAN LESS CONTRIVED SOLUTIONS.\u000a,CLASS EXTENDS SERVLET CLASS AND USES INSTANCE VARIABLESCLASS {0} EXTENDS SERVLET CLASS AND USES INSTANCE VARIABLESSTYLETHIS CLASS EXTENDS FROM A SERVLET CLASS, AND USES AN INSTANCE MEMBER VARIABLE. \u000aSINCE ONLY ONE INSTANCE OF A SERVLET CLASS IS CREATED BY THE J2EE FRAMEWORK, \u000aAND USED IN A MULTITHREADED WAY, THIS PARADIGM IS HIGHLY DISCOURAGED AND MOST \u000aLIKELY PROBLEMATIC. CONSIDER ONLY USING METHOD LOCAL VARIABLES.\u000a,A PREPARED STATEMENT IS GENERATED FROM A NONCONSTANT STRINGA PREPARED STATEMENT IS GENERATED FROM A NONCONSTANT STRING IN {1} SECURITYTHE CODE CREATES AN SQL PREPARED STATEMENT FROM A NONCONSTANT STRING. IF \u000aUNCHECKED, TAINTED DATA FROM A USER IS USED IN BUILDING THIS STRING, SQL \u000aINJECTION COULD BE USED TO MAKE THE PREPARED STATEMENT DO SOMETHING UNEXPECTED \u000aAND UNDESIRABLE.\u000a,COVARIANT EQUALS() METHOD DEFINED{0} DEFINES EQUALS({0.GIVENCLASS}) METHOD BUT NOT EQUALS(OBJECT)BAD_PRACTICETHIS CLASS DEFINES A COVARIANT VERSION OF EQUALS().  TO CORRECTLY OVERRIDE THE EQUALS() \u000aMETHOD IN JAVA.LANG.OBJECT, THE PARAMETER OF EQUALS() MUST HAVE TYPE JAVA.LANG.OBJECT.\u000a,CLASS EXTENDS STRUTS ACTION CLASS AND USES INSTANCE VARIABLESCLASS {0} EXTENDS STRUTS ACTION CLASS AND USES INSTANCE VARIABLESSTYLETHIS CLASS EXTENDS FROM A STRUTS ACTION CLASS, AND USES AN INSTANCE MEMBER \u000aVARIABLE. SINCE ONLY ONE INSTANCE OF A STRUTS ACTION CLASS IS CREATED BY THE \u000aSTRUTS FRAMEWORK, AND USED IN A MULTITHREADED WAY, THIS PARADIGM IS HIGHLY \u000aDISCOURAGED AND MOST LIKELY PROBLEMATIC. CONSIDER ONLY USING METHOD LOCAL \u000aVARIABLES. ONLY INSTANCE FIELDS THAT ARE WRITTEN OUTSIDE OF A MONITOR ARE \u000aREPORTED.\u000a,THE READRESOLVE METHOD MUST BE DECLARED WITH A RETURN TYPE OF OBJECT. THE METHOD {1} MUST BE DECLARED WITH A RETURN TYPE OF OBJECT RATHER THAN {1.RETURNTYPE}BAD_PRACTICEIN ORDER FOR THE READRESOLVE METHOD TO BE RECOGNIZED BY THE SERIALIZATION \u000aMECHANISM, IT MUST BE DECLARED TO HAVE A RETURN TYPE OF OBJECT.\u000a,EMPTY DATABASE PASSWORDEMPTY DATABASE PASSWORD IN {1}SECURITYTHIS CODE CREATES A DATABASE CONNECT USING A BLANK OR EMPTY PASSWORD. THIS \u000aINDICATES THAT THE DATABASE IS NOT PROTECTED BY A PASSWORD.\u000a,INEFFICIENT USE OF STRING.INDEXOF(STRING){1} USES STRING.INDEXOF(STRING) INSTEAD OF STRING.INDEXOF(INT)PERFORMANCETHIS CODE PASSES A CONSTANT STRING OF LENGTH 1 TO STRING.INDEXOF(). IT IS MORE \u000aEFFICIENT TO USE THE INTEGER IMPLEMENTATIONS OF STRING.INDEXOF(). F. E. CALL MYSTRING.INDEXOF(&apos;.&apos;) \u000aINSTEAD OF MYSTRING.INDEXOF(&quot;.&quot;)\u000a,CLASS&apos;S WRITEOBJECT() METHOD IS SYNCHRONIZED BUT NOTHING ELSE IS{0}&apos;S WRITEOBJECT METHOD IS SYNCHRONIZED BUT NOTHING ELSE ISMT_CORRECTNESSTHIS CLASS HAS A WRITEOBJECT() METHOD WHICH IS SYNCHRONIZED; HOWEVER, NO OTHER \u000aMETHOD OF THE CLASS IS SYNCHRONIZED.\u000a,SERIALIZABLE INNER CLASS{0} IS SERIALIZABLE AND AN INNER CLASSBAD_PRACTICETHIS SERIALIZABLE CLASS IS AN INNER CLASS. ANY ATTEMPT TO SERIALIZE IT WILL \u000aALSO SERIALIZE THE ASSOCIATED OUTER INSTANCE. THE OUTER INSTANCE IS \u000aSERIALIZABLE, SO THIS WON&apos;T FAIL, BUT IT MIGHT SERIALIZE A LOT MORE DATA THAN \u000aINTENDED. IF POSSIBLE, MAKING THE INNER CLASS A STATIC INNER CLASS (ALSO KNOWN \u000aAS A NESTED CLASS) SHOULD SOLVE THE PROBLEM.\u000a,TRANSIENT FIELD OF CLASS THAT ISN&apos;T SERIALIZABLE. {1.GIVENCLASS} IS TRANSIENT BUT {0} ISN&apos;T SERIALIZABLESTYLETHE FIELD IS MARKED AS TRANSIENT, BUT THE CLASS ISN&apos;T SERIALIZABLE, SO MARKING \u000aIT AS TRANSIENT HAS ABSOLUTELY NO EFFECT. THIS MAY BE LEFTOVER MARKING FROM A \u000aPREVIOUS VERSION OF THE CODE IN WHICH THE CLASS WAS TRANSIENT, OR IT MAY \u000aINDICATE A MISUNDERSTANDING OF HOW SERIALIZATION WORKS.\u000a,BAD ATTEMPT TO COMPUTE ABSOLUTE VALUE OF SIGNED RANDOM INTEGERBAD ATTEMPT TO COMPUTE ABSOLUTE VALUE OF SIGNED RANDOM INTEGER IN {1}CORRECTNESSTHIS CODE GENERATES A RANDOM SIGNED INTEGER AND THEN COMPUTES THE ABSOLUTE \u000aVALUE OF THAT RANDOM INTEGER. IF THE NUMBER RETURNED BY THE RANDOM NUMBER \u000aGENERATOR IS INTEGER.MIN_VALUE, THEN THE RESULT WILL BE NEGATIVE AS WELL \u000a(SINCE MATH.ABS(INTEGER.MIN_VALUE) == INTEGER.MIN_VALUE). (SAME PROBLEM ARISED \u000aFOR LONG VALUES AS WELL).\u000a,CLASS IMPLEMENTS SAME INTERFACE AS SUPERCLASSCLASS {0} IMPLEMENTS SAME INTERFACE AS SUPERCLASSSTYLETHIS CLASS DECLARES THAT IT IMPLEMENTS AN INTERFACE THAT IS ALSO IMPLEMENTED \u000aBY A SUPERCLASS. THIS IS REDUNDANT BECAUSE ONCE A SUPERCLASS IMPLEMENTS AN \u000aINTERFACE, ALL SUBCLASSES BY DEFAULT ALSO IMPLEMENT THIS INTERFACE. IT MAY \u000aPOINT OUT THAT THE INHERITANCE HIERARCHY HAS CHANGED SINCE THIS CLASS WAS \u000aCREATED, AND CONSIDERATION SHOULD BE GIVEN TO THE OWNERSHIP OF THE INTERFACE&apos;S \u000aIMPLEMENTATION.\u000a,COLLECTIONS SHOULD NOT CONTAIN THEMSELVESCOLLECTIONS SHOULD NOT CONTAIN THEMSELVES IN CALL TO {2.GIVENCLASS}CORRECTNESSTHIS CALL TO A GENERIC COLLECTION&apos;S METHOD WOULD ONLY MAKE SENSE IF A \u000aCOLLECTION CONTAINED ITSELF (E.G., IF S.CONTAINS(S) WERE TRUE). THIS IS \u000aUNLIKELY TO BE TRUE AND WOULD CAUSE PROBLEMS IF IT WERE TRUE (SUCH AS THE \u000aCOMPUTATION OF THE HASH CODE RESULTING IN INFINITE RECURSION). IT IS LIKELY \u000aTHAT THE WRONG VALUE IS BEING PASSED AS A PARAMETER.\u000a,CALL TO STATIC DATEFORMATCALL TO METHOD OF STATIC JAVA.TEXT.DATEFORMAT IN {1}MT_CORRECTNESSAS THE JAVADOC STATES, DATEFORMATS ARE INHERENTLY UNSAFE FOR MULTITHREADED \u000aUSE. THE DETECTOR HAS FOUND A CALL TO AN INSTANCE OF DATEFORMAT THAT HAS BEEN \u000aOBTAINED VIA A STATIC FIELD. THIS LOOKS SUSPICOUS. \u000aFOR MORE INFORMATION ON THIS SEE SUN BUG #6231579 AND SUN BUG #6178997.\u000a,AN APPARENT INFINITE LOOPTHERE IS AN APPARENT INFINITE LOOP IN {1}CORRECTNESSTHIS LOOP DOESN&apos;T SEEM TO HAVE A WAY TO TERMINATE (OTHER THAN BY PERHAPS \u000aTHROWING AN EXCEPTION).\u000a,NEEDLESS INSTANTIATION OF CLASS THAT ONLY SUPPLIES STATIC METHODS{1} NEEDLESSLY INSTANTIATES A CLASS THAT ONLY SUPPLIES STATIC METHODSBAD_PRACTICETHIS CLASS ALLOCATES AN OBJECT THAT IS BASED ON A CLASS THAT ONLY SUPPLIES \u000aSTATIC METHODS. THIS OBJECT DOES NOT NEED TO BE CREATED, JUST ACCESS THE \u000aSTATIC METHODS DIRECTLY USING THE CLASS NAME AS A QUALIFIER.\u000a,COMPARISON OF STRING OBJECTS USING == OR !=COMPARISON OF STRING OBJECTS USING == OR != IN {1} BAD_PRACTICETHIS CODE COMPARES JAVA.LANG.STRING OBJECTS FOR REFERENCE EQUALITY USING THE \u000a== OR != OPERATORS. UNLESS BOTH STRINGS ARE EITHER CONSTANTS IN A SOURCE FILE, \u000aOR HAVE BEEN INTERNED USING THE STRING.INTERN() METHOD, THE SAME STRING VALUE \u000aMAY BE REPRESENTED BY TWO DIFFERENT STRING OBJECTS. CONSIDER USING THE EQUALS(OBJECT) \u000aMETHOD INSTEAD.\u000a,CLASS DEFINES FIELD THAT MASKS A SUPERCLASS FIELDFIELD {1.GIVENCLASS} MASKS FIELD IN SUPERCLASS {2.CLASS}CORRECTNESSTHIS CLASS DEFINES A FIELD WITH THE SAME NAME AS A VISIBLE INSTANCE FIELD IN A \u000aSUPERCLASS. THIS IS CONFUSING, AND MAY INDICATE AN ERROR IF METHODS UPDATE OR \u000aACCESS ONE OF THE FIELDS WHEN THEY WANTED THE OTHER.\u000a,NULL POINTER DEREFERENCENULL POINTER DEREFERENCE OF {2.GIVENCLASS} IN {1}CORRECTNESSA NULL POINTER IS DEREFERENCED HERE.  THIS WILL LEAD TO A NULLPOINTEREXCEPTION \u000aWHEN THE CODE IS EXECUTED.\u000a,METHOD INVOKES INEFFICIENT BOOLEAN CONSTRUCTOR; USE BOOLEAN.VALUEOF(...) INSTEAD{1} INVOKES INEFFICIENT BOOLEAN CONSTRUCTOR; USE BOOLEAN.VALUEOF(...) INSTEADPERFORMANCECREATING NEW INSTANCES OF JAVA.LANG.BOOLEAN WASTES MEMORY, SINCE BOOLEAN \u000aOBJECTS ARE IMMUTABLE AND THERE ARE ONLY TWO USEFUL VALUES OF THIS TYPE.  USE \u000aTHE BOOLEAN.VALUEOF() METHOD (OR JAVA 1.5 AUTOBOXING) TO CREATE BOOLEAN \u000aOBJECTS INSTEAD.\u000a,EQUALS CHECKS FOR INCOMPATIBLE OPERAND{1} CHECKS FOR OPERAND BEING A {2.GIVENCLASS} BAD_PRACTICETHIS EQUALS METHOD IS CHECKING TO SEE IF THE ARGUMENT IS SOME INCOMPATIBLE \u000aTYPE (I.E., A CLASS THAT IS NEITHER A SUPERTYPE NOR SUBTYPE OF THE CLASS THAT \u000aDEFINES THE EQUALS METHOD). FOR EXAMPLE, THE FOO CLASS MIGHT HAVE AN EQUALS \u000aMETHOD THAT LOOKS LIKE: \u000aPUBLIC BOOLEAN EQUALS(OBJECT O) {\u000a  IF (O INSTANCEOF FOO)\u000a    RETURN NAME.EQUALS(((FOO)O).NAME);\u000a  ELSE IF (O INSTANCEOF STRING)\u000a    RETURN NAME.EQUALS(O);\u000a  ELSE RETURN FALSE;\u000aTHIS IS CONSIDERED BAD PRACTICE, AS IT MAKES IT VERY HARD TO IMPLEMENT AN \u000aEQUALS METHOD THAT IS SYMMETRIC AND TRANSITIVE. WITHOUT THOSE PROPERTIES, VERY \u000aUNEXPECTED BEHAVOIRS ARE POSSIBLE.\u000a,SERVLET REFLECTED CROSS SITE SCRIPTING VULNERABILITYHTTP PARAMETER WRITTEN TO SERVLET OUTPUT IN {1}SECURITYTHIS CODE DIRECTLY WRITES AN HTTP PARAMETER TO SERVLET OUTPUT, WHICH ALLOWS \u000aFOR A REFLECTED CROSS SITE SCRIPTING VULNERABILITY. SEE HTTP://EN.WIKIPEDIA.ORG/WIKI/CROSS-SITE_SCRIPTING \u000aFOR MORE INFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF CROSS SITE \u000aSCRIPTING. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE CROSS SITE \u000aSCRIPTING VULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED \u000aABOUT CROSS SITE SCRIPTING, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL \u000aSTATIC ANALYSIS OR PEN-TESTING TOOL.\u000a,METHOD MAY FAIL TO CLOSE DATABASE RESOURCE{1} MAY FAIL TO CLOSE {2.EXCLUDINGPACKAGE}BAD_PRACTICETHE METHOD CREATES A DATABASE RESOURCE (SUCH AS A DATABASE CONNECTION OR ROW \u000aSET), DOES NOT ASSIGN IT TO ANY FIELDS, PASS IT TO OTHER METHODS, OR RETURN \u000aIT, AND DOES NOT APPEAR TO CLOSE THE OBJECT ON ALL PATHS OUT OF THE METHOD.  \u000aFAILURE TO CLOSE DATABASE RESOURCES ON ALL PATHS OUT OF A METHOD MAY RESULT IN \u000aPOOR PERFORMANCE, AND COULD CAUSE THE APPLICATION TO HAVE PROBLEMS \u000aCOMMUNICATING WITH THE DATABASE.\u000a,SEQUENCE OF CALLS TO CONCURRENT ABSTRACTION MAY NOT BE ATOMICSEQUENCE OF CALLS TO {2} MAY NOT BE ATOMIC IN {1}MT_CORRECTNESSTHIS CODE CONTAINS A SEQUENCE OF CALLS TO A CONCURRENT ABSTRACTION (SUCH AS A \u000aCONCURRENT HASH MAP). THESE CALLS WILL NOT BE EXECUTED ATOMICALLY.\u000a,COMPARISON OF STRING PARAMETER USING == OR !=COMPARISON OF STRING PARAMETER USING == OR != IN {1} BAD_PRACTICETHIS CODE COMPARES A JAVA.LANG.STRING PARAMETER FOR REFERENCE EQUALITY USING \u000aTHE == OR != OPERATORS. REQUIRING CALLERS TO PASS ONLY STRING CONSTANTS OR \u000aINTERNED STRINGS TO A METHOD IS UNNECESSARILY FRAGILE, AND RARELY LEADS TO \u000aMEASURABLE PERFORMANCE GAINS. CONSIDER USING THE EQUALS(OBJECT) METHOD INSTEAD.\u000a,TRANSIENT FIELD THAT ISN&apos;T SET BY DESERIALIZATION. THE FIELD {1} IS TRANSIENT BUT ISN&apos;T SET BY DESERIALIZATIONBAD_PRACTICETHIS CLASS CONTAINS A FIELD THAT IS UPDATED AT MULTIPLE PLACES IN THE CLASS, \u000aTHUS IT SEEMS TO BE PART OF THE STATE OF THE CLASS. HOWEVER, SINCE THE FIELD \u000aIS MARKED AS TRANSIENT AND NOT SET IN READOBJECT OR READRESOLVE, IT WILL \u000aCONTAIN THE DEFAULT VALUE IN ANY DESERIALIZED INSTANCE OF THE CLASS.\u000a,METHOD IGNORES EXCEPTIONAL RETURN VALUEEXCEPTIONAL RETURN VALUE OF {2} IGNORED IN {1}BAD_PRACTICETHIS METHOD RETURNS A VALUE THAT IS NOT CHECKED. THE RETURN VALUE SHOULD BE \u000aCHECKED SINCE IT CAN INDICATE AN UNUSUAL OR UNEXPECTED FUNCTION EXECUTION. FOR \u000aEXAMPLE, THE FILE.DELETE() METHOD RETURNS FALSE IF THE FILE COULD NOT BE \u000aSUCCESSFULLY DELETED (RATHER THAN THROWING AN EXCEPTION). IF YOU DON&apos;T CHECK \u000aTHE RESULT, YOU WON&apos;T NOTICE IF THE METHOD INVOCATION SIGNALS UNEXPECTED \u000aBEHAVIOR BY RETURNING AN ATYPICAL RETURN VALUE.\u000a,COMPUTATION OF AVERAGE COULD OVERFLOWCOMPUTATION OF AVERAGE COULD OVERFLOW IN {1}STYLETHE CODE COMPUTES THE AVERAGE OF TWO INTEGERS USING EITHER DIVISION OR SIGNED \u000aRIGHT SHIFT, AND THEN USES THE RESULT AS THE INDEX OF AN ARRAY. IF THE VALUES \u000aBEING AVERAGED ARE VERY LARGE, THIS CAN OVERFLOW (RESULTING IN THE COMPUTATION \u000aOF A NEGATIVE AVERAGE). ASSUMING THAT THE RESULT IS INTENDED TO BE \u000aNONNEGATIVE, YOU CAN USE AN UNSIGNED RIGHT SHIFT INSTEAD. IN OTHER WORDS, \u000aRATHER THAT USING (LOW+HIGH)/2, USE (LOW+HIGH) >>> 1 \u000aTHIS BUG EXISTS IN MANY EARLIER IMPLEMENTATIONS OF BINARY SEARCH AND MERGE \u000aSORT. MARTIN BUCHHOLZ FOUND AND FIXED IT IN THE JDK LIBRARIES, AND JOSHUA \u000aBLOCH WIDELY PUBLICIZED THE BUG PATTERN.\u000a,METHOD ASSIGNS BOOLEAN LITERAL IN BOOLEAN EXPRESSION{1} ASSIGNS BOOLEAN LITERAL IN BOOLEAN EXPRESSIONCORRECTNESSTHIS METHOD ASSIGNS A LITERAL BOOLEAN VALUE (TRUE OR FALSE) TO A BOOLEAN \u000aVARIABLE INSIDE AN IF OR WHILE EXPRESSION. MOST PROBABLY THIS WAS SUPPOSED TO \u000aBE A BOOLEAN COMPARISON USING ==, NOT AN ASSIGNMENT USING =.\u000a,THE EQUALS AND HASHCODE METHODS OF URL ARE BLOCKINGINVOCATION OF {2}, WHICH BLOCKS TO DO DOMAIN NAME RESOLUTION, IN {1}PERFORMANCETHE EQUALS AND HASHCODE METHOD OF URL PERFORM DOMAIN NAME RESOLUTION, THIS CAN \u000aRESULT IN A BIG PERFORMANCE HIT. SEE HTTP://MICHAELSCHARF.BLOGSPOT.COM/2006/11/JAVANETURLEQUALS-AND-HASHCODE-MAKE.HTML \u000aFOR MORE INFORMATION. CONSIDER USING JAVA.NET.URI INSTEAD.\u000a,CLASS DEFINES HASHCODE() BUT NOT EQUALS(){0} DEFINES HASHCODE BUT NOT EQUALSBAD_PRACTICETHIS CLASS DEFINES A HASHCODE() METHOD BUT NOT AN EQUALS() METHOD.  THEREFORE, \u000aTHE CLASS MAY VIOLATE THE INVARIANT THAT EQUAL OBJECTS MUST HAVE EQUAL \u000aHASHCODES.\u000a,METHOD DOES NOT RELEASE LOCK ON ALL PATHS{1} DOES NOT RELEASE LOCK ON ALL PATHSMT_CORRECTNESSTHIS METHOD ACQUIRES A JSR-166 (JAVA.UTIL.CONCURRENT) LOCK, BUT DOES NOT \u000aRELEASE IT ON ALL PATHS OUT OF THE METHOD. IN GENERAL, THE CORRECT IDIOM FOR \u000aUSING A JSR-166 LOCK IS: \u000a    LOCK L = ...;\u000a    L.LOCK();\u000a    TRY {\u000a        // DO SOMETHING\u000a    } FINALLY {\u000a        L.UNLOCK();\u000a    },D&apos;OH! A NONSENSICAL METHOD INVOCATIOND&apos;OH! A NONSENSICAL INVOCATION OF {2.NAMEANDSIGNATURE} IN {1}CORRECTNESSTHIS PARTICAL METHOD INVOCATION DOESN&apos;T MAKE SENSE, FOR REASONS THAT SHOULD BE \u000aAPPARENT FROM INSPECTION.\u000a,STORE OF NON SERIALIZABLE OBJECT INTO HTTPSESSIONSTORE OF NON SERIALIZABLE {2} INTO HTTPSESSION IN {1}BAD_PRACTICETHIS CODE SEEMS TO BE STORING A NON-SERIALIZABLE OBJECT INTO AN HTTPSESSION. \u000aIF THIS SESSION IS PASSIVATED OR MIGRATED, AN ERROR WILL RESULT.\u000a,METHOD USES THE SAME CODE FOR TWO SWITCH CLAUSES{1} USES THE SAME CODE FOR TWO SWITCH CLAUSESSTYLETHIS METHOD USES THE SAME CODE TO IMPLEMENT TWO CLAUSES OF A SWITCH STATEMENT. \u000aTHIS COULD BE A CASE OF DUPLICATE CODE, BUT IT MIGHT ALSO INDICATE A CODING \u000aMISTAKE.\u000a,READ OF UNWRITTEN PUBLIC OR PROTECTED FIELDREAD OF UNWRITTEN PUBLIC OR PROTECTED FIELD {2.NAME} IN {1}STYLETHE PROGRAM IS DEREFERENCING A PUBLIC OR PROTECTED FIELD THAT DOES NOT SEEM TO \u000aEVER HAVE A NON-NULL VALUE WRITTEN TO IT. UNLESS THE FIELD IS INITIALIZED VIA \u000aSOME MECHANISM NOT SEEN BY THE ANALYSIS, DEREFERENCING THIS VALUE WILL \u000aGENERATE A NULL POINTER EXCEPTION.\u000a,TEST FOR CIRCULAR DEPENDENCIES AMONG CLASSESCLASS {0} HAS A CIRCULAR DEPENDENCY WITH OTHER CLASSESSTYLETHIS CLASS HAS A CIRCULAR DEPENDENCY WITH OTHER CLASSES. THIS MAKES BUILDING \u000aTHESE CLASSES DIFFICULT, AS EACH IS DEPENDENT ON THE OTHER TO BUILD CORRECTLY. \u000aCONSIDER USING INTERFACES TO BREAK THE HARD DEPENDENCY.\u000a,TESTCASE DEFINES TEARDOWN THAT DOESN&apos;T CALL SUPER.TEARDOWN()TESTCASE {0} DEFINES TEARDOWN THAT DOESN&apos;T CALL SUPER.TEARDOWN()CORRECTNESSCLASS IS A JUNIT TESTCASE AND IMPLEMENTS THE TEARDOWN METHOD. THE TEARDOWN \u000aMETHOD SHOULD CALL SUPER.TEARDOWN(), BUT DOESN&apos;T.\u000a,METHOD INVOKES INEFFICIENT NEW STRING(STRING) CONSTRUCTOR{1} INVOKES INEFFICIENT NEW STRING(STRING) CONSTRUCTORPERFORMANCEUSING THE JAVA.LANG.STRING(STRING) CONSTRUCTOR WASTES MEMORY BECAUSE THE \u000aOBJECT SO CONSTRUCTED WILL BE FUNCTIONALLY INDISTINGUISHABLE FROM THE STRING \u000aPASSED AS A PARAMETER.  JUST USE THE ARGUMENT STRING DIRECTLY.\u000a,METHOD WITH BOOLEAN RETURN TYPE RETURNS EXPLICIT NULL{1} HAS BOOLEAN RETURN TYPE AND RETURNS EXPLICIT NULLBAD_PRACTICEA METHOD THAT RETURNS EITHER BOOLEAN.TRUE, BOOLEAN.FALSE OR NULL IS AN \u000aACCIDENT WAITING TO HAPPEN. THIS METHOD CAN BE INVOKED AS THOUGH IT RETURNED A \u000aVALUE OF TYPE BOOLEAN, AND THE COMPILER WILL INSERT AUTOMATIC UNBOXING OF THE \u000aBOOLEAN VALUE. IF A NULL VALUE IS RETURNED, THIS WILL RESULT IN A \u000aNULLPOINTEREXCEPTION.\u000a,INITIALIZATION CIRCULARITYINITIALIZATION CIRCULARITY BETWEEN {0} AND {1}STYLEA CIRCULARITY WAS DETECTED IN THE STATIC INITIALIZERS OF THE TWO CLASSES \u000aREFERENCED BY THE BUG INSTANCE.  MANY KINDS OF UNEXPECTED BEHAVIOR MAY ARISE \u000aFROM SUCH CIRCULARITY.\u000a,METHOD TIGHTENS NULLNESS ANNOTATION ON PARAMETERMETHOD {1} OVERRIDES THE NULLNESS ANNOTATION RELAXING THE ANCESTOR METHOD REQUIREMENTS ON PARAMETER.STYLEA METHOD SHOULD ALWAYS IMPLEMENT THE CONTRACT OF A METHOD IT OVERRIDES. THUS, \u000aIF A METHOD TAKES A PARAMETER THAT IS MARKED AS @NULLABLE, YOU SHOULDN&apos;T \u000aOVERRIDE THAT METHOD IN A SUBCLASS WITH A METHOD WHERE THAT PARAMETER IS \u000a@NONNULL. DOING SO VIOLATES THE CONTRACT THAT THE METHOD SHOULD HANDLE A NULL \u000aPARAMETER.\u000a,PRIMITIVE VALUE IS UNBOXED AND COERCED FOR TERNARY OPERATORPRIMITIVE VALUE IS UNBOXED AND COERCED FOR TERNARY OPERATOR IN {1}CORRECTNESSA WRAPPED PRIMITIVE VALUE IS UNBOXED AND CONVERTED TO ANOTHER PRIMITIVE TYPE \u000aAS PART OF THE EVALUATION OF A CONDITIONAL TERNARY OPERATOR (THE B ? E1 : E2 \u000aOPERATOR). THE SEMANTICS OF JAVA MANDATE THAT IF E1 AND E2 ARE WRAPPED NUMERIC \u000aVALUES, THE VALUES ARE UNBOXED AND CONVERTED/COERCED TO THEIR COMMON TYPE \u000a(E.G, IF E1 IS OF TYPE INTEGER AND E2 IS OF TYPE FLOAT, THEN E1 IS UNBOXED, \u000aCONVERTED TO A FLOATING POINT VALUE, AND BOXED. SEE JLS SECTION 15.25.\u000a,SYNCHRONIZE AND NULL CHECK ON THE SAME FIELD.IN {1} THE FIELD {2.GIVENCLASS} IS SYNCHRONIZED ON AND THEN CHECKED IF NULL.MT_CORRECTNESSSINCE THE FIELD IS SYNCHRONIZED ON, IT SEEMS NOT LIKELY TO BE NULL. IF IT IS \u000aNULL AND THEN SYNCHRONIZED ON A NULLPOINTEREXCEPTION WILL BE THROWN AND THE \u000aCHECK WOULD BE POINTLESS. BETTER TO SYNCHRONIZE ON ANOTHER FIELD.\u000a,A COLLECTION IS ADDED TO ITSELFA COLLECTION IS ADDED TO ITSELF IN {1}CORRECTNESSA COLLECTION IS ADDED TO ITSELF. AS A RESULT, COMPUTING THE HASHCODE OF THIS \u000aSET WILL THROW A STACKOVERFLOWEXCEPTION.\u000a,INSTANCEOF WILL ALWAYS RETURN FALSEINSTANCEOF WILL ALWAYS RETURN FALSE IN {1}, SINCE A {2} CAN&apos;T BE A {3}CORRECTNESSTHIS INSTANCEOF TEST WILL ALWAYS RETURN FALSE. ALTHOUGH THIS IS SAFE, MAKE \u000aSURE IT ISN&apos;T AN INDICATION OF SOME MISUNDERSTANDING OR SOME OTHER LOGIC ERROR.\u000a,CAN&apos;T USE REFLECTION TO CHECK FOR PRESENCE OF ANNOTATION WITHOUT RUNTIME RETENTIONUSE OF REFLECTION TO CHECK FOR THE PRESENCE THE ANNOTATION {3} WHICH DOESN&apos;T HAVE RUNTIME RETENTION, IN {1}CORRECTNESSUNLESS AN ANNOTATION HAS ITSELF BEEN ANNOTATED WITH \u000a@RETENTION(RETENTIONPOLICY.RUNTIME), THE ANNOTATION CAN&apos;T BE OBSERVED USING \u000aREFLECTION (E.G., BY USING THE ISANNOTATIONPRESENT METHOD). .\u000a,INVOCATION OF HASHCODE ON AN ARRAYINVOCATION OF HASHCODE ON ARRAY IN {1}CORRECTNESSTHE CODE INVOKES HASHCODE ON AN ARRAY. CALLING HASHCODE ON AN ARRAY RETURNS \u000aTHE SAME VALUE AS SYSTEM.IDENTITYHASHCODE, AND INGORES THE CONTENTS AND LENGTH \u000aOF THE ARRAY. IF YOU NEED A HASHCODE THAT DEPENDS ON THE CONTENTS OF AN ARRAY A, \u000aUSE JAVA.UTIL.ARRAYS.HASHCODE(A).\u000a,USING MONITOR STYLE WAIT METHODS ON UTIL.CONCURRENT ABSTRACTIONCALLING {2.NAME} RATHER THAN {3.NAME} IN {1}MT_CORRECTNESSTHIS METHOD CALLS WAIT(), NOTIFY() OR NOTIFYALL()() ON AN OBJECT THAT ALSO \u000aPROVIDES AN AWAIT(), SIGNAL(), SIGNALALL() METHOD (SUCH AS UTIL.CONCURRENT \u000aCONDITION OBJECTS). THIS PROBABLY ISN&apos;T WHAT YOU WANT, AND EVEN IF YOU DO WANT \u000aIT, YOU SHOULD CONSIDER CHANGING YOUR DESIGN, AS OTHER DEVELOPERS WILL FIND IT \u000aEXCEPTIONALLY CONFUSING.\u000a,USE OF IDENTIFIER THAT IS A KEYWORD IN LATER VERSIONS OF JAVA{1} USES {2} FOR A VARIABLE NAME, WHICH IS A KEYWORD IN LATER VERSIONS OF JAVABAD_PRACTICETHE IDENTIFIER IS A WORD THAT IS RESERVED AS A KEYWORD IN LATER VERSIONS OF \u000aJAVA, AND YOUR CODE WILL NEED TO BE CHANGED IN ORDER TO COMPILE IT IN LATER \u000aVERSIONS OF JAVA.\u000a,SELF COMPARISON OF VALUE WITH ITSELFSELF COMPARISON OF {2} WITH ITSELF {1}CORRECTNESSTHIS METHOD COMPARES A LOCAL VARIABLE WITH ITSELF, AND MAY INDICATE A TYPO OR \u000aA LOGIC ERROR. MAKE SURE THAT YOU ARE COMPARING THE RIGHT THINGS.\u000a,AN INCREMENT TO A VOLATILE FIELD ISN&apos;T ATOMICINCREMENT OF VOLATILE FIELD {2} IN {1}MT_CORRECTNESSTHIS CODE INCREMENTS A VOLATILE FIELD. INCREMENTS OF VOLATILE FIELDS AREN&apos;T \u000aATOMIC. IF MORE THAN ONE THREAD IS INCREMENTING THE FIELD AT THE SAME TIME, \u000aINCREMENTS COULD BE LOST.\u000a,THE READRESOLVE METHOD MUST NOT BE DECLARED AS A STATIC METHOD.  {1} SHOULD BE DECLARED AS AN INSTANCE METHOD RATHER THAN A STATIC METHODCORRECTNESSIN ORDER FOR THE READRESOLVE METHOD TO BE RECOGNIZED BY THE SERIALIZATION \u000aMECHANISM, IT MUST NOT BE DECLARED AS A STATIC METHOD.\u000a,FORMAT STRING SHOULD USE %N RATHER THAN \NFORMAT STRING SHOULD USE %N RATHER THAN \N IN {1}BAD_PRACTICETHIS FORMAT STRING INCLUDE A NEWLINE CHARACTER (\N). IN FORMAT STRINGS, IT IS \u000aGENERALLY PREFERABLE BETTER TO USE %N, WHICH WILL PRODUCE THE \u000aPLATFORM-SPECIFIC LINE SEPARATOR.\u000a,JSP REFLECTED CROSS SITE SCRIPTING VULNERABILITYHTTP PARAMETER DIRECTLY WRITTEN TO JSP OUTPUT, GIVING REFLECTED XSS VULNERABILITY IN {1.CLASS}SECURITYTHIS CODE DIRECTLY WRITES AN HTTP PARAMETER TO JSP OUTPUT, WHICH ALLOWS FOR A \u000aCROSS SITE SCRIPTING VULNERABILITY. SEE HTTP://EN.WIKIPEDIA.ORG/WIKI/CROSS-SITE_SCRIPTING \u000aFOR MORE INFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF CROSS SITE \u000aSCRIPTING. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE CROSS SITE \u000aSCRIPTING VULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED \u000aABOUT CROSS SITE SCRIPTING, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL \u000aSTATIC ANALYSIS OR PEN-TESTING TOOL.\u000a,QUESTIONABLE CAST TO CONCRETE COLLECTIONQUESTIONABLE CAST FROM {2} TO {3} IN {1}STYLETHIS CODE CASTS AN ABSTRACT COLLECTION (SUCH AS A COLLECTION, LIST, OR SET) TO \u000aA SPECIFIC CONCRETE IMPLEMENTATION (SUCH AS AN ARRAYLIST OR HASHSET). THIS \u000aMIGHT NOT BE CORRECT, AND IT MAY MAKE YOUR CODE FRAGILE, SINCE IT MAKES IT \u000aHARDER TO SWITCH TO OTHER CONCRETE IMPLEMENTATIONS AT A FUTURE POINT. UNLESS \u000aYOU HAVE A PARTICULAR REASON TO DO SO, JUST USE THE ABSTRACT COLLECTION CLASS.\u000a,NONCONSTANT STRING PASSED TO EXECUTE METHOD ON AN SQL STATEMENT{1} PASSES A NONCONSTANT STRING TO AN EXECUTE METHOD ON AN SQL STATEMENTSECURITYTHE METHOD INVOKES THE EXECUTE METHOD ON AN SQL STATEMENT WITH A STRING THAT \u000aSEEMS TO BE DYNAMICALLY GENERATED. CONSIDER USING A PREPARED STATEMENT \u000aINSTEAD. IT IS MORE EFFICIENT AND LESS VULNERABLE TO SQL INJECTION ATTACKS.\u000a,MISMATCHED NOTIFY()MISMATCHED NOTIFY() IN {1}MT_CORRECTNESSTHIS METHOD CALLS OBJECT.NOTIFY() OR OBJECT.NOTIFYALL() WITHOUT OBVIOUSLY \u000aHOLDING A LOCK ON THE OBJECT.  CALLING NOTIFY() OR NOTIFYALL() WITHOUT A LOCK \u000aHELD WILL RESULT IN AN ILLEGALMONITORSTATEEXCEPTION BEING THROWN.\u000a,CREATES AN EMPTY JAR FILE ENTRYEMPTY JAR FILE ENTRY CREATED IN {1}BAD_PRACTICETHE CODE CALLS PUTNEXTENTRY(), IMMEDIATELY FOLLOWED BY A CALL TO CLOSEENTRY(). \u000aTHIS RESULTS IN AN EMPTY JARFILE ENTRY. THE CONTENTS OF THE ENTRY SHOULD BE \u000aWRITTEN TO THE JARFILE BETWEEN THE CALLS TO PUTNEXTENTRY() AND CLOSEENTRY().\u000a,UNCONDITIONAL WAITUNCONDITIONAL WAIT IN {1}MT_CORRECTNESSTHIS METHOD CONTAINS A CALL TO JAVA.LANG.OBJECT.WAIT() WHICH IS NOT GUARDED BY \u000aCONDITIONAL CONTROL FLOW.  THE CODE SHOULD VERIFY THAT CONDITION IT INTENDS TO \u000aWAIT FOR IS NOT ALREADY SATISFIED BEFORE CALLING WAIT; ANY PREVIOUS \u000aNOTIFICATIONS WILL BE IGNORED.\u000a,FIELD ISN&apos;T FINAL BUT SHOULD BE REFACTORED TO BE SO{1} ISN&apos;T FINAL BUT SHOULD BE REFACTORED TO BE SOMALICIOUS_CODETHIS STATIC FIELD PUBLIC BUT NOT FINAL, AND COULD BE CHANGED BY MALICIOUS CODE \u000aOR BY ACCIDENT FROM ANOTHER PACKAGE. THE FIELD COULD BE MADE FINAL TO AVOID \u000aTHIS VULNERABILITY. HOWEVER, THE STATIC INITIALIZER CONTAINS MORE THAN ONE \u000aWRITE TO THE FIELD, SO DOING SO WILL REQUIRE SOME REFACTORING.\u000a,METHOD CHECKS TO SEE IF RESULT OF STRING.INDEXOF IS POSITIVE{1} CHECKS TO SEE IF RESULT OF STRING.INDEXOF IS POSITIVESTYLETHE METHOD INVOKES STRING.INDEXOF AND CHECKS TO SEE IF THE RESULT IS POSITIVE \u000aOR NON-POSITIVE. IT IS MUCH MORE TYPICAL TO CHECK TO SEE IF THE RESULT IS \u000aNEGATIVE OR NON-NEGATIVE. IT IS POSITIVE ONLY IF THE SUBSTRING CHECKED FOR \u000aOCCURS AT SOME PLACE OTHER THAN AT THE BEGINNING OF THE STRING.\u000a,DEAD STORE TO LOCAL VARIABLEDEAD STORE TO {2} IN {1}STYLETHIS INSTRUCTION ASSIGNS A VALUE TO A LOCAL VARIABLE, BUT THE VALUE IS NOT \u000aREAD OR USED IN ANY SUBSEQUENT INSTRUCTION. OFTEN, THIS INDICATES AN ERROR, \u000aBECAUSE THE VALUE COMPUTED IS NEVER USED. \u000aNOTE THAT SUN&apos;S JAVAC COMPILER OFTEN GENERATES DEAD STORES FOR FINAL LOCAL \u000aVARIABLES. BECAUSE FINDBUGS IS A BYTECODE-BASED TOOL, THERE IS NO EASY WAY TO \u000aELIMINATE THESE FALSE POSITIVES.\u000a,A VOLATILE REFERENCE TO AN ARRAY DOESN&apos;T TREAT THE ARRAY ELEMENTS AS VOLATILE{1} IS A VOLATILE REFERENCE TO AN ARRAY; THE ARRAY ELEMENTS ARE NON-VOLATILEMT_CORRECTNESSTHIS DECLARES A VOLATILE REFERENCE TO AN ARRAY, WHICH MIGHT NOT BE WHAT YOU \u000aWANT. WITH A VOLATILE REFERENCE TO AN ARRAY, READS AND WRITES OF THE REFERENCE \u000aTO THE ARRAY ARE TREATED AS VOLATILE, BUT THE ARRAY ELEMENTS ARE NON-VOLATILE. \u000aTO GET VOLATILE ARRAY ELEMENTS, YOU WILL NEED TO USE ONE OF THE ATOMIC ARRAY \u000aCLASSES IN JAVA.UTIL.CONCURRENT (PROVIDED IN JAVA 5.0).\u000a,CONSTRUCTOR INVOKES THREAD.START(){1} INVOKES {2}MT_CORRECTNESSTHE CONSTRUCTOR STARTS A THREAD. THIS IS LIKELY TO BE WRONG IF THE CLASS IS \u000aEVER EXTENDED/SUBCLASSED, SINCE THE THREAD WILL BE STARTED BEFORE THE SUBCLASS \u000aCONSTRUCTOR IS STARTED.\u000a,INEFFICIENT USE OF KEYSET ITERATOR INSTEAD OF ENTRYSET ITERATOR{1} MAKES INEFFICIENT USE OF KEYSET ITERATOR INSTEAD OF ENTRYSET ITERATORPERFORMANCETHIS METHOD ACCESSES THE VALUE OF A MAP ENTRY, USING A KEY THAT WAS RETRIEVED \u000aFROM A KEYSET ITERATOR. IT IS MORE EFFICIENT TO USE AN ITERATOR ON THE \u000aENTRYSET OF THE MAP, TO AVOID THE MAP.GET(KEY) LOOKUP.\u000a,DEREFERENCE OF THE RESULT OF READLINE() WITHOUT NULLCHECKDEREFERENCE OF THE RESULT OF READLINE() WITHOUT NULLCHECK IN {1}STYLETHE RESULT OF INVOKING READLINE() IS DEREFERENCED WITHOUT CHECKING TO SEE IF \u000aTHE RESULT IS NULL. IF THERE ARE NO MORE LINES OF TEXT TO READ, READLINE() \u000aWILL RETURN NULL AND DEREFERENCING THAT WILL GENERATE A NULL POINTER EXCEPTION.\u000a,AN APPARENT INFINITE RECURSIVE LOOPTHERE IS AN APPARENT INFINITE RECURSIVE LOOP IN {1}CORRECTNESSTHIS METHOD UNCONDITIONALLY INVOKES ITSELF. THIS WOULD SEEM TO INDICATE AN \u000aINFINITE RECURSIVE LOOP THAT WILL RESULT IN A STACK OVERFLOW.\u000a,DEAD STORE TO LOCAL VARIABLE THAT SHADOWS FIELDDEAD STORE TO {2} RATHER THAN FIELD WITH SAME NAME IN {1}STYLETHIS INSTRUCTION ASSIGNS A VALUE TO A LOCAL VARIABLE, BUT THE VALUE IS NOT \u000aREAD OR USED IN ANY SUBSEQUENT INSTRUCTION. OFTEN, THIS INDICATES AN ERROR, \u000aBECAUSE THE VALUE COMPUTED IS NEVER USED. THERE IS A FIELD WITH THE SAME NAME \u000aAS THE LOCAL VARIABLE. DID YOU MEAN TO ASSIGN TO THAT VARIABLE INSTEAD?\u000a,ADDING ELEMENTS OF AN ENTRY SET MAY FAIL DUE TO REUSE OF ENTRY OBJECTSADDING ELEMENTS OF AN ENTRY SET MAY FAIL DUE TO REUSE OF {2.SIMPLECLASS}.ENTRY OBJECT IN {1}BAD_PRACTICETHE ENTRYSET() METHOD IS ALLOWED TO RETURN A VIEW OF THE UNDERLYING MAP IN \u000aWHICH A SINGLE ENTRY OBJECT IS REUSED AND RETURNED DURING THE ITERATION. AS OF \u000aJAVA 1.6, BOTH IDENTITYHASHMAP AND ENUMMAP DID SO. WHEN ITERATING THROUGH SUCH \u000aA MAP, THE ENTRY VALUE IS ONLY VALID UNTIL YOU ADVANCE TO THE NEXT ITERATION. \u000aIF, FOR EXAMPLE, YOU TRY TO PASS SUCH AN ENTRYSET TO AN ADDALL METHOD, THINGS \u000aWILL GO BADLY WRONG.\u000a,BAD CONSTANT VALUE FOR MONTHBAD MONTH VALUE OF {2} PASSED TO {3} IN {1}CORRECTNESSTHIS CODE PASSES A CONSTANT MONTH VALUE OUTSIDE THE EXPECTED RANGE OF 0..11 TO \u000aA METHOD.\u000a,POSSIBLE DOUBLE CHECK OF FIELDPOSSIBLE DOUBLECHECK ON {2} IN {1}MT_CORRECTNESSTHIS METHOD MAY CONTAIN AN INSTANCE OF DOUBLE-CHECKED LOCKING.  THIS IDIOM IS \u000aNOT CORRECT ACCORDING TO THE SEMANTICS OF THE JAVA MEMORY MODEL.  FOR MORE \u000aINFORMATION, SEE THE WEB PAGE HTTP://WWW.CS.UMD.EDU/~PUGH/JAVA/MEMORYMODEL/DOUBLECHECKEDLOCKING.HTML.\u000a,CHECK FOR ODDNESS THAT WON&apos;T WORK FOR NEGATIVE NUMBERS CHECK FOR ODDNESS THAT WON&apos;T WORK FOR NEGATIVE NUMBERS IN {1}STYLETHE CODE USES X % 2 == 1 TO CHECK TO SEE IF A VALUE IS ODD, BUT THIS WON&apos;T \u000aWORK FOR NEGATIVE NUMBERS (E.G., (-5) % 2 == -1). IF THIS CODE IS INTENDING TO \u000aCHECK FOR ODDNESS, CONSIDER USING X &amp; 1 == 1, OR X % 2 != 0.\u000a,MONITOR WAIT() CALLED ON CONDITIONMONITOR WAIT() CALLED ON A CONDITION IN {1}MT_CORRECTNESSTHIS METHOD CALLS WAIT() ON A JAVA.UTIL.CONCURRENT.LOCKS.CONDITION OBJECT.  \u000aWAITING FOR A CONDITION SHOULD BE DONE USING ONE OF THE AWAIT() METHODS \u000aDEFINED BY THE CONDITION INTERFACE.\u000a,EQUALS METHOD ALWAYS RETURNS FALSE{1} ALWAYS RETURNS FALSECORRECTNESSTHIS CLASS DEFINES AN EQUALS METHOD THAT ALWAYS RETURNS FALSE. THIS MEANS THAT \u000aAN OBJECT IS NOT EQUAL TO ITSELF, AND IT IS IMPOSSIBLE TO CREATE USEFUL MAPS \u000aOR SETS OF THIS CLASS. MORE FUNDAMENTALLY, IT MEANS THAT EQUALS IS NOT \u000aREFLEXIVE, ONE OF THE REQUIREMENTS OF THE EQUALS METHOD. \u000aTHE LIKELY INTENDED SEMANTICS ARE OBJECT IDENTITY: THAT AN OBJECT IS EQUAL TO \u000aITSELF. THIS IS THE BEHAVIOR INHERITED FROM CLASS OBJECT. IF YOU NEED TO \u000aOVERRIDE AN EQUALS INHERITED FROM A DIFFERENT SUPERCLASS, YOU CAN USE USE: \u000aPUBLIC BOOLEAN EQUALS(OBJECT O) { RETURN THIS == O; },BITWISE OR OF SIGNED BYTE VALUEBITWISE OR OF SIGNED BYTE VALUE COMPUTED IN {1} CORRECTNESSLOADS A BYTE VALUE (E.G., A VALUE LOADED FROM A BYTE ARRAY OR RETURNED BY A \u000aMETHOD WITH RETURN TYPE BYTE) AND PERFORMS A BITWISE OR WITH THAT VALUE. BYTE \u000aVALUES ARE SIGN EXTENDED TO 32 BITS BEFORE ANY ANY BITWISE OPERATIONS ARE \u000aPERFORMED ON THE VALUE. THUS, IF B[0] CONTAINS THE VALUE 0XFF, AND X IS \u000aINITIALLY 0, THEN THE CODE ((X &lt;&lt; 8) | B[0]) WILL SIGN EXTEND 0XFF TO GET 0XFFFFFFFF, \u000aAND THUS GIVE THE VALUE 0XFFFFFFFF AS THE RESULT. \u000aIN PARTICULAR, THE FOLLOWING CODE FOR PACKING A BYTE ARRAY INTO AN INT IS \u000aBADLY WRONG: \u000aINT RESULT = 0;\u000aFOR(INT I = 0; I &lt; 4; I++)\u000a  RESULT = ((RESULT &lt;&lt; 8) | B[I]);\u000aTHE FOLLOWING IDIOM WILL WORK INSTEAD: \u000aINT RESULT = 0;\u000aFOR(INT I = 0; I &lt; 4; I++)\u000a  RESULT = ((RESULT &lt;&lt; 8) | (B[I] &amp; 0XFF));,MAY EXPOSE INTERNAL REPRESENTATION BY RETURNING REFERENCE TO MUTABLE OBJECT{1} MAY EXPOSE INTERNAL REPRESENTATION BY RETURNING {2.GIVENCLASS}MALICIOUS_CODERETURNING A REFERENCE TO A MUTABLE OBJECT VALUE STORED IN ONE OF THE OBJECT&apos;S \u000aFIELDS EXPOSES THE INTERNAL REPRESENTATION OF THE OBJECT.  IF INSTANCES ARE \u000aACCESSED BY UNTRUSTED CODE, AND UNCHECKED CHANGES TO THE MUTABLE OBJECT WOULD \u000aCOMPROMISE SECURITY OR OTHER IMPORTANT PROPERTIES, YOU WILL NEED TO DO \u000aSOMETHING DIFFERENT. RETURNING A NEW COPY OF THE OBJECT IS BETTER APPROACH IN \u000aMANY SITUATIONS.\u000a,RANDOM OBJECT CREATED AND USED ONLY ONCERANDOM OBJECT CREATED AND USED ONLY ONCE IN {1}BAD_PRACTICETHIS CODE CREATES A JAVA.UTIL.RANDOM OBJECT, USES IT TO GENERATE ONE RANDOM \u000aNUMBER, AND THEN DISCARDS THE RANDOM OBJECT. THIS PRODUCES MEDIOCRE QUALITY \u000aRANDOM NUMBERS AND IS INEFFICIENT. IF POSSIBLE, REWRITE THE CODE SO THAT THE \u000aRANDOM OBJECT IS CREATED ONCE AND SAVED, AND EACH TIME A NEW RANDOM NUMBER IS \u000aREQUIRED INVOKE A METHOD ON THE EXISTING RANDOM OBJECT TO OBTAIN IT. \u000aIF IT IS IMPORTANT THAT THE GENERATED RANDOM NUMBERS NOT BE GUESSABLE, YOU MUST \u000aNOT CREATE A NEW RANDOM FOR EACH RANDOM NUMBER; THE VALUES ARE TOO EASILY \u000aGUESSABLE. YOU SHOULD STRONGLY CONSIDER USING A JAVA.SECURITY.SECURERANDOM \u000aINSTEAD (AND AVOID ALLOCATING A NEW SECURERANDOM FOR EACH RANDOM NUMBER \u000aNEEDED).\u000a,THREAD PASSED WHERE RUNNABLE EXPECTEDTHREAD PASSED WHERE RUNNABLE EXPECTED IN {1}STYLEA THREAD OBJECT IS PASSED AS A PARAMETER TO A METHOD WHERE A RUNNABLE IS \u000aEXPECTED. THIS IS RATHER UNUSUAL, AND MAY INDICATE A LOGIC ERROR OR CAUSE \u000aUNEXPECTED BEHAVIOR.\u000a,METHOD CALL PASSES NULL FOR NONNULL PARAMETERNULL PASSED FOR NONNULL PARAMETER OF {2.GIVENCLASS} IN {1}CORRECTNESSTHIS METHOD CALL PASSES A NULL VALUE FOR A NONNULL METHOD PARAMETER. EITHER \u000aTHE PARAMETER IS ANNOTATED AS A PARAMETER THAT SHOULD ALWAYS BE NONNULL, OR \u000aANALYSIS HAS SHOWN THAT IT WILL ALWAYS BE DEREFERENCED.\u000a,&quot;.&quot; OR &quot;|&quot; USED FOR REGULAR EXPRESSION&quot;.&quot; OR &quot;|&quot; USED FOR REGULAR EXPRESSION IN {1}CORRECTNESSA STRING FUNCTION IS BEING INVOKED AND &quot;.&quot; OR &quot;|&quot; IS BEING PASSED TO A \u000aPARAMETER THAT TAKES A REGULAR EXPRESSION AS AN ARGUMENT. IS THIS WHAT YOU \u000aINTENDED? FOR EXAMPLE \u000a  * S.REPLACEALL(&quot;.&quot;, &quot;/&quot;) WILL RETURN A STRING IN WHICH EVERY CHARACTER HAS \u000a    BEEN REPLACED BY A &apos;/&apos; CHARACTER \u000a  * S.SPLIT(&quot;.&quot;) ALWAYS RETURNS A ZERO LENGTH ARRAY OF STRING \u000a  * &quot;AB|CD&quot;.REPLACEALL(&quot;|&quot;, &quot;/&quot;) WILL RETURN &quot;/A/B/|/C/D/&quot; \u000a  * &quot;AB|CD&quot;.SPLIT(&quot;|&quot;) WILL RETURN ARRAY WITH SIX (!) ELEMENTS: [, A, B, |, C, \u000a    D]\u000a  \u000a,CLASS DEFINES TOSTRING(); SHOULD IT BE TOSTRING()?CLASS {0} DEFINES TOSTRING(); SHOULD IT BE TOSTRING()?CORRECTNESSTHIS CLASS DEFINES A METHOD CALLED TOSTRING().  THIS METHOD DOES NOT OVERRIDE \u000aTHE TOSTRING() METHOD IN JAVA.LANG.OBJECT, WHICH IS PROBABLY WHAT WAS INTENDED.\u000a,VERY CONFUSING METHOD NAMES (BUT PERHAPS INTENTIONAL)VERY CONFUSING (BUT PERHAPS INTENTIONAL) TO HAVE METHODS {1} AND {3}BAD_PRACTICETHE REFERENCED METHODS HAVE NAMES THAT DIFFER ONLY BY CAPITALIZATION. THIS IS \u000aVERY CONFUSING BECAUSE IF THE CAPITALIZATION WERE IDENTICAL THEN ONE OF THE \u000aMETHODS WOULD OVERRIDE THE OTHER. FROM THE EXISTENCE OF OTHER METHODS, IT \u000aSEEMS THAT THE EXISTENCE OF BOTH OF THESE METHODS IS INTENTIONAL, BUT IS SURE \u000aIS CONFUSING. YOU SHOULD TRY HARD TO ELIMINATE ONE OF THEM, UNLESS YOU ARE \u000aFORCED TO HAVE BOTH DUE TO FROZEN APIS.\u000a,CLASS IS FINAL BUT DECLARES PROTECTED FIELDCLASS {0} IS FINAL BUT DECLARES PROTECTED FIELD {1}STYLETHIS CLASS IS DECLARED TO BE FINAL, BUT DECLARES FIELDS TO BE PROTECTED. SINCE \u000aTHE CLASS IS FINAL, IT CAN NOT BE DERIVED FROM, AND THE USE OF PROTECTED IS \u000aCONFUSING. THE ACCESS MODIFIER FOR THE FIELD SHOULD BE CHANGED TO PRIVATE OR \u000aPUBLIC TO REPRESENT THE TRUE USE FOR THE FIELD.\u000a,METHOD MAY FAIL TO CLEAN UP STREAM OR RESOURCE ON CHECKED EXCEPTION{1} MAY FAIL TO CLEAN UP {2} ON CHECKED EXCEPTIONEXPERIMENTALTHIS METHOD MAY FAIL TO CLEAN UP (CLOSE, DISPOSE OF) A STREAM, DATABASE \u000aOBJECT, OR OTHER RESOURCE REQUIRING AN EXPLICIT CLEANUP OPERATION. \u000aIN GENERAL, IF A METHOD OPENS A STREAM OR OTHER RESOURCE, THE METHOD SHOULD \u000aUSE A TRY/FINALLY BLOCK TO ENSURE THAT THE STREAM OR RESOURCE IS CLEANED UP \u000aBEFORE THE METHOD RETURNS. \u000aTHIS BUG PATTERN IS ESSENTIALLY THE SAME AS THE OS_OPEN_STREAM AND \u000aODR_OPEN_DATABASE_RESOURCE BUG PATTERNS, BUT IS BASED ON A DIFFERENT (AND \u000aHOPEFULLY BETTER) STATIC ANALYSIS TECHNIQUE. WE ARE INTERESTED IS GETTING \u000aFEEDBACK ABOUT THE USEFULNESS OF THIS BUG PATTERN. TO SEND FEEDBACK, EITHER: \u000a  * SEND EMAIL TO FINDBUGS@CS.UMD.EDU \u000a  * FILE A BUG REPORT: HTTP://FINDBUGS.SOURCEFORGE.NET/REPORTINGBUGS.HTML \u000a  \u000aIN PARTICULAR, THE FALSE-POSITIVE SUPPRESSION HEURISTICS FOR THIS BUG PATTERN \u000aHAVE NOT BEEN EXTENSIVELY TUNED, SO REPORTS ABOUT FALSE POSITIVES ARE HELPFUL \u000aTO US. \u000aSEE WEIMER AND NECULA, FINDING AND PREVENTING RUN-TIME ERROR HANDLING MISTAKES, \u000aFOR A DESCRIPTION OF THE ANALYSIS TECHNIQUE.\u000a,CLASS IS EXTERNALIZABLE BUT DOESN&apos;T DEFINE A VOID CONSTRUCTOR{0} IS EXTERNALIZABLE BUT DOESN&apos;T DEFINE A VOID CONSTRUCTORBAD_PRACTICETHIS CLASS IMPLEMENTS THE EXTERNALIZABLE INTERFACE, BUT DOES NOT DEFINE A VOID \u000aCONSTRUCTOR. WHEN EXTERNALIZABLE OBJECTS ARE DESERIALIZED, THEY FIRST NEED TO \u000aBE CONSTRUCTED BY INVOKING THE VOID CONSTRUCTOR. SINCE THIS CLASS DOES NOT \u000aHAVE ONE, SERIALIZATION AND DESERIALIZATION WILL FAIL AT RUNTIME.\u000a,FINALIZER ONLY NULLS FIELDS{1} ONLY NULLS FIELDSBAD_PRACTICETHIS FINALIZER DOES NOTHING EXCEPT NULL OUT FIELDS. THIS IS COMPLETELY \u000aPOINTLESS, AND REQUIRES THAT THE OBJECT BE GARBAGE COLLECTED, FINALIZED, AND \u000aTHEN GARBAGE COLLECTED AGAIN. YOU SHOULD JUST REMOVE THE FINALIZE METHOD.\u000a,USELESS/VACUOUS CALL TO EASYMOCK METHODUSELESS/VACUOUS CALL TO {2} IN {1}CORRECTNESSTHIS CALL DOESN&apos;T PASS ANY OBJECTS TO THE EASYMOCK METHOD, SO THE CALL DOESN&apos;T \u000aDO ANYTHING.\u000a,DEAD STORE DUE TO SWITCH STATEMENT FALL THROUGH TO THROWVALUE OF {2.GIVENCLASS} FROM PREVIOUS CASE IS LOST HERE DUE TO SWITCH STATEMENT FALL THROUGH TO THROWCORRECTNESSA VALUE STORED IN THE PREVIOUS SWITCH CASE IS IGNORED HERE DUE TO A SWITCH \u000aFALL THROUGH TO A PLACE WHERE AN EXCEPTION IS THROWN. IT IS LIKELY THAT YOU \u000aFORGOT TO PUT A BREAK OR RETURN AT THE END OF THE PREVIOUS CASE.\u000a,A PARAMETER IS DEAD UPON ENTRY TO A METHOD BUT OVERWRITTENTHE PARAMETER {2} TO {1} IS DEAD UPON ENTRY BUT OVERWRITTENCORRECTNESSTHE INITIAL VALUE OF THIS PARAMETER IS IGNORED, AND THE PARAMETER IS \u000aOVERWRITTEN HERE. THIS OFTEN INDICATES A MISTAKEN BELIEF THAT THE WRITE TO THE \u000aPARAMETER WILL BE CONVEYED BACK TO THE CALLER.\u000a,UNSYNCHRONIZED GET METHOD, SYNCHRONIZED SET METHOD{1} IS UNSYNCHRONIZED, {2} IS SYNCHRONIZEDMT_CORRECTNESSTHIS CLASS CONTAINS SIMILARLY-NAMED GET AND SET METHODS WHERE THE SET METHOD \u000aIS SYNCHRONIZED AND THE GET METHOD IS NOT.  THIS MAY RESULT IN INCORRECT \u000aBEHAVIOR AT RUNTIME, AS CALLERS OF THE GET METHOD WILL NOT NECESSARILY SEE A \u000aCONSISTENT STATE FOR THE OBJECT.  THE GET METHOD SHOULD BE MADE SYNCHRONIZED.\u000a,NONSENSICAL SELF COMPUTATION INVOLVING A VARIABLE (E.G., X &amp; X)NONSENSICAL SELF COMPUTATION OF {2} WITH ITSELF IN {1}CORRECTNESSTHIS METHOD PERFORMS A NONSENSICAL COMPUTATION OF A LOCAL VARIABLE WITH \u000aANOTHER REFERENCE TO THE SAME VARIABLE (E.G., X&amp;X OR X-X). BECAUSE OF THE \u000aNATURE OF THE COMPUTATION, THIS OPERATION DOESN&apos;T SEEM TO MAKE SENSE, AND MAY \u000aINDICATE A TYPO OR A LOGIC ERROR. DOUBLE CHECK THE COMPUTATION.\u000a,USE OF IDENTIFIER THAT IS A KEYWORD IN LATER VERSIONS OF JAVA{1} CONFLICTS WITH A KEYWORD IN A MORE RECENT VERSION OF JAVABAD_PRACTICETHIS IDENTIFIER IS USED AS A KEYWORD IN LATER VERSIONS OF JAVA. THIS CODE, AND \u000aANY CODE THAT REFERENCES THIS API, WILL NEED TO BE CHANGED IN ORDER TO COMPILE \u000aIT IN LATER VERSIONS OF JAVA.\u000a,WAIT NOT IN LOOP WAIT NOT IN LOOP IN {1}MT_CORRECTNESSTHIS METHOD CONTAINS A CALL TO JAVA.LANG.OBJECT.WAIT() WHICH IS NOT IN A \u000aLOOP.  IF THE MONITOR IS USED FOR MULTIPLE CONDITIONS, THE CONDITION THE \u000aCALLER INTENDED TO WAIT FOR MIGHT NOT BE THE ONE THAT ACTUALLY OCCURRED.\u000a,METHOD MUST BE PRIVATE IN ORDER FOR SERIALIZATION TO WORKTHE METHOD {1.GIVENCLASS} MUST BE PRIVATE TO BE INVOKED IN SERIALIZATION/DESERIALIZATION OF {0}CORRECTNESSTHIS CLASS IMPLEMENTS THE SERIALIZABLE INTERFACE, AND DEFINES A METHOD FOR \u000aCUSTOM SERIALIZATION/DESERIALIZATION. BUT SINCE THAT METHOD ISN&apos;T DECLARED \u000aPRIVATE, IT WILL BE SILENTLY IGNORED BY THE SERIALIZATION/DESERIALIZATION API.\u000a,STATIC THREAD.INTERRUPTED() METHOD INVOKED ON THREAD INSTANCE{1} INVOKES STATIC THREAD.INTERRUPTED() METHOD ON THREAD INSTANCECORRECTNESSTHIS METHOD INVOKES THE THREAD.INTERRUPTED() METHOD ON A THREAD OBJECT THAT \u000aAPPEARS TO BE A THREAD OBJECT THAT IS NOT THE CURRENT THREAD. AS THE \u000aINTERRUPTED() METHOD IS STATIC, THE INTERRUPTED METHOD WILL BE CALLED ON A \u000aDIFFERENT OBJECT THAN THE ONE THE AUTHOR INTENDED.\u000a,EMPTY FINALIZER SHOULD BE DELETED{1} IS EMPTY AND SHOULD BE DELETEDBAD_PRACTICEEMPTY FINALIZE() METHODS ARE USELESS, SO THEY SHOULD BE DELETED.\u000a,FIELD IS A MUTABLE HASHTABLE{1} IS A MUTABLE HASHTABLEMALICIOUS_CODEA FINAL STATIC FIELD REFERENCES A HASHTABLE AND CAN BE ACCESSED BY MALICIOUS \u000aCODE OR BY ACCIDENT FROM ANOTHER PACKAGE. THIS CODE CAN FREELY MODIFY THE \u000aCONTENTS OF THE HASHTABLE.\u000a,BOXING/UNBOXING TO PARSE A PRIMITIVEBOXING/UNBOXING TO PARSE A PRIMITIVE {1}PERFORMANCEA BOXED PRIMITIVE IS CREATED FROM A STRING, JUST TO EXTRACT THE UNBOXED \u000aPRIMITIVE VALUE. IT IS MORE EFFICIENT TO JUST CALL THE STATIC PARSEXXX METHOD.\u000a,INTEGRAL VALUE CAST TO DOUBLE AND THEN PASSED TO MATH.CEILINTEGRAL VALUE CAST TO DOUBLE AND THEN PASSED TO MATH.CEIL IN {1}CORRECTNESSTHIS CODE CONVERTS AN INTEGRAL VALUE (E.G., INT OR LONG) TO A DOUBLE PRECISION \u000aFLOATING POINT NUMBER AND THEN PASSING THE RESULT TO THE MATH.CEIL() FUNCTION, \u000aWHICH ROUNDS A DOUBLE TO THE NEXT HIGHER INTEGER VALUE. THIS OPERATION SHOULD \u000aALWAYS BE A NO-OP, SINCE THE CONVERTING AN INTEGER TO A DOUBLE SHOULD GIVE A \u000aNUMBER WITH NO FRACTIONAL PART. IT IS LIKELY THAT THE OPERATION THAT GENERATED \u000aTHE VALUE TO BE PASSED TO MATH.CEIL WAS INTENDED TO BE PERFORMED USING DOUBLE \u000aPRECISION FLOATING POINT ARITHMETIC.\u000a,UNKNOWN BUG PATTERNUNKNOWN BUG PATTERN BUG_PATTERN IN {1}EXPERIMENTALA WARNING WAS RECORDED, BUT FINDBUGS CAN&apos;T FIND THE DESCRIPTION OF THIS BUG \u000aPATTERN AND SO CAN&apos;T DESCRIBE IT. THIS SHOULD OCCUR ONLY IN CASES OF A BUG IN \u000aFINDBUGS OR ITS CONFIGURATION, OR PERHAPS IF AN ANALYSIS WAS GENERATED USING A \u000aPLUGIN, BUT THAT PLUGIN IS NOT CURRENTLY LOADED. .\u000a,INCONSISTENT SYNCHRONIZATIONINCONSISTENT SYNCHRONIZATION OF {1}; LOCKED {2}% OF TIMEMT_CORRECTNESSTHE FIELDS OF THIS CLASS APPEAR TO BE ACCESSED INCONSISTENTLY WITH RESPECT TO \u000aSYNCHRONIZATION.  THIS BUG REPORT INDICATES THAT THE BUG PATTERN DETECTOR \u000aJUDGED THAT \u000a  * THE CLASS CONTAINS A MIX OF LOCKED AND UNLOCKED ACCESSES, \u000a  * THE CLASS IS NOT ANNOTATED AS JAVAX.ANNOTATION.CONCURRENT.NOTTHREADSAFE, \u000a  * AT LEAST ONE LOCKED ACCESS WAS PERFORMED BY ONE OF THE CLASS&apos;S OWN \u000a    METHODS, AND \u000a  * THE NUMBER OF UNSYNCHRONIZED FIELD ACCESSES (READS AND WRITES) WAS NO MORE \u000a    THAN ONE THIRD OF ALL ACCESSES, WITH WRITES BEING WEIGHED TWICE AS HIGH AS \u000a    READS \u000a  \u000aA TYPICAL BUG MATCHING THIS BUG PATTERN IS FORGETTING TO SYNCHRONIZE ONE OF \u000aTHE METHODS IN A CLASS THAT IS INTENDED TO BE THREAD-SAFE. \u000aYOU CAN SELECT THE NODES LABELED &quot;UNSYNCHRONIZED ACCESS&quot; TO SHOW THE CODE \u000aLOCATIONS WHERE THE DETECTOR BELIEVED THAT A FIELD WAS ACCESSED WITHOUT \u000aSYNCHRONIZATION. \u000aNOTE THAT THERE ARE VARIOUS SOURCES OF INACCURACY IN THIS DETECTOR; FOR \u000aEXAMPLE, THE DETECTOR CANNOT STATICALLY DETECT ALL SITUATIONS IN WHICH A LOCK \u000aIS HELD.  ALSO, EVEN WHEN THE DETECTOR IS ACCURATE IN DISTINGUISHING LOCKED \u000aVS. UNLOCKED ACCESSES, THE CODE IN QUESTION MAY STILL BE CORRECT.\u000a,CLASS IS SERIALIZABLE, BUT DOESN&apos;T DEFINE SERIALVERSIONUID{0} IS SERIALIZABLE; CONSIDER DECLARING A SERIALVERSIONUIDBAD_PRACTICETHIS CLASS IMPLEMENTS THE SERIALIZABLE INTERFACE, BUT DOES NOT DEFINE A SERIALVERSIONUID \u000aFIELD.  A CHANGE AS SIMPLE AS ADDING A REFERENCE TO A .CLASS OBJECT WILL ADD \u000aSYNTHETIC FIELDS TO THE CLASS, WHICH WILL UNFORTUNATELY CHANGE THE IMPLICIT \u000aSERIALVERSIONUID (E.G., ADDING A REFERENCE TO STRING.CLASS WILL GENERATE A \u000aSTATIC FIELD CLASS$JAVA$LANG$STRING). ALSO, DIFFERENT SOURCE CODE TO BYTECODE \u000aCOMPILERS MAY USE DIFFERENT NAMING CONVENTIONS FOR SYNTHETIC VARIABLES \u000aGENERATED FOR REFERENCES TO CLASS OBJECTS OR INNER CLASSES. TO ENSURE \u000aINTEROPERABILITY OF SERIALIZABLE ACROSS VERSIONS, CONSIDER ADDING AN EXPLICIT \u000aSERIALVERSIONUID.\u000a,VALUE ANNOTATED AS CARRYING A TYPE QUALIFIER USED WHERE A VALUE THAT MUST NOT CARRY THAT QUALIFIER IS REQUIREDVALUE ANNOTATED AS CARRYING TYPE QUALIFIER {2.SIMPLENAME} USED WHERE A VALUE THAT MUST NOT CARRY THAT QUALIFIER IS REQUIREDCORRECTNESSA VALUE SPECIFIED AS CARRYING A TYPE QUALIFIER ANNOTATION IS CONSUMED IN A \u000aLOCATION OR LOCATIONS REQUIRING THAT THE VALUE NOT CARRY THAT ANNOTATION. \u000aMORE PRECISELY, A VALUE ANNOTATED WITH A TYPE QUALIFIER SPECIFYING WHEN=ALWAYS \u000aIS GUARANTEED TO REACH A USE OR USES WHERE THE SAME TYPE QUALIFIER SPECIFIES \u000aWHEN=NEVER. \u000aFOR EXAMPLE, SAY THAT @NONNEGATIVE IS A NICKNAME FOR THE TYPE QUALIFIER \u000aANNOTATION @NEGATIVE(WHEN=WHEN.NEVER). THE FOLLOWING CODE WILL GENERATE THIS \u000aWARNING BECAUSE THE RETURN STATEMENT REQUIRES A @NONNEGATIVE VALUE, BUT \u000aRECEIVES ONE THAT IS MARKED AS @NEGATIVE. \u000aPUBLIC @NONNEGATIVE INTEGER EXAMPLE(@NEGATIVE INTEGER VALUE) {\u000a    RETURN VALUE;\u000a},FIELDS OF IMMUTABLE CLASSES SHOULD BE FINAL{1.GIVENCLASS} SHOULD BE FINAL SINCE {0} IS MARKED AS IMMUTABLE.  BAD_PRACTICETHE CLASS IS ANNOTATED WITH NET.JCIP.ANNOTATIONS.IMMUTABLE OR \u000aJAVAX.ANNOTATION.CONCURRENT.IMMUTABLE, AND THE RULES FOR THOSE ANNOTATIONS \u000aREQUIRE THAT ALL FIELDS ARE FINAL. .\u000a,EXCEPTION IS CAUGHT WHEN EXCEPTION IS NOT THROWNEXCEPTION IS CAUGHT WHEN EXCEPTION IS NOT THROWN IN {1}STYLETHIS METHOD USES A TRY-CATCH BLOCK THAT CATCHES EXCEPTION OBJECTS, BUT \u000aEXCEPTION IS NOT THROWN WITHIN THE TRY BLOCK, AND RUNTIMEEXCEPTION IS NOT \u000aEXPLICITLY CAUGHT. IT IS A COMMON BUG PATTERN TO SAY TRY { ... } CATCH \u000a(EXCEPTION E) { SOMETHING } AS A SHORTHAND FOR CATCHING A NUMBER OF TYPES OF \u000aEXCEPTION EACH OF WHOSE CATCH BLOCKS IS IDENTICAL, BUT THIS CONSTRUCT ALSO \u000aACCIDENTALLY CATCHES RUNTIMEEXCEPTION AS WELL, MASKING POTENTIAL BUGS. \u000aA BETTER APPROACH IS TO EITHER EXPLICITLY CATCH THE SPECIFIC EXCEPTIONS THAT \u000aARE THROWN, OR TO EXPLICITLY CATCH RUNTIMEEXCEPTION EXCEPTION, RETHROW IT, AND \u000aTHEN CATCH ALL NON-RUNTIME EXCEPTIONS, AS SHOWN BELOW: \u000a  TRY {\u000a    ...\u000a  } CATCH (RUNTIMEEXCEPTION E) {\u000a    THROW E;\u000a  } CATCH (EXCEPTION E) {\u000a    ... DEAL WITH ALL NON-RUNTIME EXCEPTIONS ...\u000a  },ABSOLUTE PATH TRAVERSAL IN SERVLETABSOLUTE PATH TRAVERSAL IN {1}SECURITYTHE SOFTWARE USES AN HTTP REQUEST PARAMETER TO CONSTRUCT A PATHNAME THAT \u000aSHOULD BE WITHIN A RESTRICTED DIRECTORY, BUT IT DOES NOT PROPERLY NEUTRALIZE \u000aABSOLUTE PATH SEQUENCES SUCH AS &quot;/ABS/PATH&quot; THAT CAN RESOLVE TO A LOCATION \u000aTHAT IS OUTSIDE OF THAT DIRECTORY. SEE HTTP://CWE.MITRE.ORG/DATA/DEFINITIONS/36.HTML \u000aFOR MORE INFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF ABSOLUTE PATH \u000aTRAVERSAL. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE \u000aVULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED ABOUT \u000aABSOLUTE PATH TRAVERSAL, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL \u000aSTATIC ANALYSIS OR PEN-TESTING TOOL.\u000a,REDUNDANT NULLCHECK OF VALUE KNOWN TO BE NON-NULLREDUNDANT NULLCHECK OF {2}, WHICH IS KNOWN TO BE NON-NULL IN {1}STYLETHIS METHOD CONTAINS A REDUNDANT CHECK OF A KNOWN NON-NULL VALUE AGAINST THE \u000aCONSTANT NULL.\u000a,CLASSLOADERS SHOULD ONLY BE CREATED INSIDE DOPRIVILEGED BLOCK{1} CREATES A {2} CLASSLOADER, WHICH SHOULD BE PERFORMED WITHIN A DOPRIVILEGED BLOCKMALICIOUS_CODETHIS CODE CREATES A CLASSLOADER, WHICH NEEDS PERMISSION IF A SECURITY MANAGE \u000aIS INSTALLED. IF THIS CODE MIGHT BE INVOKED BY CODE THAT DOES NOT HAVE \u000aSECURITY PERMISSIONS, THEN THE CLASSLOADER CREATION NEEDS TO OCCUR INSIDE A \u000aDOPRIVILEGED BLOCK.\u000a,USELESS CONTROL FLOW TO NEXT LINEUSELESS CONTROL FLOW TO NEXT LINE IN {1}STYLETHIS METHOD CONTAINS A USELESS CONTROL FLOW STATEMENT IN WHICH CONTROL FLOW \u000aFOLLOWS TO THE SAME OR FOLLOWING LINE REGARDLESS OF WHETHER OR NOT THE BRANCH \u000aIS TAKEN. OFTEN, THIS IS CAUSED BY INADVERTENTLY USING AN EMPTY STATEMENT AS \u000aTHE BODY OF AN IF STATEMENT, E.G.: \u000a    IF (ARGV.LENGTH == 1);\u000a        SYSTEM.OUT.PRINTLN(&quot;HELLO, &quot; + ARGV[0]);,METHOD DIRECTLY ALLOCATES A SPECIFIC IMPLEMENTATION OF XML INTERFACES{1} DIRECTLY ALLOCATES A SPECIFIC IMPLEMENTATION OF XML INTERFACESSTYLETHIS METHOD ALLOCATES A SPECIFIC IMPLEMENTATION OF AN XML INTERFACE. IT IS \u000aPREFERABLE TO USE THE SUPPLIED FACTORY CLASSES TO CREATE THESE OBJECTS SO THAT \u000aTHE IMPLEMENTATION CAN BE CHANGED AT RUNTIME. SEE \u000a  * JAVAX.XML.PARSERS.DOCUMENTBUILDERFACTORY \u000a  * JAVAX.XML.PARSERS.SAXPARSERFACTORY \u000a  * JAVAX.XML.TRANSFORM.TRANSFORMERFACTORY \u000a  * ORG.W3C.DOM.DOCUMENT.CREATEXXXX \u000a  \u000aFOR DETAILS.\u000a,EQUALS() METHOD DOES NOT CHECK FOR NULL ARGUMENT{1} DOES NOT CHECK FOR NULL ARGUMENTBAD_PRACTICETHIS IMPLEMENTATION OF EQUALS(OBJECT) VIOLATES THE CONTRACT DEFINED BY \u000aJAVA.LANG.OBJECT.EQUALS() BECAUSE IT DOES NOT CHECK FOR NULL BEING PASSED AS \u000aTHE ARGUMENT. ALL EQUALS() METHODS SHOULD RETURN FALSE IF PASSED A NULL VALUE.\u000a,TESTING 1 TEST WARNING 1 GENERATED IN {1}EXPERIMENTALTHIS BUG PATTERN IS ONLY GENERATED BY NEW, INCOMPLETELY IMPLEMENTED BUG \u000aDETECTORS.\u000a,COULD BE REFACTORED INTO A NAMED STATIC INNER CLASSTHE CLASS {0} COULD BE REFACTORED INTO A NAMED _STATIC_ INNER CLASSPERFORMANCETHIS CLASS IS AN INNER CLASS, BUT DOES NOT USE ITS EMBEDDED REFERENCE TO THE \u000aOBJECT WHICH CREATED IT.  THIS REFERENCE MAKES THE INSTANCES OF THE CLASS \u000aLARGER, AND MAY KEEP THE REFERENCE TO THE CREATOR OBJECT ALIVE LONGER THAN \u000aNECESSARY.  IF POSSIBLE, THE CLASS SHOULD BE MADE INTO A STATIC INNER CLASS. \u000aSINCE ANONYMOUS INNER CLASSES CANNOT BE MARKED AS STATIC, DOING THIS WILL \u000aREQUIRE REFACTORING THE INNER CLASS SO THAT IT IS A NAMED INNER CLASS.\u000a,TESTING 3TEST WARNING 3 GENERATED IN {1}EXPERIMENTALTHIS BUG PATTERN IS ONLY GENERATED BY NEW, INCOMPLETELY IMPLEMENTED BUG \u000aDETECTORS.\u000a,METHOD INVOKES INEFFICIENT NEW STRING() CONSTRUCTOR{1} INVOKES INEFFICIENT NEW STRING() CONSTRUCTORPERFORMANCECREATING A NEW JAVA.LANG.STRING OBJECT USING THE NO-ARGUMENT CONSTRUCTOR \u000aWASTES MEMORY BECAUSE THE OBJECT SO CREATED WILL BE FUNCTIONALLY \u000aINDISTINGUISHABLE FROM THE EMPTY STRING CONSTANT &quot;&quot;.  JAVA GUARANTEES THAT \u000aIDENTICAL STRING CONSTANTS WILL BE REPRESENTED BY THE SAME STRING OBJECT.  \u000aTHEREFORE, YOU SHOULD JUST USE THE EMPTY STRING CONSTANT DIRECTLY.\u000a,TESTING 2TEST WARNING 2 GENERATED IN {1}EXPERIMENTALTHIS BUG PATTERN IS ONLY GENERATED BY NEW, INCOMPLETELY IMPLEMENTED BUG \u000aDETECTORS.\u000a,HTTP RESPONSE SPLITTING VULNERABILITYHTTP PARAMETER DIRECTLY WRITTEN TO HTTP HEADER OUTPUT IN {1}SECURITYTHIS CODE DIRECTLY WRITES AN HTTP PARAMETER TO AN HTTP HEADER, WHICH ALLOWS \u000aFOR A HTTP RESPONSE SPLITTING VULNERABILITY. SEE HTTP://EN.WIKIPEDIA.ORG/WIKI/HTTP_RESPONSE_SPLITTING \u000aFOR MORE INFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF HTTP RESPONSE \u000aSPLITTING. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE \u000aVULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED ABOUT HTTP \u000aRESPONSE SPLITTING, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL STATIC \u000aANALYSIS OR PEN-TESTING TOOL.\u000a,BAD APPLET CONSTRUCTOR RELIES ON UNINITIALIZED APPLETSTUBBAD APPLET CONSTRUCTOR RELIES ON UNINITIALIZED APPLETSTUBCORRECTNESSTHIS CONSTRUCTOR CALLS METHODS IN THE PARENT APPLET THAT RELY ON THE \u000aAPPLETSTUB. SINCE THE APPLETSTUB ISN&apos;T INITIALIZED UNTIL THE INIT() METHOD OF \u000aTHIS APPLET IS CALLED, THESE METHODS WILL NOT PERFORM CORRECTLY.\u000a,BOGUS WARNING ABOUT AN OPERATIONBOGUS WARNING ABOUT AN OPERATION {1}NOISEBOGUS WARNING.\u000a,REVERSED METHOD ARGUMENTSARGUMENTS IN WRONG ORDER FOR INVOCATION OF {2.NAME} IN {1}CORRECTNESSTHE ARGUMENTS TO THIS METHOD CALL SEEM TO BE IN THE WRONG ORDER. FOR EXAMPLE, \u000aA CALL PRECONDITIONS.CHECKNOTNULL(&quot;MESSAGE&quot;, MESSAGE) HAS RESERVED ARGUMENTS: \u000aTHE VALUE TO BE CHECKED IS THE FIRST ARGUMENT.\u000a,EQUALS() METHOD DEFINED THAT DOESN&apos;T OVERRIDE EQUALS(OBJECT){0} DEFINES {1.GIVENCLASS} METHOD THAT DOESN&apos;T OVERRIDE EQUALS(OBJECT)CORRECTNESSTHIS CLASS DEFINES AN EQUALS() METHOD, THAT DOESN&apos;T OVERRIDE THE NORMAL EQUALS(OBJECT) \u000aMETHOD DEFINED IN THE BASE JAVA.LANG.OBJECT CLASS.  INSTEAD, IT INHERITS AN EQUALS(OBJECT) \u000aMETHOD FROM A SUPERCLASS. THE CLASS SHOULD PROBABLY DEFINE A BOOLEAN \u000aEQUALS(OBJECT) METHOD.\u000a,HARDCODED CONSTANT DATABASE PASSWORDHARDCODED CONSTANT DATABASE PASSWORD IN {1}SECURITYTHIS CODE CREATES A DATABASE CONNECT USING A HARDCODED, CONSTANT PASSWORD. \u000aANYONE WITH ACCESS TO EITHER THE SOURCE CODE OR THE COMPILED CODE CAN EASILY \u000aLEARN THE PASSWORD.\u000a,COMPARETO()/COMPARE() RETURNS INTEGER.MIN_VALUE{1} RETURNS INTEGER.MIN_VALUE, WHICH CAN&apos;T BE NEGATEDCORRECTNESSIN SOME SITUATION, THIS COMPARETO OR COMPARE METHOD RETURNS THE CONSTANT \u000aINTEGER.MIN_VALUE, WHICH IS AN EXCEPTIONALLY BAD PRACTICE. THE ONLY THING THAT \u000aMATTERS ABOUT THE RETURN VALUE OF COMPARETO IS THE SIGN OF THE RESULT. BUT \u000aPEOPLE WILL SOMETIMES NEGATE THE RETURN VALUE OF COMPARETO, EXPECTING THAT \u000aTHIS WILL NEGATE THE SIGN OF THE RESULT. AND IT WILL, EXCEPT IN THE CASE WHERE \u000aTHE VALUE RETURNED IS INTEGER.MIN_VALUE. SO JUST RETURN -1 RATHER THAN \u000aINTEGER.MIN_VALUE.\u000a,READ OF UNWRITTEN FIELDREAD OF UNWRITTEN FIELD {2.NAME} IN {1}CORRECTNESSTHE PROGRAM IS DEREFERENCING A FIELD THAT DOES NOT SEEM TO EVER HAVE A \u000aNON-NULL VALUE WRITTEN TO IT. UNLESS THE FIELD IS INITIALIZED VIA SOME \u000aMECHANISM NOT SEEN BY THE ANALYSIS, DEREFERENCING THIS VALUE WILL GENERATE A \u000aNULL POINTER EXCEPTION.\u000a,USING POINTER EQUALITY TO COMPARE DIFFERENT TYPESUSING POINTER EQUALITY TO COMPARE A {2.GIVENCLASS} WITH A {3.GIVENCLASS} IN {1}CORRECTNESSTHIS METHOD USES USING POINTER EQUALITY TO COMPARE TWO REFERENCES THAT SEEM TO \u000aBE OF DIFFERENT TYPES. THE RESULT OF THIS COMPARISON WILL ALWAYS BE FALSE AT \u000aRUNTIME.\u000a,FINALIZER DOES NOTHING BUT CALL SUPERCLASS FINALIZER{1} DOES NOTHING EXCEPT CALL SUPER.FINALIZE(); DELETE ITBAD_PRACTICETHE ONLY THING THIS FINALIZE() METHOD DOES IS CALL THE SUPERCLASS&apos;S FINALIZE() \u000aMETHOD, MAKING IT REDUNDANT.  DELETE IT.\u000a,METHOD IGNORES RESULTS OF INPUTSTREAM.SKIP(){1} IGNORES RESULT OF {2}BAD_PRACTICETHIS METHOD IGNORES THE RETURN VALUE OF JAVA.IO.INPUTSTREAM.SKIP() WHICH CAN \u000aSKIP MULTIPLE BYTES.  IF THE RETURN VALUE IS NOT CHECKED, THE CALLER WILL NOT \u000aBE ABLE TO CORRECTLY HANDLE THE CASE WHERE FEWER BYTES WERE SKIPPED THAN THE \u000aCALLER REQUESTED.  THIS IS A PARTICULARLY INSIDIOUS KIND OF BUG, BECAUSE IN \u000aMANY PROGRAMS, SKIPS FROM INPUT STREAMS USUALLY DO SKIP THE FULL AMOUNT OF \u000aDATA REQUESTED, CAUSING THE PROGRAM TO FAIL ONLY SPORADICALLY. WITH BUFFERED \u000aSTREAMS, HOWEVER, SKIP() WILL ONLY SKIP DATA IN THE BUFFER, AND WILL ROUTINELY \u000aFAIL TO SKIP THE REQUESTED NUMBER OF BYTES.\u000a,METHOD IGNORES RESULTS OF INPUTSTREAM.READ(){1} IGNORES RESULT OF {2}BAD_PRACTICETHIS METHOD IGNORES THE RETURN VALUE OF ONE OF THE VARIANTS OF JAVA.IO.INPUTSTREAM.READ() \u000aWHICH CAN RETURN MULTIPLE BYTES.  IF THE RETURN VALUE IS NOT CHECKED, THE \u000aCALLER WILL NOT BE ABLE TO CORRECTLY HANDLE THE CASE WHERE FEWER BYTES WERE \u000aREAD THAN THE CALLER REQUESTED.  THIS IS A PARTICULARLY INSIDIOUS KIND OF BUG, \u000aBECAUSE IN MANY PROGRAMS, READS FROM INPUT STREAMS USUALLY DO READ THE FULL \u000aAMOUNT OF DATA REQUESTED, CAUSING THE PROGRAM TO FAIL ONLY SPORADICALLY.\u000a,CLASS&apos;S READOBJECT() METHOD IS SYNCHRONIZED{0}&apos;S READOBJECT METHOD IS SYNCHRONIZEDMT_CORRECTNESSTHIS SERIALIZABLE CLASS DEFINES A READOBJECT() WHICH IS SYNCHRONIZED.  BY \u000aDEFINITION, AN OBJECT CREATED BY DESERIALIZATION IS ONLY REACHABLE BY ONE \u000aTHREAD, AND THUS THERE IS NO NEED FOR READOBJECT() TO BE SYNCHRONIZED.  IF THE READOBJECT() \u000aMETHOD ITSELF IS CAUSING THE OBJECT TO BECOME VISIBLE TO ANOTHER THREAD, THAT \u000aIS AN EXAMPLE OF VERY DUBIOUS CODING STYLE.\u000a,UNCALLABLE METHOD DEFINED IN ANONYMOUS CLASSUNCALLABLE METHOD {1} DEFINED IN ANONYMOUS CLASSCORRECTNESSTHIS ANONYMOUS CLASS DEFINED A METHOD THAT IS NOT DIRECTLY INVOKED AND DOES \u000aNOT OVERRIDE A METHOD IN A SUPERCLASS. SINCE METHODS IN OTHER CLASSES CANNOT \u000aDIRECTLY INVOKE METHODS DECLARED IN AN ANONYMOUS CLASS, IT SEEMS THAT THIS \u000aMETHOD IS UNCALLABLE. THE METHOD MIGHT SIMPLY BE DEAD CODE, BUT IT IS ALSO \u000aPOSSIBLE THAT THE METHOD IS INTENDED TO OVERRIDE A METHOD DECLARED IN A \u000aSUPERCLASS, AND DUE TO AN TYPO OR OTHER ERROR THE METHOD DOES NOT, IN FACT, \u000aOVERRIDE THE METHOD IT IS INTENDED TO.\u000a,METHOD IGNORES RETURN VALUERETURN VALUE OF {2.GIVENCLASS} IGNORED IN {1}CORRECTNESSTHE RETURN VALUE OF THIS METHOD SHOULD BE CHECKED. ONE COMMON CAUSE OF THIS \u000aWARNING IS TO INVOKE A METHOD ON AN IMMUTABLE OBJECT, THINKING THAT IT UPDATES \u000aTHE OBJECT. FOR EXAMPLE, IN THE FOLLOWING CODE FRAGMENT, \u000aSTRING DATESTRING = GETHEADERFIELD(NAME);\u000aDATESTRING.TRIM();\u000aTHE PROGRAMMER SEEMS TO BE THINKING THAT THE TRIM() METHOD WILL UPDATE THE \u000aSTRING REFERENCED BY DATESTRING. BUT SINCE STRINGS ARE IMMUTABLE, THE TRIM() \u000aFUNCTION RETURNS A NEW STRING VALUE, WHICH IS BEING IGNORED HERE. THE CODE \u000aSHOULD BE CORRECTED TO: \u000aSTRING DATESTRING = GETHEADERFIELD(NAME);\u000aDATESTRING = DATESTRING.TRIM();,CONSIDER RETURNING A ZERO LENGTH ARRAY RATHER THAN NULLSHOULD {1} RETURN A ZERO LENGTH ARRAY RATHER THAN NULL?STYLEIT IS OFTEN A BETTER DESIGN TO RETURN A LENGTH ZERO ARRAY RATHER THAN A NULL \u000aREFERENCE TO INDICATE THAT THERE ARE NO RESULTS (I.E., AN EMPTY LIST OF \u000aRESULTS). THIS WAY, NO EXPLICIT CHECK FOR NULL IS NEEDED BY CLIENTS OF THE \u000aMETHOD. \u000aON THE OTHER HAND, USING NULL TO INDICATE &quot;THERE IS NO ANSWER TO THIS \u000aQUESTION&quot; IS PROBABLY APPROPRIATE. FOR EXAMPLE, FILE.LISTFILES() RETURNS AN \u000aEMPTY LIST IF GIVEN A DIRECTORY CONTAINING NO FILES, AND RETURNS NULL IF THE \u000aFILE IS NOT A DIRECTORY.\u000a,METHOD ATTEMPTS TO ACCESS A PREPARED STATEMENT PARAMETER WITH INDEX 0{1} ATTEMPTS TO ACCESS A PREPARED STATEMENT PARAMETER WITH INDEX 0CORRECTNESSA CALL TO A SETXXX METHOD OF A PREPARED STATEMENT WAS MADE WHERE THE PARAMETER \u000aINDEX IS 0. AS PARAMETER INDEXES START AT INDEX 1, THIS IS ALWAYS A MISTAKE.\u000a,NON-BOOLEAN ARGUMENT FORMATTED USING %B FORMAT SPECIFIERNON-BOOLEAN ARGUMENT FORMATTED USING %B FORMAT SPECIFIER IN {1}STYLEAN ARGUMENT NOT OF TYPE BOOLEAN IS BEING FORMATTED WITH A %B FORMAT SPECIFIER. \u000aTHIS WON&apos;T THROW AN EXCEPTION; INSTEAD, IT WILL PRINT TRUE FOR ANY NONNULL \u000aVALUE, AND FALSE FOR NULL. THIS FEATURE OF FORMAT STRINGS IS STRANGE, AND MAY \u000aNOT BE WHAT YOU INTENDED.\u000a,VALUE IS NULL AND GUARANTEED TO BE DEREFERENCED ON EXCEPTION PATH{2.NAME} IS NULL GUARANTEED TO BE DEREFERENCED IN {1} ON EXCEPTION PATHCORRECTNESSTHERE IS A STATEMENT OR BRANCH ON AN EXCEPTION PATH THAT IF EXECUTED \u000aGUARANTEES THAT A VALUE IS NULL AT THIS POINT, AND THAT VALUE THAT IS \u000aGUARANTEED TO BE DEREFERENCED (EXCEPT ON FORWARD PATHS INVOLVING RUNTIME \u000aEXCEPTIONS).\u000a,HTTP COOKIE FORMED FROM UNTRUSTED INPUTHTTP COOKIE FORMED FROM UNTRUSTED INPUT IN {1}SECURITYTHIS CODE CONSTRUCTS AN HTTP COOKIE USING AN UNTRUSTED HTTP PARAMETER. IF THIS \u000aCOOKIE IS ADDED TO AN HTTP RESPONSE, IT WILL ALLOW A HTTP RESPONSE SPLITTING \u000aVULNERABILITY. SEE HTTP://EN.WIKIPEDIA.ORG/WIKI/HTTP_RESPONSE_SPLITTING FOR \u000aMORE INFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF HTTP RESPONSE \u000aSPLITTING. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE \u000aVULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED ABOUT HTTP \u000aRESPONSE SPLITTING, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL STATIC \u000aANALYSIS OR PEN-TESTING TOOL.\u000a,CLASS NAMES SHOULDN&apos;T SHADOW SIMPLE NAME OF SUPERCLASSTHE CLASS NAME {0} SHADOWS THE SIMPLE NAME OF THE SUPERCLASS {1}BAD_PRACTICETHIS CLASS HAS A SIMPLE NAME THAT IS IDENTICAL TO THAT OF ITS SUPERCLASS, \u000aEXCEPT THAT ITS SUPERCLASS IS IN A DIFFERENT PACKAGE (E.G., ALPHA.FOO EXTENDS BETA.FOO). \u000aTHIS CAN BE EXCEPTIONALLY CONFUSING, CREATE LOTS OF SITUATIONS IN WHICH YOU \u000aHAVE TO LOOK AT IMPORT STATEMENTS TO RESOLVE REFERENCES AND CREATES MANY \u000aOPPORTUNITIES TO ACCIDENTLY DEFINE METHODS THAT DO NOT OVERRIDE METHODS IN \u000aTHEIR SUPERCLASSES.\u000a,SWITCH STATEMENT FOUND WHERE ONE CASE FALLS THROUGH TO THE NEXT CASESWITCH STATEMENT FOUND IN {1} WHERE ONE CASE FALLS THROUGH TO THE NEXT CASESTYLETHIS METHOD CONTAINS A SWITCH STATEMENT WHERE ONE CASE BRANCH WILL FALL \u000aTHROUGH TO THE NEXT CASE. USUALLY YOU NEED TO END THIS CASE WITH A BREAK OR \u000aRETURN.\u000a,MUTABLE SERVLET FIELD{1} IS A MUTABLE SERVLET FIELDMT_CORRECTNESSA WEB SERVER GENERALLY ONLY CREATES ONE INSTANCE OF SERVLET OR JSP CLASS \u000a(I.E., TREATS THE CLASS AS A SINGLETON), AND WILL HAVE MULTIPLE THREADS INVOKE \u000aMETHODS ON THAT INSTANCE TO SERVICE MULTIPLE SIMULTANEOUS REQUESTS. THUS, \u000aHAVING A MUTABLE INSTANCE FIELD GENERALLY CREATES RACE CONDITIONS.\u000a,METHOD DOESN&apos;T OVERRIDE METHOD IN SUPERCLASS DUE TO WRONG PACKAGE FOR PARAMETER{1} DOESN&apos;T OVERRIDE METHOD IN SUPERCLASS BECAUSE PARAMETER TYPE {4} DOESN&apos;T MATCH SUPERCLASS PARAMETER TYPE {5}BAD_PRACTICETHE METHOD IN THE SUBCLASS DOESN&apos;T OVERRIDE A SIMILAR METHOD IN A SUPERCLASS \u000aBECAUSE THE TYPE OF A PARAMETER DOESN&apos;T EXACTLY MATCH THE TYPE OF THE \u000aCORRESPONDING PARAMETER IN THE SUPERCLASS. FOR EXAMPLE, IF YOU HAVE: \u000aIMPORT ALPHA.FOO;\u000aPUBLIC CLASS A {\u000a  PUBLIC INT F(FOO X) { RETURN 17; }\u000a}\u000a----\u000aIMPORT BETA.FOO;\u000aPUBLIC CLASS B EXTENDS A {\u000a  PUBLIC INT F(FOO X) { RETURN 42; }\u000a  PUBLIC INT F(ALPHA.FOO X) { RETURN 27; }\u000a}\u000aTHE F(FOO) METHOD DEFINED IN CLASS B DOESN&apos;T OVERRIDE THE F(FOO) METHOD \u000aDEFINED IN CLASS A, BECAUSE THE ARGUMENT TYPES ARE FOO&apos;S FROM DIFFERENT \u000aPACKAGES. \u000aIN THIS CASE, THE SUBCLASS DOES DEFINE A METHOD WITH A SIGNATURE IDENTICAL TO \u000aTHE METHOD IN THE SUPERCLASS, SO THIS IS PRESUMABLY UNDERSTOOD. HOWEVER, SUCH \u000aMETHODS ARE EXCEPTIONALLY CONFUSING. YOU SHOULD STRONGLY CONSIDER REMOVING OR \u000aDEPRECATING THE METHOD WITH THE SIMILAR BUT NOT IDENTICAL SIGNATURE.\u000a,POSSIBLE NULL POINTER DEREFERENCE ON BRANCH THAT MIGHT BE INFEASIBLEPOSSIBLE NULL POINTER DEREFERENCE OF {2.GIVENCLASS} ON BRANCH THAT MIGHT BE INFEASIBLE IN {1}STYLETHERE IS A BRANCH OF STATEMENT THAT, IF EXECUTED, GUARANTEES THAT A NULL VALUE \u000aWILL BE DEREFERENCED, WHICH WOULD GENERATE A NULLPOINTEREXCEPTION WHEN THE \u000aCODE IS EXECUTED. OF COURSE, THE PROBLEM MIGHT BE THAT THE BRANCH OR STATEMENT \u000aIS INFEASIBLE AND THAT THE NULL POINTER EXCEPTION CAN&apos;T EVER BE EXECUTED; \u000aDECIDING THAT IS BEYOND THE ABILITY OF FINDBUGS. DUE TO THE FACT THAT THIS \u000aVALUE HAD BEEN PREVIOUSLY TESTED FOR NULLNESS, THIS IS A DEFINITE POSSIBILITY.\u000a,BOGUS WARNING ABOUT A FIELD REFERENCEBOGUS WARNING ABOUT A REFERENCE TO {2} IN {1}NOISEBOGUS WARNING.\u000a,METHOD DOES NOT RELEASE LOCK ON ALL EXCEPTION PATHS{1} DOES NOT RELEASE LOCK ON ALL EXCEPTION PATHSMT_CORRECTNESSTHIS METHOD ACQUIRES A JSR-166 (JAVA.UTIL.CONCURRENT) LOCK, BUT DOES NOT \u000aRELEASE IT ON ALL EXCEPTION PATHS OUT OF THE METHOD. IN GENERAL, THE CORRECT \u000aIDIOM FOR USING A JSR-166 LOCK IS: \u000a    LOCK L = ...;\u000a    L.LOCK();\u000a    TRY {\u000a        // DO SOMETHING\u000a    } FINALLY {\u000a        L.UNLOCK();\u000a    },VACUOUS BIT MASK OPERATION ON INTEGER VALUEVACUOUS {2} OPERATION ON {3} IN {1}STYLETHIS IS AN INTEGER BIT OPERATION (AND, OR, OR EXCLUSIVE OR) THAT DOESN&apos;T DO \u000aANY USEFUL WORK (E.G., V &amp; 0XFFFFFFFF).\u000a,TEST FOR FLOATING POINT EQUALITYTEST FOR FLOATING POINT EQUALITY IN {1}STYLETHIS OPERATION COMPARES TWO FLOATING POINT VALUES FOR EQUALITY. BECAUSE \u000aFLOATING POINT CALCULATIONS MAY INVOLVE ROUNDING, CALCULATED FLOAT AND DOUBLE \u000aVALUES MAY NOT BE ACCURATE. FOR VALUES THAT MUST BE PRECISE, SUCH AS MONETARY \u000aVALUES, CONSIDER USING A FIXED-PRECISION TYPE SUCH AS BIGDECIMAL. FOR VALUES \u000aTHAT NEED NOT BE PRECISE, CONSIDER COMPARING FOR EQUALITY WITHIN SOME RANGE, \u000aFOR EXAMPLE: IF ( MATH.ABS(X - Y) &lt; .0000001 ). SEE THE JAVA LANGUAGE \u000aSPECIFICATION, SECTION 4.2.4.\u000a,RELIANCE ON DEFAULT ENCODINGFOUND RELIANCE ON DEFAULT ENCODING IN {1}: {2}I18NFOUND A CALL TO A METHOD WHICH WILL PERFORM A BYTE TO STRING (OR STRING TO \u000aBYTE) CONVERSION, AND WILL ASSUME THAT THE DEFAULT PLATFORM ENCODING IS \u000aSUITABLE. THIS WILL CAUSE THE APPLICATION BEHAVIOUR TO VARY BETWEEN PLATFORMS. \u000aUSE AN ALTERNATIVE API AND SPECIFY A CHARSET NAME OR CHARSET OBJECT EXPLICITLY.\u000a,FIELD ONLY EVER SET TO NULLFIELD ONLY EVER SET TO NULL: {1}CORRECTNESSALL WRITES TO THIS FIELD ARE OF THE CONSTANT VALUE NULL, AND THUS ALL READS OF \u000aTHE FIELD WILL RETURN NULL. CHECK FOR ERRORS, OR REMOVE IT IF IT IS USELESS.\u000a,INCORRECT LAZY INITIALIZATION OF INSTANCE FIELDINCORRECT LAZY INITIALIZATION OF INSTANCE FIELD {2} IN {1}MT_CORRECTNESSTHIS METHOD CONTAINS AN UNSYNCHRONIZED LAZY INITIALIZATION OF A NON-VOLATILE \u000aFIELD. BECAUSE THE COMPILER OR PROCESSOR MAY REORDER INSTRUCTIONS, THREADS ARE \u000aNOT GUARANTEED TO SEE A COMPLETELY INITIALIZED OBJECT, IF THE METHOD CAN BE \u000aCALLED BY MULTIPLE THREADS. YOU CAN MAKE THE FIELD VOLATILE TO CORRECT THE \u000aPROBLEM. FOR MORE INFORMATION, SEE THE JAVA MEMORY MODEL WEB SITE.\u000a,UNREAD PUBLIC/PROTECTED FIELDUNREAD PUBLIC/PROTECTED FIELD: {1}STYLETHIS FIELD IS NEVER READ.  THE FIELD IS PUBLIC OR PROTECTED, SO PERHAPS IT IS \u000aINTENDED TO BE USED WITH CLASSES NOT SEEN AS PART OF THE ANALYSIS. IF NOT, \u000aCONSIDER REMOVING IT FROM THE CLASS.\u000a,DEADLY EMBRACE OF NON-STATIC INNER CLASS AND THREAD LOCAL{0} NEEDS TO BE _STATIC_ TO AVOID A DEADLY EMBRACE WITH {1}CORRECTNESSTHIS CLASS IS AN INNER CLASS, BUT SHOULD PROBABLY BE A STATIC INNER CLASS. AS \u000aIT IS, THERE IS A SERIOUS DANGER OF A DEADLY EMBRACE BETWEEN THE INNER CLASS \u000aAND THE THREAD LOCAL IN THE OUTER CLASS. BECAUSE THE INNER CLASS ISN&apos;T STATIC, \u000aIT RETAINS A REFERENCE TO THE OUTER CLASS. IF THE THREAD LOCAL CONTAINS A \u000aREFERENCE TO AN INSTANCE OF THE INNER CLASS, THE INNER AND OUTER INSTANCE WILL \u000aBOTH BE REACHABLE AND NOT ELIGIBLE FOR GARBAGE COLLECTION.\u000a,CALL TO EQUALS() COMPARING DIFFERENT TYPESCALL TO {3.SIMPLECLASS}.EQUALS({2.SIMPLECLASS}) IN {1}CORRECTNESSTHIS METHOD CALLS EQUALS(OBJECT) ON TWO REFERENCES OF DIFFERENT CLASS TYPES \u000aWITH NO COMMON SUBCLASSES. THEREFORE, THE OBJECTS BEING COMPARED ARE UNLIKELY \u000aTO BE MEMBERS OF THE SAME CLASS AT RUNTIME (UNLESS SOME APPLICATION CLASSES \u000aWERE NOT ANALYZED, OR DYNAMIC CLASS LOADING CAN OCCUR AT RUNTIME). ACCORDING \u000aTO THE CONTRACT OF EQUALS(), OBJECTS OF DIFFERENT CLASSES SHOULD ALWAYS \u000aCOMPARE AS UNEQUAL; THEREFORE, ACCORDING TO THE CONTRACT DEFINED BY \u000aJAVA.LANG.OBJECT.EQUALS(OBJECT), THE RESULT OF THIS COMPARISON WILL ALWAYS BE \u000aFALSE AT RUNTIME.\u000a,THE TYPE OF A SUPPLIED ARGUMENT DOESN&apos;T MATCH FORMAT SPECIFIERARGUMENT OF TYPE {3} CAN&apos;T BE HANDLED BY FORMAT SPECIFIER {4} IN {1}CORRECTNESSONE OF THE ARGUMENTS IS UNCOMPATIBLE WITH THE CORRESPONDING FORMAT STRING \u000aSPECIFIER. AS A RESULT, THIS WILL GENERATE A RUNTIME EXCEPTION WHEN EXECUTED. \u000aFOR EXAMPLE, STRING.FORMAT(&quot;%D&quot;, &quot;1&quot;) WILL GENERATE AN EXCEPTION, SINCE THE \u000aSTRING &quot;1&quot; IS INCOMPATIBLE WITH THE FORMAT SPECIFIER %D.\u000a,ARRAY FORMATTED IN USELESS WAY USING FORMAT STRINGARGUMENT OF TYPE {3} FORMATTED IN USELESS WAY IN {1}CORRECTNESSONE OF THE ARGUMENTS BEING FORMATTED WITH A FORMAT STRING IS AN ARRAY. THIS \u000aWILL BE FORMATTED USING A FAIRLY USELESS FORMAT, SUCH AS [I@304282, WHICH \u000aDOESN&apos;T ACTUALLY SHOW THE CONTENTS OF THE ARRAY. CONSIDER WRAPPING THE ARRAY \u000aUSING ARRAYS.ASLIST(...) BEFORE HANDLING IT OFF TO A FORMATTED.\u000a,POTENTIAL LOST LOGGER CHANGES DUE TO WEAK REFERENCE IN OPENJDKCHANGES TO LOGGER COULD BE LOST IN {1}EXPERIMENTALOPENJDK INTRODUCES A POTENTIAL INCOMPATIBILITY. IN PARTICULAR, THE \u000aJAVA.UTIL.LOGGING.LOGGER BEHAVIOR HAS CHANGED. INSTEAD OF USING STRONG \u000aREFERENCES, IT NOW USES WEAK REFERENCES INTERNALLY. THAT&apos;S A REASONABLE \u000aCHANGE, BUT UNFORTUNATELY SOME CODE RELIES ON THE OLD BEHAVIOR - WHEN CHANGING \u000aLOGGER CONFIGURATION, IT SIMPLY DROPS THE LOGGER REFERENCE. THAT MEANS THAT \u000aTHE GARBAGE COLLECTOR IS FREE TO RECLAIM THAT MEMORY, WHICH MEANS THAT THE \u000aLOGGER CONFIGURATION IS LOST. FOR EXAMPLE, CONSIDER: \u000aPUBLIC STATIC VOID INITLOGGING() THROWS EXCEPTION {\u000a LOGGER LOGGER = LOGGER.GETLOGGER(&quot;EDU.UMD.CS&quot;);\u000a LOGGER.ADDHANDLER(NEW FILEHANDLER()); // CALL TO CHANGE LOGGER CONFIGURATION\u000a LOGGER.SETUSEPARENTHANDLERS(FALSE); // ANOTHER CALL TO CHANGE LOGGER CONFIGURATION\u000a}\u000aTHE LOGGER REFERENCE IS LOST AT THE END OF THE METHOD (IT DOESN&apos;T ESCAPE THE \u000aMETHOD), SO IF YOU HAVE A GARBAGE COLLECTION CYCLE JUST AFTER THE CALL TO \u000aINITLOGGING, THE LOGGER CONFIGURATION IS LOST (BECAUSE LOGGER ONLY KEEPS WEAK \u000aREFERENCES). \u000aPUBLIC STATIC VOID MAIN(STRING[] ARGS) THROWS EXCEPTION {\u000a INITLOGGING(); // ADDS A FILE HANDLER TO THE LOGGER\u000a SYSTEM.GC(); // LOGGER CONFIGURATION LOST\u000a LOGGER.GETLOGGER(&quot;EDU.UMD.CS&quot;).INFO(&quot;SOME MESSAGE&quot;); // THIS ISN&apos;T LOGGED TO THE FILE AS EXPECTED\u000a}\u000aULF OCHSENFAHRT AND ERIC FELLHEIMER\u000a,METHOD ALLOCATES AN OBJECT, ONLY TO GET THE CLASS OBJECT{1} ALLOCATES AN OBJECT, ONLY TO GET THE CLASS OBJECTPERFORMANCETHIS METHOD ALLOCATES AN OBJECT JUST TO CALL GETCLASS() ON IT, IN ORDER TO \u000aRETRIEVE THE CLASS OBJECT FOR IT. IT IS SIMPLER TO JUST ACCESS THE .CLASS \u000aPROPERTY OF THE CLASS.\u000a,METHOD USES THE SAME CODE FOR TWO BRANCHES{1} USES THE SAME CODE FOR TWO BRANCHESSTYLETHIS METHOD USES THE SAME CODE TO IMPLEMENT TWO BRANCHES OF A CONDITIONAL \u000aBRANCH. CHECK TO ENSURE THAT THIS ISN&apos;T A CODING MISTAKE.\u000a,UNWRITTEN FIELDUNWRITTEN FIELD: {1}CORRECTNESSTHIS FIELD IS NEVER WRITTEN.  ALL READS OF IT WILL RETURN THE DEFAULT VALUE. \u000aCHECK FOR ERRORS (SHOULD IT HAVE BEEN INITIALIZED?), OR REMOVE IT IF IT IS \u000aUSELESS.\u000a,CODE CONTAINS A HARD CODED REFERENCE TO AN ABSOLUTE PATHNAMEHARD CODED REFERENCE TO AN ABSOLUTE PATHNAME IN {1}STYLETHIS CODE CONSTRUCTS A FILE OBJECT USING A HARD CODED TO AN ABSOLUTE PATHNAME \u000a(E.G., NEW \u000aFILE(&quot;/HOME/DANNYC/WORKSPACE/J2EE/SRC/SHARE/COM/SUN/ENTERPRISE/DEPLOYMENT&quot;);\u000a,IMPOSSIBLE CAST INVOLVING PRIMITIVE ARRAYIMPOSSIBLE CAST INVOLVING PRIMITIVE ARRAY IN {1}CORRECTNESSTHIS CAST WILL ALWAYS THROW A CLASSCASTEXCEPTION.\u000a,CREATES AN EMPTY ZIP FILE ENTRYEMPTY ZIP FILE ENTRY CREATED IN {1}BAD_PRACTICETHE CODE CALLS PUTNEXTENTRY(), IMMEDIATELY FOLLOWED BY A CALL TO CLOSEENTRY(). \u000aTHIS RESULTS IN AN EMPTY ZIPFILE ENTRY. THE CONTENTS OF THE ENTRY SHOULD BE \u000aWRITTEN TO THE ZIPFILE BETWEEN THE CALLS TO PUTNEXTENTRY() AND CLOSEENTRY().\u000a,CHECK FOR SIGN OF BITWISE OPERATIONCHECK FOR SIGN OF BITWISE OPERATION IN {1}BAD_PRACTICETHIS METHOD COMPARES AN EXPRESSION SUCH AS \u000a((EVENT.DETAIL &amp; SWT.SELECTED) > 0)\u000a. USING BIT ARITHMETIC AND THEN COMPARING WITH THE GREATER THAN OPERATOR CAN \u000aLEAD TO UNEXPECTED RESULTS (OF COURSE DEPENDING ON THE VALUE OF SWT.SELECTED). \u000aIF SWT.SELECTED IS A NEGATIVE NUMBER, THIS IS A CANDIDATE FOR A BUG. EVEN WHEN \u000aSWT.SELECTED IS NOT NEGATIVE, IT SEEMS GOOD PRACTICE TO USE &apos;!= 0&apos; INSTEAD OF \u000a&apos;> 0&apos;. \u000aBORIS BOKOWSKI\u000a,QUESTIONABLE USE OF NON-SHORT-CIRCUIT LOGICQUESTIONABLE USE OF NON-SHORT-CIRCUIT LOGIC IN {1}STYLETHIS CODE SEEMS TO BE USING NON-SHORT-CIRCUIT LOGIC (E.G., &amp; OR |) RATHER THAN \u000aSHORT-CIRCUIT LOGIC (&amp;&amp; OR ||). NON-SHORT-CIRCUIT LOGIC CAUSES BOTH SIDES OF \u000aTHE EXPRESSION TO BE EVALUATED EVEN WHEN THE RESULT CAN BE INFERRED FROM \u000aKNOWING THE LEFT-HAND SIDE. THIS CAN BE LESS EFFICIENT AND CAN RESULT IN \u000aERRORS IF THE LEFT-HAND SIDE GUARDS CASES WHEN EVALUATING THE RIGHT-HAND SIDE \u000aCAN GENERATE AN ERROR. \u000aSEE THE JAVA LANGUAGE SPECIFICATION FOR DETAILS\u000a,APPARENT METHOD/CONSTRUCTOR CONFUSION{1} WAS PROBABLY INTENDED TO BE A CONSTRUCTORCORRECTNESSTHIS REGULAR METHOD HAS THE SAME NAME AS THE CLASS IT IS DEFINED IN. IT IS \u000aLIKELY THAT THIS WAS INTENDED TO BE A CONSTRUCTOR. IF IT WAS INTENDED TO BE A \u000aCONSTRUCTOR, REMOVE THE DECLARATION OF A VOID RETURN VALUE. IF YOU HAD \u000aACCIDENTLY DEFINED THIS METHOD, REALIZED THE MISTAKE, DEFINED A PROPER \u000aCONSTRUCTOR BUT CAN&apos;T GET RID OF THIS METHOD DUE TO BACKWARDS COMPATIBILITY, \u000aDEPRECATE THE METHOD.\u000a,CALL TO EQUALS() COMPARING DIFFERENT INTERFACE TYPESCALL TO {3.SIMPLECLASS}.EQUALS({2.SIMPLECLASS}) IN {1}CORRECTNESSTHIS METHOD CALLS EQUALS(OBJECT) ON TWO REFERENCES OF UNRELATED INTERFACE \u000aTYPES, WHERE NEITHER IS A SUBTYPE OF THE OTHER, AND THERE ARE NO KNOWN \u000aNON-ABSTRACT CLASSES WHICH IMPLEMENT BOTH INTERFACES. THEREFORE, THE OBJECTS \u000aBEING COMPARED ARE UNLIKELY TO BE MEMBERS OF THE SAME CLASS AT RUNTIME (UNLESS \u000aSOME APPLICATION CLASSES WERE NOT ANALYZED, OR DYNAMIC CLASS LOADING CAN OCCUR \u000aAT RUNTIME). ACCORDING TO THE CONTRACT OF EQUALS(), OBJECTS OF DIFFERENT \u000aCLASSES SHOULD ALWAYS COMPARE AS UNEQUAL; THEREFORE, ACCORDING TO THE CONTRACT \u000aDEFINED BY JAVA.LANG.OBJECT.EQUALS(OBJECT), THE RESULT OF THIS COMPARISON WILL \u000aALWAYS BE FALSE AT RUNTIME.\u000a,NON SERIALIZABLE OBJECT WRITTEN TO OBJECTOUTPUTNON SERIALIZABLE {2} WRITTEN TO OBJECTOUTPUT IN {1}STYLETHIS CODE SEEMS TO BE PASSING A NON-SERIALIZABLE OBJECT TO THE \u000aOBJECTOUTPUT.WRITEOBJECT METHOD. IF THE OBJECT IS, INDEED, NON-SERIALIZABLE, \u000aAN ERROR WILL RESULT.\u000a,REMAINDER OF 32-BIT SIGNED RANDOM INTEGERREMAINDER OF 32-BIT SIGNED RANDOM INTEGER COMPUTED IN {1}STYLETHIS CODE GENERATES A RANDOM SIGNED INTEGER AND THEN COMPUTES THE REMAINDER OF \u000aTHAT VALUE MODULO ANOTHER VALUE. SINCE THE RANDOM NUMBER CAN BE NEGATIVE, THE \u000aRESULT OF THE REMAINDER OPERATION CAN ALSO BE NEGATIVE. BE SURE THIS IS \u000aINTENDED, AND STRONGLY CONSIDER USING THE RANDOM.NEXTINT(INT) METHOD INSTEAD.\u000a,SERVLET REFLECTED CROSS SITE SCRIPTING VULNERABILITY IN ERROR PAGEHTTP PARAMETER WRITTEN TO SERVLET ERROR PAGE IN {1}SECURITYTHIS CODE DIRECTLY WRITES AN HTTP PARAMETER TO A SERVER ERROR PAGE (USING \u000aHTTPSERVLETRESPONSE.SENDERROR). ECHOING THIS UNTRUSTED INPUT ALLOWS FOR A \u000aREFLECTED CROSS SITE SCRIPTING VULNERABILITY. SEE HTTP://EN.WIKIPEDIA.ORG/WIKI/CROSS-SITE_SCRIPTING \u000aFOR MORE INFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF CROSS SITE \u000aSCRIPTING. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE CROSS SITE \u000aSCRIPTING VULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED \u000aABOUT CROSS SITE SCRIPTING, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL \u000aSTATIC ANALYSIS OR PEN-TESTING TOOL.\u000a,METHOD ACCESSES A PRIVATE MEMBER VARIABLE OF OWNING CLASS{1} ACCESSES TO A PRIVATE MEMBER VARIABLE OF OWNING CLASSPERFORMANCETHIS METHOD OF AN INNER CLASS READS FROM OR WRITES TO A PRIVATE MEMBER \u000aVARIABLE OF THE OWNING CLASS, OR CALLS A PRIVATE METHOD OF THE OWNING CLASS. \u000aTHE COMPILER MUST GENERATE A SPECIAL METHOD TO ACCESS THIS PRIVATE MEMBER, \u000aCAUSING THIS TO BE LESS EFFICIENT. RELAXING THE PROTECTION OF THE MEMBER \u000aVARIABLE OR METHOD WILL ALLOW THE COMPILER TO TREAT THIS AS A NORMAL ACCESS.\u000a,CLASS DEFINES EQUAL(OBJECT); SHOULD IT BE EQUALS(OBJECT)?CLASS {0} DEFINES EQUAL(OBJECT); SHOULD IT BE EQUALS(OBJECT)?CORRECTNESSTHIS CLASS DEFINES A METHOD EQUAL(OBJECT).  THIS METHOD DOES NOT OVERRIDE THE EQUALS(OBJECT) \u000aMETHOD IN JAVA.LANG.OBJECT, WHICH IS PROBABLY WHAT WAS INTENDED.\u000a,POSSIBLE NULL POINTER DEREFERENCE DUE TO RETURN VALUE OF CALLED METHODPOSSIBLE NULL POINTER DEREFERENCE IN {1} DUE TO RETURN VALUE OF CALLED METHODSTYLETHE RETURN VALUE FROM A METHOD IS DEREFERENCED WITHOUT A NULL CHECK, AND THE \u000aRETURN VALUE OF THAT METHOD IS ONE THAT SHOULD GENERALLY BE CHECKED FOR NULL. \u000aTHIS MAY LEAD TO A NULLPOINTEREXCEPTION WHEN THE CODE IS EXECUTED.\u000a,SUSPICIOUS REFERENCE COMPARISON OF BOOLEAN VALUESSUSPICIOUS COMPARISON OF BOOLEAN REFERENCES IN {1}BAD_PRACTICETHIS METHOD COMPARES TWO BOOLEAN VALUES USING THE == OR != OPERATOR. NORMALLY, \u000aTHERE ARE ONLY TWO BOOLEAN VALUES (BOOLEAN.TRUE AND BOOLEAN.FALSE), BUT IT IS \u000aPOSSIBLE TO CREATE OTHER BOOLEAN OBJECTS USING THE NEW BOOLEAN(B) CONSTRUCTOR. \u000aIT IS BEST TO AVOID SUCH OBJECTS, BUT IF THEY DO EXIST, THEN CHECKING BOOLEAN \u000aOBJECTS FOR EQUALITY USING == OR != WILL GIVE RESULTS THAN ARE DIFFERENT THAN \u000aYOU WOULD GET USING .EQUALS(...)\u000a,PUBLIC STATIC METHOD MAY EXPOSE INTERNAL REPRESENTATION BY RETURNING ARRAYPUBLIC STATIC {1} MAY EXPOSE INTERNAL REPRESENTATION BY RETURNING {2.GIVENCLASS}MALICIOUS_CODEA PUBLIC STATIC METHOD RETURNS A REFERENCE TO AN ARRAY THAT IS PART OF THE \u000aSTATIC STATE OF THE CLASS. ANY CODE THAT CALLS THIS METHOD CAN FREELY MODIFY \u000aTHE UNDERLYING ARRAY. ONE FIX IS TO RETURN A COPY OF THE ARRAY.\u000a,METHOD SYNCHRONIZES ON AN UPDATED FIELD{1} SYNCHRONIZES ON UPDATED FIELD {2.GIVENCLASS}MT_CORRECTNESSTHIS METHOD SYNCHRONIZES ON AN OBJECT REFERENCED FROM A MUTABLE FIELD. THIS IS \u000aUNLIKELY TO HAVE USEFUL SEMANTICS, SINCE DIFFERENT THREADS MAY BE \u000aSYNCHRONIZING ON DIFFERENT OBJECTS.\u000a,BOGUS WARNING ABOUT A NULL POINTER DEREFERENCEBOGUS WARNING ABOUT A NULL POINTER DEREFERENCE IN {1}NOISEBOGUS WARNING.\u000a,WRITE TO STATIC FIELD FROM INSTANCE METHODWRITE TO STATIC FIELD {2} FROM INSTANCE METHOD {1}STYLETHIS INSTANCE METHOD WRITES TO A STATIC FIELD. THIS IS TRICKY TO GET CORRECT \u000aIF MULTIPLE INSTANCES ARE BEING MANIPULATED, AND GENERALLY BAD PRACTICE.\u000a,UNUSED FIELDUNUSED FIELD: {1}PERFORMANCETHIS FIELD IS NEVER USED.  CONSIDER REMOVING IT FROM THE CLASS.\u000a,INEFFICIENT USE OF STRING.LASTINDEXOF(STRING){1} USES STRING.LASTINDEXOF(STRING) INSTEAD OF STRING.LASTINDEXOF(INT)PERFORMANCETHIS CODE PASSES A CONSTANT STRING OF LENGTH 1 TO STRING.LASTINDEXOF(). IT IS \u000aMORE EFFICIENT TO USE THE INTEGER IMPLEMENTATIONS OF STRING.LASTINDEXOF(). F. \u000aE. CALL MYSTRING.LASTINDEXOF(&apos;.&apos;) INSTEAD OF MYSTRING.LASTINDEXOF(&quot;.&quot;)\u000a,ABSTRACT CLASS DEFINES COVARIANT EQUALS() METHODABSTRACT {0} DEFINES EQUALS({0.GIVENCLASS}) METHODBAD_PRACTICETHIS CLASS DEFINES A COVARIANT VERSION OF EQUALS().  TO CORRECTLY OVERRIDE THE EQUALS() \u000aMETHOD IN JAVA.LANG.OBJECT, THE PARAMETER OF EQUALS() MUST HAVE TYPE JAVA.LANG.OBJECT.\u000a,IMPOSSIBLE CASTIMPOSSIBLE CAST FROM {2} TO {3} IN {1}CORRECTNESSTHIS CAST WILL ALWAYS THROW A CLASSCASTEXCEPTION. FINDBUGS TRACKS TYPE \u000aINFORMATION FROM INSTANCEOF CHECKS, AND ALSO USES MORE PRECISE INFORMATION \u000aABOUT THE TYPES OF VALUES RETURNED FROM METHODS AND LOADED FROM FIELDS. THUS, \u000aIT MAY HAVE MORE PRECISE INFORMATION THAT JUST THE DECLARED TYPE OF A \u000aVARIABLE, AND CAN USE THIS TO DETERMINE THAT A CAST WILL ALWAYS THROW AN \u000aEXCEPTION AT RUNTIME.\u000a,SWITCH STATEMENT FOUND WHERE DEFAULT CASE IS MISSINGSWITCH STATEMENT FOUND IN {1} WHERE DEFAULT CASE IS MISSINGSTYLETHIS METHOD CONTAINS A SWITCH STATEMENT WHERE DEFAULT CASE IS MISSING. USUALLY \u000aYOU NEED TO PROVIDE A DEFAULT CASE. \u000aBECAUSE THE ANALYSIS ONLY LOOKS AT THE GENERATED BYTECODE, THIS WARNING CAN BE \u000aINCORRECT TRIGGERED IF THE DEFAULT CASE IS AT THE END OF THE SWITCH STATEMENT \u000aAND DOESN&apos;T END WITH A BREAK STATEMENT.\u000a,CLASS EXPOSES SYNCHRONIZATION AND SEMAPHORES IN ITS PUBLIC INTERFACECLASS {0} EXPOSES SYNCHRONIZATION AND SEMAPHORES IN ITS PUBLIC INTERFACESTYLETHIS CLASS USES SYNCHRONIZATION ALONG WITH WAIT(), NOTIFY() OR NOTIFYALL() ON \u000aITSELF (THE THIS REFERENCE). CLIENT CLASSES THAT USE THIS CLASS, MAY, IN \u000aADDITION, USE AN INSTANCE OF THIS CLASS AS A SYNCHRONIZING OBJECT. BECAUSE TWO \u000aCLASSES ARE USING THE SAME OBJECT FOR SYNCHRONIZATION, MULTITHREAD CORRECTNESS \u000aIS SUSPECT. YOU SHOULD NOT SYNCHRONIZE NOR CALL SEMAPHORE METHODS ON A PUBLIC \u000aREFERENCE. CONSIDER USING A INTERNAL PRIVATE MEMBER VARIABLE TO CONTROL \u000aSYNCHRONIZATION.\u000a,CALL TO EQUALS(NULL)CALL TO EQUALS(NULL) IN {1}CORRECTNESSTHIS METHOD CALLS EQUALS(OBJECT), PASSING A NULL VALUE AS THE ARGUMENT. \u000aACCORDING TO THE CONTRACT OF THE EQUALS() METHOD, THIS CALL SHOULD ALWAYS \u000aRETURN FALSE.\u000a,MAY EXPOSE INTERNAL STATIC STATE BY STORING A MUTABLE OBJECT INTO A STATIC FIELD{1} MAY EXPOSE INTERNAL STATIC STATE BY STORING A MUTABLE OBJECT INTO A STATIC FIELD {2}MALICIOUS_CODETHIS CODE STORES A REFERENCE TO AN EXTERNALLY MUTABLE OBJECT INTO A STATIC \u000aFIELD. IF UNCHECKED CHANGES TO THE MUTABLE OBJECT WOULD COMPROMISE SECURITY OR \u000aOTHER IMPORTANT PROPERTIES, YOU WILL NEED TO DO SOMETHING DIFFERENT. STORING A \u000aCOPY OF THE OBJECT IS BETTER APPROACH IN MANY SITUATIONS.\u000a,INVOCATION OF TOSTRING ON AN UNNAMED ARRAYINVOCATION OF TOSTRING ON AN UNNAMED ARRAY IN {1}CORRECTNESSTHE CODE INVOKES TOSTRING ON AN (ANONYMOUS) ARRAY. CALLING TOSTRING ON AN \u000aARRAY GENERATES A FAIRLY USELESS RESULT SUCH AS [C@16F0472. CONSIDER USING \u000aARRAYS.TOSTRING TO CONVERT THE ARRAY INTO A READABLE STRING THAT GIVES THE \u000aCONTENTS OF THE ARRAY. SEE PROGRAMMING PUZZLERS, CHAPTER 3, PUZZLE 12.\u000a,VALUE THAT MIGHT NOT CARRY A TYPE QUALIFIER IS ALWAYS USED IN A WAY REQUIRES THAT TYPE QUALIFIERVALUE THAT MIGHT NOT CARRY THE {2.SIMPLENAME} ANNOTATION IS ALWAYS USED IN A WAY THAT REQUIRES THAT TYPE QUALIFIERCORRECTNESSA VALUE THAT IS ANNOTATED AS POSSIBILITY NOT BEING AN INSTANCE OF THE VALUES \u000aDENOTED BY THE TYPE QUALIFIER, AND THE VALUE IS GUARANTEED TO BE USED IN A WAY \u000aTHAT REQUIRES VALUES DENOTED BY THAT TYPE QUALIFIER.\u000a,CLOSE() INVOKED ON A VALUE THAT IS ALWAYS NULLCAN&apos;T CLOSE {2.GIVENCLASS} SINCE IT IS ALWAYS NULL IN {1}CORRECTNESSCLOSE() IS BEING INVOKED ON A VALUE THAT IS ALWAYS NULL. IF THIS STATEMENT IS \u000aEXECUTED, A NULL POINTER EXCEPTION WILL OCCUR. BUT THE BIG RISK HERE YOU NEVER \u000aCLOSE SOMETHING THAT SHOULD BE CLOSED.\u000a,DOUBLE.LONGBITSTODOUBLE INVOKED ON AN INTDOUBLE.LONGBITSTODOUBLE INVOKED ON AN INT IN {1}CORRECTNESSTHE DOUBLE.LONGBITSTODOUBLE METHOD IS INVOKED, BUT A 32 BIT INT VALUE IS \u000aPASSED AS AN ARGUMENT. THIS ALMOSTLY CERTAINLY IS NOT INTENDED AND IS UNLIKELY \u000aTO GIVE THE INTENDED RESULT.\u000a,EQUALS METHOD COMPARES CLASS NAMES RATHER THAN CLASS OBJECTS{1} COMPARES CLASS NAMES RATHER THAN CLASS OBJECTSCORRECTNESSTHIS METHOD CHECKS TO SEE IF TWO OBJECTS ARE THE SAME CLASS BY CHECKING TO SEE \u000aIF THE NAMES OF THEIR CLASSES ARE EQUAL. YOU CAN HAVE DIFFERENT CLASSES WITH \u000aTHE SAME NAME IF THEY ARE LOADED BY DIFFERENT CLASS LOADERS. JUST CHECK TO SEE \u000aIF THE CLASS OBJECTS ARE THE SAME.\u000a,SYNCHRONIZATION ON BOXED PRIMITIVE VALUESSYNCHRONIZATION ON {2} IN {1}MT_CORRECTNESSTHE CODE SYNCHRONIZES ON AN APPARENTLY UNSHARED BOXED PRIMITIVE, SUCH AS AN \u000aINTEGER. \u000aPRIVATE STATIC FINAL INTEGER FILELOCK = NEW INTEGER(1);\u000a...\u000a  SYNCHRONIZED(FILELOCK) {\u000a     .. DO SOMETHING ..\u000a     }\u000a...\u000aIT WOULD BE MUCH BETTER, IN THIS CODE, TO REDECLARE FILELOCK AS \u000aPRIVATE STATIC FINAL OBJECT FILELOCK = NEW OBJECT();\u000aTHE EXISTING CODE MIGHT BE OK, BUT IT IS CONFUSING AND A FUTURE REFACTORING, \u000aSUCH AS THE &quot;REMOVE BOXING&quot; REFACTORING IN INTELLIJ, MIGHT REPLACE THIS WITH \u000aTHE USE OF AN INTERNED INTEGER OBJECT SHARED THROUGHOUT THE JVM, LEADING TO \u000aVERY CONFUSING BEHAVIOR AND POTENTIAL DEADLOCK.\u000a,CODE CHECKS FOR SPECIFIC VALUES RETURNED BY COMPARETOCHECK TO SEE IF RETURN VALUE OF {2.GIVENCLASS} IS EQUAL TO {3}CORRECTNESSTHIS CODE INVOKED A COMPARETO OR COMPARE METHOD, AND CHECKS TO SEE IF THE \u000aRETURN VALUE IS A SPECIFIC VALUE, SUCH AS 1 OR -1. WHEN INVOKING THESE \u000aMETHODS, YOU SHOULD ONLY CHECK THE SIGN OF THE RESULT, NOT FOR ANY SPECIFIC \u000aNON-ZERO VALUE. WHILE MANY OR MOST COMPARETO AND COMPARE METHODS ONLY RETURN \u000a-1, 0 OR 1, SOME OF THEM WILL RETURN OTHER VALUES.\u000a,NON-VIRTUAL METHOD CALL PASSES NULL FOR NONNULL PARAMETERNON-VIRTUAL METHOD CALL IN {1} PASSES NULL FOR NONNULL PARAMETER OF {2.GIVENCLASS}CORRECTNESSA POSSIBLY-NULL VALUE IS PASSED TO A NONNULL METHOD PARAMETER. EITHER THE \u000aPARAMETER IS ANNOTATED AS A PARAMETER THAT SHOULD ALWAYS BE NONNULL, OR \u000aANALYSIS HAS SHOWN THAT IT WILL ALWAYS BE DEREFERENCED.\u000a,PRIMITIVE VALUE IS BOXED AND THEN IMMEDIATELY UNBOXEDPRIMITIVE VALUE IS BOXED AND THEN IMMEDIATELY UNBOXED IN {1}PERFORMANCEA PRIMITIVE IS BOXED, AND THEN IMMEDIATELY UNBOXED. THIS PROBABLY IS DUE TO A \u000aMANUAL BOXING IN A PLACE WHERE AN UNBOXED VALUE IS REQUIRED, THUS FORCING THE \u000aCOMPILER TO IMMEDIATELY UNDO THE WORK OF THE BOXING.\u000a,CLASS OVERRIDES A METHOD IMPLEMENTED IN SUPER CLASS ADAPTER WRONGLYCLASS {0} OVERRIDES A METHOD {1} IMPLEMENTED IN SUPER CLASS ADAPTER WRONGLYCORRECTNESSTHIS METHOD OVERRIDES A METHOD FOUND IN A PARENT CLASS, WHERE THAT CLASS IS AN \u000aADAPTER THAT IMPLEMENTS A LISTENER DEFINED IN THE JAVA.AWT.EVENT OR \u000aJAVAX.SWING.EVENT PACKAGE. AS A RESULT, THIS METHOD WILL NOT GET CALLED WHEN \u000aTHE EVENT OCCURS.\u000a,USAGE OF GETRESOURCE MAY BE UNSAFE IF CLASS IS EXTENDEDUSAGE OF GETRESOURCE IN {1} MAY BE UNSAFE IF CLASS IS EXTENDEDBAD_PRACTICECALLING THIS.GETCLASS().GETRESOURCE(...) COULD GIVE RESULTS OTHER THAN \u000aEXPECTED IF THIS CLASS IS EXTENDED BY A CLASS IN ANOTHER PACKAGE.\u000a,VACUOUS CALL TO COLLECTIONSFOR ANY COLLECTION C, CALLING C.{2.NAME}(C) DOESN&apos;T MAKE SENSE CORRECTNESSTHIS CALL DOESN&apos;T MAKE SENSE. FOR ANY COLLECTION C, CALLING C.CONTAINSALL(C) \u000aSHOULD ALWAYS BE TRUE, AND C.RETAINALL(C) SHOULD HAVE NO EFFECT.\u000a,CLASS TOO BIG FOR ANALYSIS{0} IS TOO BIG FOR ANALYSISEXPERIMENTALTHIS CLASS IS BIGGER THAN CAN BE EFFECTIVELY HANDLED, AND WAS NOT FULLY \u000aANALYZED FOR ERRORS.\u000a,STATIC INITIALIZER CREATES INSTANCE BEFORE ALL STATIC FINAL FIELDS ASSIGNEDSTATIC INITIALIZER FOR {0} CREATES INSTANCE BEFORE ALL STATIC FINAL FIELDS ASSIGNEDBAD_PRACTICETHE CLASS&apos;S STATIC INITIALIZER CREATES AN INSTANCE OF THE CLASS BEFORE ALL OF \u000aTHE STATIC FINAL FIELDS ARE ASSIGNED.\u000a,UNCHECKED/UNCONFIRMED CAST OF RETURN VALUE FROM METHODUNCHECKED/UNCONFIRMED CAST FROM {2} TO {3} OF RETURN VALUE IN {1}STYLETHIS CODE PERFORMS AN UNCHECKED CAST OF THE RETURN VALUE OF A METHOD. THE CODE \u000aMIGHT BE CALLING THE METHOD IN SUCH A WAY THAT THE CAST IS GUARANTEED TO BE \u000aSAFE, BUT FINDBUGS IS UNABLE TO VERIFY THAT THE CAST IS SAFE. CHECK THAT YOUR \u000aPROGRAM LOGIC ENSURES THAT THIS CAST WILL NOT FAIL.\u000a,FIELD SHOULD BE BOTH FINAL AND PACKAGE PROTECTED{1} SHOULD BE BOTH FINAL AND PACKAGE PROTECTEDMALICIOUS_CODEA MUTABLE STATIC FIELD COULD BE CHANGED BY MALICIOUS CODE OR BY ACCIDENT FROM \u000aANOTHER PACKAGE. THE FIELD COULD BE MADE PACKAGE PROTECTED AND/OR MADE FINAL \u000aTO AVOID THIS VULNERABILITY.\u000a,FIELD NOT GUARDED AGAINST CONCURRENT ACCESS{1.GIVENCLASS} NOT GUARDED AGAINST CONCURRENT ACCESS; LOCKED {2}% OF TIMEMT_CORRECTNESSTHIS FIELD IS ANNOTATED WITH NET.JCIP.ANNOTATIONS.GUARDEDBY OR \u000aJAVAX.ANNOTATION.CONCURRENT.GUARDEDBY, BUT CAN BE ACCESSED IN A WAY THAT SEEMS \u000aTO VIOLATE THOSE ANNOTATIONS.\u000a,NON-TRANSIENT NON-SERIALIZABLE INSTANCE FIELD IN SERIALIZABLE CLASSCLASS {0} DEFINES NON-TRANSIENT NON-SERIALIZABLE INSTANCE FIELD {1.NAME}BAD_PRACTICETHIS SERIALIZABLE CLASS DEFINES A NON-PRIMITIVE INSTANCE FIELD WHICH IS \u000aNEITHER TRANSIENT, SERIALIZABLE, OR JAVA.LANG.OBJECT, AND DOES NOT APPEAR TO \u000aIMPLEMENT THE EXTERNALIZABLE INTERFACE OR THE READOBJECT() AND WRITEOBJECT() \u000aMETHODS.  OBJECTS OF THIS CLASS WILL NOT BE DESERIALIZED CORRECTLY IF A \u000aNON-SERIALIZABLE OBJECT IS STORED IN THIS FIELD.\u000a,RELATIVE PATH TRAVERSAL IN SERVLETRELATIVE PATH TRAVERSAL IN {1}SECURITYTHE SOFTWARE USES AN HTTP REQUEST PARAMETER TO CONSTRUCT A PATHNAME THAT \u000aSHOULD BE WITHIN A RESTRICTED DIRECTORY, BUT IT DOES NOT PROPERLY NEUTRALIZE \u000aSEQUENCES SUCH AS &quot;..&quot; THAT CAN RESOLVE TO A LOCATION THAT IS OUTSIDE OF THAT \u000aDIRECTORY. SEE HTTP://CWE.MITRE.ORG/DATA/DEFINITIONS/23.HTML FOR MORE \u000aINFORMATION. \u000aFINDBUGS LOOKS ONLY FOR THE MOST BLATANT, OBVIOUS CASES OF RELATIVE PATH \u000aTRAVERSAL. IF FINDBUGS FOUND ANY, YOU ALMOST CERTAINLY HAVE MORE \u000aVULNERABILITIES THAT FINDBUGS DOESN&apos;T REPORT. IF YOU ARE CONCERNED ABOUT \u000aRELATIVE PATH TRAVERSAL, YOU SHOULD SERIOUSLY CONSIDER USING A COMMERCIAL \u000aSTATIC ANALYSIS OR PEN-TESTING TOOL.\u000a,WAIT WITH TWO LOCKS HELDWAIT() WITH TWO LOCKS HELD IN {1}MT_CORRECTNESSWAITING ON A MONITOR WHILE TWO LOCKS ARE HELD MAY CAUSE DEADLOCK.   PERFORMING \u000aA WAIT ONLY RELEASES THE LOCK ON THE OBJECT BEING WAITED ON, NOT ANY OTHER \u000aLOCKS.   THIS NOT NECESSARILY A BUG, BUT IS WORTH EXAMINING CLOSELY.\u000a,SYNCHRONIZATION PERFORMED ON LOCKSYNCHRONIZATION PERFORMED ON {2} IN {1}MT_CORRECTNESSTHIS METHOD PERFORMS SYNCHRONIZATION AN OBJECT THAT IMPLEMENTS \u000aJAVA.UTIL.CONCURRENT.LOCKS.LOCK. SUCH AN OBJECT IS LOCKED/UNLOCKED USING ACQUIRE()/RELEASE() \u000aRATHER THAN USING THE SYNCHRONIZED (...) CONSTRUCT.\u000a,INVOKES RUN ON A THREAD (DID YOU MEAN TO START IT INSTEAD?){1} EXPLICITLY INVOKES RUN ON A THREAD (DID YOU MEAN TO START IT INSTEAD?)MT_CORRECTNESSTHIS METHOD EXPLICITLY INVOKES RUN() ON AN OBJECT.  IN GENERAL, CLASSES \u000aIMPLEMENT THE RUNNABLE INTERFACE BECAUSE THEY ARE GOING TO HAVE THEIR RUN() \u000aMETHOD INVOKED IN A NEW THREAD, IN WHICH CASE THREAD.START() IS THE RIGHT \u000aMETHOD TO CALL.\u000a,METHOD INVOKED THAT SHOULD BE ONLY BE INVOKED INSIDE A DOPRIVILEGED BLOCKINVOCATION OF {2}, WHICH SHOULD BE INVOKED FROM WITHIN A DOPRIVILEGED BLOCK, IN {1}MALICIOUS_CODETHIS CODE INVOKES A METHOD THAT REQUIRES A SECURITY PERMISSION CHECK. IF THIS \u000aCODE WILL BE GRANTED SECURITY PERMISSIONS, BUT MIGHT BE INVOKED BY CODE THAT \u000aDOES NOT HAVE SECURITY PERMISSIONS, THEN THE INVOCATION NEEDS TO OCCUR INSIDE \u000aA DOPRIVILEGED BLOCK.\u000a,BIGDECIMAL CONSTRUCTED FROM DOUBLE THAT ISN&apos;T REPRESENTED PRECISELYBIGDECIMAL CONSTRUCTED FROM {4} IN {1}CORRECTNESSTHIS CODE CREATES A BIGDECIMAL FROM A DOUBLE VALUE THAT DOESN&apos;T TRANSLATE WELL \u000aTO A DECIMAL NUMBER. FOR EXAMPLE, ONE MIGHT ASSUME THAT WRITING NEW \u000aBIGDECIMAL(0.1) IN JAVA CREATES A BIGDECIMAL WHICH IS EXACTLY EQUAL TO 0.1 (AN \u000aUNSCALED VALUE OF 1, WITH A SCALE OF 1), BUT IT IS ACTUALLY EQUAL TO \u000a0.1000000000000000055511151231257827021181583404541015625. YOU PROBABLY WANT \u000aTO USE THE BIGDECIMAL.VALUEOF(DOUBLE D) METHOD, WHICH USES THE STRING \u000aREPRESENTATION OF THE DOUBLE TO CREATE THE BIGDECIMAL (E.G., \u000aBIGDECIMAL.VALUEOF(0.1) GIVES 0.1).\u000a,PRIMITIVE VALUE IS BOXED THEN UNBOXED TO PERFORM PRIMITIVE COERCIONPRIMITIVE VALUE IS BOXED THEN UNBOXED TO PERFORM PRIMITIVE COERCION IN {1}PERFORMANCEA PRIMITIVE BOXED VALUE CONSTRUCTED AND THEN IMMEDIATELY CONVERTED INTO A \u000aDIFFERENT PRIMITIVE TYPE (E.G., NEW DOUBLE(D).INTVALUE()). JUST PERFORM DIRECT \u000aPRIMITIVE COERCION (E.G., (INT) D).\u000a,REPEATED CONDITIONAL TESTSREPEATED CONDITIONAL TEST IN {1}CORRECTNESSTHE CODE CONTAINS A CONDITIONAL TEST IS PERFORMED TWICE, ONE RIGHT AFTER THE \u000aOTHER (E.G., X == 0 || X == 0). PERHAPS THE SECOND OCCURRENCE IS INTENDED TO \u000aBE SOMETHING ELSE (E.G., X == 0 || Y == 0).\u000a,INTEGER REMAINDER MODULO 1INTEGER REMAINDER MODULO 1 COMPUTED IN {1} STYLEANY EXPRESSION (EXP % 1) IS GUARANTEED TO ALWAYS RETURN ZERO. DID YOU MEAN \u000a(EXP &amp; 1) OR (EXP % 2) INSTEAD?\u000a,CHECK FOR SIGN OF BITWISE OPERATIONCHECK FOR SIGN OF BITWISE OPERATION IN {1}CORRECTNESSTHIS METHOD COMPARES AN EXPRESSION SUCH AS \u000a((EVENT.DETAIL &amp; SWT.SELECTED) > 0)\u000a. USING BIT ARITHMETIC AND THEN COMPARING WITH THE GREATER THAN OPERATOR CAN \u000aLEAD TO UNEXPECTED RESULTS (OF COURSE DEPENDING ON THE VALUE OF SWT.SELECTED). \u000aIF SWT.SELECTED IS A NEGATIVE NUMBER, THIS IS A CANDIDATE FOR A BUG. EVEN WHEN \u000aSWT.SELECTED IS NOT NEGATIVE, IT SEEMS GOOD PRACTICE TO USE &apos;!= 0&apos; INSTEAD OF \u000a&apos;> 0&apos;. \u000aBORIS BOKOWSKI\u000a,METHOD INVOKES SYSTEM.EXIT(...){1} INVOKES SYSTEM.EXIT(...), WHICH SHUTS DOWN THE ENTIRE VIRTUAL MACHINEBAD_PRACTICEINVOKING SYSTEM.EXIT SHUTS DOWN THE ENTIRE JAVA VIRTUAL MACHINE. THIS SHOULD \u000aONLY BEEN DONE WHEN IT IS APPROPRIATE. SUCH CALLS MAKE IT HARD OR IMPOSSIBLE \u000aFOR YOUR CODE TO BE INVOKED BY OTHER CODE. CONSIDER THROWING A \u000aRUNTIMEEXCEPTION INSTEAD.\u000a,CLASS DEFINES CLONE() BUT DOESN&apos;T IMPLEMENT CLONEABLE{0} DEFINES CLONE() BUT DOESN&apos;T IMPLEMENT CLONEABLEBAD_PRACTICETHIS CLASS DEFINES A CLONE() METHOD BUT THE CLASS DOESN&apos;T IMPLEMENT CLONEABLE. \u000aTHERE ARE SOME SITUATIONS IN WHICH THIS IS OK (E.G., YOU WANT TO CONTROL HOW \u000aSUBCLASSES CAN CLONE THEMSELVES), BUT JUST MAKE SURE THAT THIS IS WHAT YOU \u000aINTENDED.\u000a,CLASS DEFINES HASHCODE() AND USES OBJECT.EQUALS(){0} DEFINES HASHCODE AND USES OBJECT.EQUALS()BAD_PRACTICETHIS CLASS DEFINES A HASHCODE() METHOD BUT INHERITS ITS EQUALS() METHOD FROM JAVA.LANG.OBJECT \u000a(WHICH DEFINES EQUALITY BY COMPARING OBJECT REFERENCES).  ALTHOUGH THIS WILL \u000aPROBABLY SATISFY THE CONTRACT THAT EQUAL OBJECTS MUST HAVE EQUAL HASHCODES, IT \u000aIS PROBABLY NOT WHAT WAS INTENDED BY OVERRIDING THE HASHCODE() METHOD.  \u000a(OVERRIDING HASHCODE() IMPLIES THAT THE OBJECT&apos;S IDENTITY IS BASED ON CRITERIA \u000aMORE COMPLICATED THAN SIMPLE REFERENCE EQUALITY.) \u000aIF YOU DON&apos;T THINK INSTANCES OF THIS CLASS WILL EVER BE INSERTED INTO A \u000aHASHMAP/HASHTABLE, THE RECOMMENDED HASHCODE IMPLEMENTATION TO USE IS: \u000aPUBLIC INT HASHCODE() {\u000a  ASSERT FALSE : &quot;HASHCODE NOT DESIGNED&quot;;\u000a  RETURN 42; // ANY ARBITRARY CONSTANT WILL DO\u000a  },CALL TO STATIC CALENDARCALL TO METHOD OF STATIC JAVA.UTIL.CALENDAR IN {1}MT_CORRECTNESSEVEN THOUGH THE JAVADOC DOES NOT CONTAIN A HINT ABOUT IT, CALENDARS ARE \u000aINHERENTLY UNSAFE FOR MULTIHTREADED USE. THE DETECTOR HAS FOUND A CALL TO AN \u000aINSTANCE OF CALENDAR THAT HAS BEEN OBTAINED VIA A STATIC FIELD. THIS LOOKS \u000aSUSPICOUS. \u000aFOR MORE INFORMATION ON THIS SEE SUN BUG #6231579 AND SUN BUG #6178997.\u000a,TESTCASE IMPLEMENTS A NON-STATIC SUITE METHOD TESTCASE {0} IMPLEMENTS A NON-STATIC SUITE METHODCORRECTNESSCLASS IS A JUNIT TESTCASE AND IMPLEMENTS THE SUITE() METHOD. THE SUITE METHOD \u000aSHOULD BE DECLARED AS BEING STATIC, BUT ISN&apos;T.\u000a,A KNOWN NULL VALUE IS CHECKED TO SEE IF IT IS AN INSTANCE OF A TYPEA KNOWN NULL VALUE IS CHECKED TO SEE IF IT IS AN INSTANCE OF {2} IN {1}CORRECTNESSTHIS INSTANCEOF TEST WILL ALWAYS RETURN FALSE, SINCE THE VALUE BEING CHECKED \u000aIS GUARANTEED TO BE NULL. ALTHOUGH THIS IS SAFE, MAKE SURE IT ISN&apos;T AN \u000aINDICATION OF SOME MISUNDERSTANDING OR SOME OTHER LOGIC ERROR.\u000a,CERTAIN SWING METHODS NEEDS TO BE INVOKED IN SWING THREADCALL TO SWING METHOD IN {1} NEEDS TO BE PERFORMED IN SWING EVENT THREADBAD_PRACTICE(FROM JDC TECH TIP): THE SWING METHODS SHOW(), SETVISIBLE(), AND PACK() WILL \u000aCREATE THE ASSOCIATED PEER FOR THE FRAME. WITH THE CREATION OF THE PEER, THE \u000aSYSTEM CREATES THE EVENT DISPATCH THREAD. THIS MAKES THINGS PROBLEMATIC \u000aBECAUSE THE EVENT DISPATCH THREAD COULD BE NOTIFYING LISTENERS WHILE PACK AND \u000aVALIDATE ARE STILL PROCESSING. THIS SITUATION COULD RESULT IN TWO THREADS \u000aGOING THROUGH THE SWING COMPONENT-BASED GUI -- IT&apos;S A SERIOUS FLAW THAT COULD \u000aRESULT IN DEADLOCKS OR OTHER RELATED THREADING ISSUES. A PACK CALL CAUSES \u000aCOMPONENTS TO BE REALIZED. AS THEY ARE BEING REALIZED (THAT IS, NOT \u000aNECESSARILY VISIBLE), THEY COULD TRIGGER LISTENER NOTIFICATION ON THE EVENT \u000aDISPATCH THREAD.\u000a,PRIMITIVE ARRAY PASSED TO FUNCTION EXPECTING A VARIABLE NUMBER OF OBJECT ARGUMENTS{2} PASSED TO VARARGS METHOD {3} IN {1}CORRECTNESSTHIS CODE PASSES A PRIMITIVE ARRAY TO A FUNCTION THAT TAKES A VARIABLE NUMBER \u000aOF OBJECT ARGUMENTS. THIS CREATES AN ARRAY OF LENGTH ONE TO HOLD THE PRIMITIVE \u000aARRAY AND PASSES IT TO THE FUNCTION.\u000a,MAPS AND SETS OF URLS CAN BE PERFORMANCE HOGS{1} IS OR USES A MAP OR SET OF URLS, WHICH CAN BE A PERFORMANCE HOGPERFORMANCETHIS METHOD OR FIELD IS OR USES A MAP OR SET OF URLS. SINCE BOTH THE EQUALS \u000aAND HASHCODE METHOD OF URL PERFORM DOMAIN NAME RESOLUTION, THIS CAN RESULT IN \u000aA BIG PERFORMANCE HIT. SEE HTTP://MICHAELSCHARF.BLOGSPOT.COM/2006/11/JAVANETURLEQUALS-AND-HASHCODE-MAKE.HTML \u000aFOR MORE INFORMATION. CONSIDER USING JAVA.NET.URI INSTEAD.\u000a,SELF ASSIGNMENT OF LOCAL RATHER THAN ASSIGNMENT TO FIELDSELF ASSIGNMENT OF {2} RATHER THAN ASSIGNED TO FIELD IN {1}CORRECTNESSTHIS METHOD CONTAINS A SELF ASSIGNMENT OF A LOCAL VARIABLE, AND THERE IS A \u000aFIELD WITH AN IDENTICAL NAME. ASSIGNMENT APPEARS TO HAVE BEEN ; E.G. \u000a  INT FOO;\u000a  PUBLIC VOID SETFOO(INT FOO) {\u000a    FOO = FOO;\u000a  }\u000aTHE ASSIGNMENT IS USELESS. DID YOU MEAN TO ASSIGN TO THE FIELD INSTEAD?\u000a,COMPARATOR DOESN&apos;T IMPLEMENT SERIALIZABLE{0} IMPLEMENTS COMPARATOR BUT NOT SERIALIZABLEBAD_PRACTICETHIS CLASS IMPLEMENTS THE COMPARATOR INTERFACE. YOU SHOULD CONSIDER WHETHER OR \u000aNOT IT SHOULD ALSO IMPLEMENT THE SERIALIZABLE INTERFACE. IF A COMPARATOR IS \u000aUSED TO CONSTRUCT AN ORDERED COLLECTION SUCH AS A TREEMAP, THEN THE TREEMAP \u000aWILL BE SERIALIZABLE ONLY IF THE COMPARATOR IS ALSO SERIALIZABLE. AS MOST \u000aCOMPARATORS HAVE LITTLE OR NO STATE, MAKING THEM SERIALIZABLE IS GENERALLY \u000aEASY AND GOOD DEFENSIVE PROGRAMMING.\u000a,USELESS CONTROL FLOWUSELESS CONTROL FLOW IN {1}STYLETHIS METHOD CONTAINS A USELESS CONTROL FLOW STATEMENT, WHERE CONTROL FLOW \u000aCONTINUES ONTO THE SAME PLACE REGARDLESS OF WHETHER OR NOT THE BRANCH IS \u000aTAKEN. FOR EXAMPLE, THIS IS CAUSED BY HAVING AN EMPTY STATEMENT BLOCK FOR AN IF \u000aSTATEMENT: \u000a    IF (ARGV.LENGTH == 0) {\u000a    // TODO: HANDLE THIS CASE\u000a    },NAKED NOTIFYNAKED NOTIFY IN {1}MT_CORRECTNESSA CALL TO NOTIFY() OR NOTIFYALL() WAS MADE WITHOUT ANY (APPARENT) ACCOMPANYING \u000aMODIFICATION TO MUTABLE OBJECT STATE.  IN GENERAL, CALLING A NOTIFY METHOD ON \u000aA MONITOR IS DONE BECAUSE SOME CONDITION ANOTHER THREAD IS WAITING FOR HAS \u000aBECOME TRUE.  HOWEVER, FOR THE CONDITION TO BE MEANINGFUL, IT MUST INVOLVE A \u000aHEAP OBJECT THAT IS VISIBLE TO BOTH THREADS. \u000aTHIS BUG DOES NOT NECESSARILY INDICATE AN ERROR, SINCE THE CHANGE TO MUTABLE \u000aOBJECT STATE MAY HAVE TAKEN PLACE IN A METHOD WHICH THEN CALLED THE METHOD \u000aCONTAINING THE NOTIFICATION.\u000a,CLONE METHOD MAY RETURN NULL{1} MAY RETURN NULLBAD_PRACTICETHIS CLONE METHOD SEEMS TO RETURN NULL IN SOME CIRCUMSTANCES, BUT CLONE IS \u000aNEVER ALLOWED TO RETURN A NULL VALUE. IF YOU ARE CONVINCED THIS PATH IS \u000aUNREACHABLE, THROW AN ASSERTIONERROR INSTEAD.\u000a,SERIALVERSIONUID ISN&apos;T LONG{1} ISN&apos;T LONGBAD_PRACTICETHIS CLASS DEFINES A SERIALVERSIONUID FIELD THAT IS NOT LONG.  THE FIELD \u000aSHOULD BE MADE LONG IF IT IS INTENDED TO SPECIFY THE VERSION UID FOR PURPOSES \u000aOF SERIALIZATION.\u000a,EQUALS() USED TO COMPARE ARRAY AND NONARRAYCALLING {3.SIMPLECLASS}.EQUALS({2.SIMPLECLASS}) IN {1}CORRECTNESSTHIS METHOD INVOKES THE .EQUALS(OBJECT O) TO COMPARE AN ARRAY AND A REFERENCE \u000aTHAT DOESN&apos;T SEEM TO BE AN ARRAY. IF THINGS BEING COMPARED ARE OF DIFFERENT \u000aTYPES, THEY ARE GUARANTEED TO BE UNEQUAL AND THE COMPARISON IS ALMOST \u000aCERTAINLY AN ERROR. EVEN IF THEY ARE BOTH ARRAYS, THE EQUALS METHOD ON ARRAYS \u000aONLY DETERMINES OF THE TWO ARRAYS ARE THE SAME OBJECT. TO COMPARE THE CONTENTS \u000aOF THE ARRAYS, USE JAVA.UTIL.ARRAYS.EQUALS(OBJECT[], OBJECT[]).\u000a,METHOD ATTEMPTS TO ACCESS A RESULT SET FIELD WITH INDEX 0{1} ATTEMPTS TO ACCESS A RESULT SET FIELD WITH INDEX 0CORRECTNESSA CALL TO GETXXX OR UPDATEXXX METHODS OF A RESULT SET WAS MADE WHERE THE FIELD \u000aINDEX IS 0. AS RESULTSET FIELDS START AT INDEX 1, THIS IS ALWAYS A MISTAKE.\u000a,CLASS INHERITS EQUALS() AND USES OBJECT.HASHCODE(){0} INHERITS EQUALS AND USES OBJECT.HASHCODE()BAD_PRACTICETHIS CLASS INHERITS EQUALS(OBJECT) FROM AN ABSTRACT SUPERCLASS, AND HASHCODE() \u000aFROM JAVA.LANG.OBJECT (WHICH RETURNS THE IDENTITY HASH CODE, AN ARBITRARY \u000aVALUE ASSIGNED TO THE OBJECT BY THE VM).  THEREFORE, THE CLASS IS VERY LIKELY \u000aTO VIOLATE THE INVARIANT THAT EQUAL OBJECTS MUST HAVE EQUAL HASHCODES. \u000aIF YOU DON&apos;T WANT TO DEFINE A HASHCODE METHOD, AND/OR DON&apos;T BELIEVE THE OBJECT \u000aWILL EVER BE PUT INTO A HASHMAP/HASHTABLE, DEFINE THE HASHCODE() METHOD TO \u000aTHROW UNSUPPORTEDOPERATIONEXCEPTION.\u000a,ABSTRACT CLASS DEFINES COVARIANT COMPARETO() METHODABSTRACT {0} DEFINES COMPARETO({0.GIVENCLASS}) METHODBAD_PRACTICETHIS CLASS DEFINES A COVARIANT VERSION OF COMPARETO().  TO CORRECTLY OVERRIDE \u000aTHE COMPARETO() METHOD IN THE COMPARABLE INTERFACE, THE PARAMETER OF COMPARETO() \u000aMUST HAVE TYPE JAVA.LANG.OBJECT.\u000a,INVOCATION OF EQUALS() ON AN ARRAY, WHICH IS EQUIVALENT TO ==USING .EQUALS TO COMPARE TWO {2.SIMPLECLASS}&apos;S, (EQUIVALENT TO ==) IN {1}CORRECTNESSTHIS METHOD INVOKES THE .EQUALS(OBJECT O) METHOD ON AN ARRAY. SINCE ARRAYS DO \u000aNOT OVERRIDE THE EQUALS METHOD OF OBJECT, CALLING EQUALS ON AN ARRAY IS THE \u000aSAME AS COMPARING THEIR ADDRESSES. TO COMPARE THE CONTENTS OF THE ARRAYS, USE JAVA.UTIL.ARRAYS.EQUALS(OBJECT[], \u000aOBJECT[]). TO COMPARE THE ADDRESSES OF THE ARRAYS, IT WOULD BE LESS CONFUSING \u000aTO EXPLICITLY CHECK POINTER EQUALITY USING ==.\u000a,CLASS DEFINES EQUALS() BUT NOT HASHCODE(){0} DEFINES EQUALS BUT NOT HASHCODEBAD_PRACTICETHIS CLASS OVERRIDES EQUALS(OBJECT), BUT DOES NOT OVERRIDE HASHCODE().  \u000aTHEREFORE, THE CLASS MAY VIOLATE THE INVARIANT THAT EQUAL OBJECTS MUST HAVE \u000aEQUAL HASHCODES.\u000a,FINALIZER DOES NOT CALL SUPERCLASS FINALIZER{1} MISSING CALL TO SUPER.FINALIZE(), SO {2}.FINALIZE() DOESN&apos;T GET CALLEDBAD_PRACTICETHIS FINALIZE() METHOD DOES NOT MAKE A CALL TO ITS SUPERCLASS&apos;S FINALIZE() \u000aMETHOD.  SO, ANY FINALIZER ACTIONS DEFINED FOR THE SUPERCLASS WILL NOT BE \u000aPERFORMED.  ADD A CALL TO SUPER.FINALIZE().\u000a,CALL TO EQUALS() COMPARING UNRELATED CLASS AND INTERFACECALL TO {3.SIMPLECLASS}.EQUALS({2.SIMPLECLASS}) IN {1}CORRECTNESSTHIS METHOD CALLS EQUALS(OBJECT) ON TWO REFERENCES, ONE OF WHICH IS A CLASS \u000aAND THE OTHER AN INTERFACE, WHERE NEITHER THE CLASS NOR ANY OF ITS \u000aNON-ABSTRACT SUBCLASSES IMPLEMENT THE INTERFACE. THEREFORE, THE OBJECTS BEING \u000aCOMPARED ARE UNLIKELY TO BE MEMBERS OF THE SAME CLASS AT RUNTIME (UNLESS SOME \u000aAPPLICATION CLASSES WERE NOT ANALYZED, OR DYNAMIC CLASS LOADING CAN OCCUR AT \u000aRUNTIME). ACCORDING TO THE CONTRACT OF EQUALS(), OBJECTS OF DIFFERENT CLASSES \u000aSHOULD ALWAYS COMPARE AS UNEQUAL; THEREFORE, ACCORDING TO THE CONTRACT DEFINED \u000aBY JAVA.LANG.OBJECT.EQUALS(OBJECT), THE RESULT OF THIS COMPARISON WILL ALWAYS \u000aBE FALSE AT RUNTIME.\u000a,A THREAD WAS CREATED USING THE DEFAULT EMPTY RUN METHOD{1} CREATES A THREAD USING THE DEFAULT EMPTY RUN METHODMT_CORRECTNESSTHIS METHOD CREATES A THREAD WITHOUT SPECIFYING A RUN METHOD EITHER BY \u000aDERIVING FROM THE THREAD CLASS, OR BY PASSING A RUNNABLE OBJECT. THIS THREAD, \u000aTHEN, DOES NOTHING BUT WASTE TIME.\u000a,OVERWRITTEN INCREMENTOVERWRITTEN INCREMENT IN {1}CORRECTNESSTHE CODE PERFORMS AN INCREMENT OPERATION (E.G., I++) AND THEN IMMEDIATELY \u000aOVERWRITES IT. FOR EXAMPLE, I = I++ IMMEDIATELY OVERWRITES THE INCREMENTED \u000aVALUE WITH THE ORIGINAL VALUE.\u000a,EQUALS METHOD ALWAYS RETURNS TRUE{1} ALWAYS RETURNS TRUECORRECTNESSTHIS CLASS DEFINES AN EQUALS METHOD THAT ALWAYS RETURNS TRUE. THIS IS \u000aIMAGINATIVE, BUT NOT VERY SMART. PLUS, IT MEANS THAT THE EQUALS METHOD IS NOT \u000aSYMMETRIC.\u000a,NONNULL FIELD IS NOT INITIALIZEDNONNULL FIELD {2.NAME} IS NOT INITIALIZED BY {1}CORRECTNESSTHE FIELD IS MARKED AS NONNULL, BUT ISN&apos;T WRITTEN TO BY THE CONSTRUCTOR. THE \u000aFIELD MIGHT BE INITIALIZED ELSEWHERE DURING CONSTRUCTOR, OR MIGHT ALWAYS BE \u000aINITIALIZED BEFORE USE.\u000a,A KNOWN NULL VALUE IS CHECKED TO SEE IF IT IS AN INSTANCE OF A TYPEA KNOWN NULL VALUE IS CHECKED TO SEE IF IT IS AN INSTANCE OF {2} IN {1}CORRECTNESSTHIS INSTANCEOF TEST WILL ALWAYS RETURN FALSE, SINCE THE VALUE BEING CHECKED \u000aIS GUARANTEED TO BE NULL. ALTHOUGH THIS IS SAFE, MAKE SURE IT ISN&apos;T AN \u000aINDICATION OF SOME MISUNDERSTANDING OR SOME OTHER LOGIC ERROR.\u000a,METHOD MAY FAIL TO CLOSE STREAM ON EXCEPTION{1} MAY FAIL TO CLOSE STREAM ON EXCEPTIONBAD_PRACTICETHE METHOD CREATES AN IO STREAM OBJECT, DOES NOT ASSIGN IT TO ANY FIELDS, PASS \u000aIT TO OTHER METHODS, OR RETURN IT, AND DOES NOT APPEAR TO CLOSE IT ON ALL \u000aPOSSIBLE EXCEPTION PATHS OUT OF THE METHOD.  THIS MAY RESULT IN A FILE \u000aDESCRIPTOR LEAK.  IT IS GENERALLY A GOOD IDEA TO USE A FINALLY BLOCK TO ENSURE \u000aTHAT STREAMS ARE CLOSED.\u000a,EQUALS(...) USED TO COMPARE INCOMPATIBLE ARRAYSUSING EQUALS TO COMPARE A {2.SIMPLECLASS} AND A {3.SIMPLECLASS} IN {1}CORRECTNESSTHIS METHOD INVOKES THE .EQUALS(OBJECT O) TO COMPARE TWO ARRAYS, BUT THE \u000aARRAYS OF OF INCOMPATIBLE TYPES (E.G., STRING[] AND STRINGBUFFER[], OR \u000aSTRING[] AND INT[]). THEY WILL NEVER BE EQUAL. IN ADDITION, WHEN EQUALS(...) \u000aIS USED TO COMPARE ARRAYS IT ONLY CHECKS TO SEE IF THEY ARE THE SAME ARRAY, \u000aAND IGNORES THE CONTENTS OF THE ARRAYS.\u000a,VALUE REQUIRED TO NOT HAVE TYPE QUALIFIER, BUT MARKED AS UNKNOWNVALUE IS REQUIRED NEVER BE {2.SIMPLENAME}, BUT IS EXPLICITLY ANNOTATED AS UNKNOWN WITH REGARDS TO {2.SIMPLENAME}STYLEA VALUE IS USED IN A WAY THAT REQUIRES IT TO BE NEVER BE A VALUE DENOTED BY A \u000aTYPE QUALIFIER, BUT THERE IS AN EXPLICIT ANNOTATION STATING THAT IT IS NOT \u000aKNOWN WHERE THE VALUE IS PROHIBITED FROM HAVING THAT TYPE QUALIFIER. EITHER \u000aTHE USAGE OR THE ANNOTATION IS INCORRECT.\u000a,POTENTIALLY AMBIGUOUS INVOCATION OF EITHER AN INHERITED OR OUTER METHODPOTENTIALLY AMBIGUOUS INVOCATION OF EITHER AN OUTER OR INHERITED METHOD {2} IN {1}STYLEAN INNER CLASS IS INVOKING A METHOD THAT COULD BE RESOLVED TO EITHER A \u000aINHERITED METHOD OR A METHOD DEFINED IN AN OUTER CLASS. FOR EXAMPLE, YOU \u000aINVOKE FOO(17), WHICH IS DEFINED IN BOTH A SUPERCLASS AND IN AN OUTER METHOD. \u000aBY THE JAVA SEMANTICS, IT WILL BE RESOLVED TO INVOKE THE INHERITED METHOD, BUT \u000aTHIS MAY NOT BE WANT YOU INTEND. \u000aIF YOU REALLY INTEND TO INVOKE THE INHERITED METHOD, INVOKE IT BY INVOKING THE \u000aMETHOD ON SUPER (E.G., INVOKE SUPER.FOO(17)), AND THUS IT WILL BE CLEAR TO \u000aOTHER READERS OF YOUR CODE AND TO FINDBUGS THAT YOU WANT TO INVOKE THE \u000aINHERITED METHOD, NOT THE METHOD IN THE OUTER CLASS. \u000aIF YOU CALL THIS.FOO(17), THEN THE INHERITED METHOD WILL BE INVOKED. HOWEVER, \u000aSINCE FINDBUGS ONLY LOOKS AT CLASSFILES, IT CAN&apos;T TELL THE DIFFERENCE BETWEEN \u000aAN INVOCATION OF THIS.FOO(17) AND FOO(17), IT WILL STILL COMPLAIN ABOUT A \u000aPOTENTIAL AMBIGUOUS INVOCATION.\u000a,NON-SERIALIZABLE VALUE STORED INTO INSTANCE FIELD OF A SERIALIZABLE CLASS{2} STORED INTO NON-TRANSIENT FIELD {1.GIVENCLASS}BAD_PRACTICEA NON-SERIALIZABLE VALUE IS STORED INTO A NON-TRANSIENT FIELD OF A \u000aSERIALIZABLE CLASS.\u000a,INTEGRAL DIVISION RESULT CAST TO DOUBLE OR FLOATINTEGRAL DIVISION RESULT CAST TO DOUBLE OR FLOAT IN {1}STYLETHIS CODE CASTS THE RESULT OF AN INTEGRAL DIVISION (E.G., INT OR LONG \u000aDIVISION) OPERATION TO DOUBLE OR FLOAT. DOING DIVISION ON INTEGERS TRUNCATES \u000aTHE RESULT TO THE INTEGER VALUE CLOSEST TO ZERO. THE FACT THAT THE RESULT WAS \u000aCAST TO DOUBLE SUGGESTS THAT THIS PRECISION SHOULD HAVE BEEN RETAINED. WHAT \u000aWAS PROBABLY MEANT WAS TO CAST ONE OR BOTH OF THE OPERANDS TO DOUBLE BEFORE \u000aPERFORMING THE DIVISION. HERE IS AN EXAMPLE: \u000aINT X = 2;\u000aINT Y = 5;\u000a// WRONG: YIELDS RESULT 0.0\u000aDOUBLE VALUE1 =  X / Y;\u000a\u000a// RIGHT: YIELDS RESULT 0.4\u000aDOUBLE VALUE2 =  X / (DOUBLE) Y;,CLASS NAMES SHOULDN&apos;T SHADOW SIMPLE NAME OF IMPLEMENTED INTERFACETHE CLASS NAME {0} SHADOWS THE SIMPLE NAME OF IMPLEMENTED INTERFACE {1}BAD_PRACTICETHIS CLASS/INTERFACE HAS A SIMPLE NAME THAT IS IDENTICAL TO THAT OF AN \u000aIMPLEMENTED/EXTENDED INTERFACE, EXCEPT THAT THE INTERFACE IS IN A DIFFERENT \u000aPACKAGE (E.G., ALPHA.FOO EXTENDS BETA.FOO). THIS CAN BE EXCEPTIONALLY \u000aCONFUSING, CREATE LOTS OF SITUATIONS IN WHICH YOU HAVE TO LOOK AT IMPORT \u000aSTATEMENTS TO RESOLVE REFERENCES AND CREATES MANY OPPORTUNITIES TO ACCIDENTLY \u000aDEFINE METHODS THAT DO NOT OVERRIDE METHODS IN THEIR SUPERCLASSES.\u000a,EQUALS METHOD FAILS FOR SUBTYPES{1} FAILS FOR SUBTYPESBAD_PRACTICETHIS CLASS HAS AN EQUALS METHOD THAT WILL BE BROKEN IF IT IS INHERITED BY \u000aSUBCLASSES. IT COMPARES A CLASS LITERAL WITH THE CLASS OF THE ARGUMENT (E.G., \u000aIN CLASS FOO IT MIGHT CHECK IF FOO.CLASS == O.GETCLASS()). IT IS BETTER TO \u000aCHECK IF THIS.GETCLASS() == O.GETCLASS().\u000a,METHOD MAY RETURN NULL, BUT IS DECLARED @NONNULL{1} MAY RETURN NULL, BUT IS DECLARED @NONNULLCORRECTNESSTHIS METHOD MAY RETURN A NULL VALUE, BUT THE METHOD (OR A SUPERCLASS METHOD \u000aWHICH IT OVERRIDES) IS DECLARED TO RETURN @NONNULL.\u000a,TOSTRING METHOD MAY RETURN NULL{1} MAY RETURN NULLBAD_PRACTICETHIS TOSTRING METHOD SEEMS TO RETURN NULL IN SOME CIRCUMSTANCES. A LIBERAL \u000aREADING OF THE SPEC COULD BE INTERPRETED AS ALLOWING THIS, BUT IT IS PROBABLY \u000aA BAD IDEA AND COULD CAUSE OTHER CODE TO BREAK. RETURN THE EMPTY STRING OR \u000aSOME OTHER APPROPRIATE STRING RATHER THAN NULL.\u000a,METHOD ALLOCATES A BOXED PRIMITIVE JUST TO CALL TOSTRINGPRIMITIVE BOXED JUST TO CALL TOSTRING IN {1}PERFORMANCEA BOXED PRIMITIVE IS ALLOCATED JUST TO CALL TOSTRING(). IT IS MORE EFFECTIVE \u000aTO JUST USE THE STATIC FORM OF TOSTRING WHICH TAKES THE PRIMITIVE VALUE. SO, \u000aREPLACE... WITH THIS... NEW INTEGER(1).TOSTRING() INTEGER.TOSTRING(1) NEW \u000aLONG(1).TOSTRING() LONG.TOSTRING(1) NEW FLOAT(1.0).TOSTRING() FLOAT.TOSTRING(1.0) \u000aNEW DOUBLE(1.0).TOSTRING() DOUBLE.TOSTRING(1.0) NEW BYTE(1).TOSTRING() BYTE.TOSTRING(1) \u000aNEW SHORT(1).TOSTRING() SHORT.TOSTRING(1) NEW BOOLEAN(TRUE).TOSTRING() BOOLEAN.TOSTRING(TRUE),COULD BE REFACTORED INTO A STATIC INNER CLASSTHE CLASS {0} COULD BE REFACTORED INTO A _STATIC_ INNER CLASSPERFORMANCETHIS CLASS IS AN INNER CLASS, BUT DOES NOT USE ITS EMBEDDED REFERENCE TO THE \u000aOBJECT WHICH CREATED IT EXCEPT DURING CONSTRUCTION OF THE INNER OBJECT.  THIS \u000aREFERENCE MAKES THE INSTANCES OF THE CLASS LARGER, AND MAY KEEP THE REFERENCE \u000aTO THE CREATOR OBJECT ALIVE LONGER THAN NECESSARY.  IF POSSIBLE, THE CLASS \u000aSHOULD BE MADE INTO A STATIC INNER CLASS. SINCE THE REFERENCE TO THE OUTER \u000aOBJECT IS REQUIRED DURING CONSTRUCTION OF THE INNER INSTANCE, THE INNER CLASS \u000aWILL NEED TO BE REFACTORED SO AS TO PASS A REFERENCE TO THE OUTER INSTANCE TO \u000aTHE CONSTRUCTOR FOR THE INNER CLASS.\u000a,CHECK TO SEE IF ((...) &amp; 0) == 0CHECK TO SEE IF ((...) &amp; 0) == 0 IN {1}CORRECTNESSTHIS METHOD COMPARES AN EXPRESSION OF THE FORM (E &amp; 0) TO 0, WHICH WILL ALWAYS \u000aCOMPARE EQUAL. THIS MAY INDICATE A LOGIC ERROR OR TYPO.\u000a,SUSPICIOUS REFERENCE COMPARISONSUSPICIOUS COMPARISON OF {2} REFERENCES IN {1}CORRECTNESSTHIS METHOD COMPARES TWO REFERENCE VALUES USING THE == OR != OPERATOR, WHERE \u000aTHE CORRECT WAY TO COMPARE INSTANCES OF THIS TYPE IS GENERALLY WITH THE \u000aEQUALS() METHOD. IT IS POSSIBLE TO CREATE DISTINCT INSTANCES THAT ARE EQUAL \u000aBUT DO NOT COMPARE AS == SINCE THEY ARE DIFFERENT OBJECTS. EXAMPLES OF CLASSES \u000aWHICH SHOULD GENERALLY NOT BE COMPARED BY REFERENCE ARE JAVA.LANG.INTEGER, \u000aJAVA.LANG.FLOAT, ETC.\u000a,METHOD INVOKES TOSTRING() METHOD ON A STRING{1} INVOKES TOSTRING() METHOD ON A STRINGPERFORMANCECALLING STRING.TOSTRING() IS JUST A REDUNDANT OPERATION. JUST USE THE STRING.\u000a,SYNCHRONIZATION ON BOXED PRIMITIVESYNCHRONIZATION ON {2} IN {1}MT_CORRECTNESSTHE CODE SYNCHRONIZES ON A BOXED PRIMITIVE CONSTANT, SUCH AS AN INTEGER. \u000aPRIVATE STATIC INTEGER COUNT = 0;\u000a...\u000a  SYNCHRONIZED(COUNT) {\u000a     COUNT++;\u000a     }\u000a...\u000aSINCE INTEGER OBJECTS CAN BE CACHED AND SHARED, THIS CODE COULD BE \u000aSYNCHRONIZING ON THE SAME OBJECT AS OTHER, UNRELATED CODE, LEADING TO \u000aUNRESPONSIVENESS AND POSSIBLE DEADLOCK \u000aSEE CERT CON08-J. DO NOT SYNCHRONIZE ON OBJECTS THAT MAY BE REUSED FOR MORE \u000aINFORMATION.\u000a,CLASS DEFINES COMPARETO(...) AND USES OBJECT.EQUALS(){0} DEFINES {1.GIVENCLASS} AND USES OBJECT.EQUALS()BAD_PRACTICETHIS CLASS DEFINES A COMPARETO(...) METHOD BUT INHERITS ITS EQUALS() METHOD \u000aFROM JAVA.LANG.OBJECT. GENERALLY, THE VALUE OF COMPARETO SHOULD RETURN ZERO IF \u000aAND ONLY IF EQUALS RETURNS TRUE. IF THIS IS VIOLATED, WEIRD AND UNPREDICTABLE \u000aFAILURES WILL OCCUR IN CLASSES SUCH AS PRIORITYQUEUE. IN JAVA 5 THE \u000aPRIORITYQUEUE.REMOVE METHOD USES THE COMPARETO METHOD, WHILE IN JAVA 6 IT USES \u000aTHE EQUALS METHOD. \u000aFROM THE JAVADOC FOR THE COMPARETO METHOD IN THE COMPARABLE INTERFACE: \u000aIT IS STRONGLY RECOMMENDED, BUT NOT STRICTLY REQUIRED THAT (X.COMPARETO(Y)==0) \u000a== (X.EQUALS(Y)). GENERALLY SPEAKING, ANY CLASS THAT IMPLEMENTS THE COMPARABLE \u000aINTERFACE AND VIOLATES THIS CONDITION SHOULD CLEARLY INDICATE THIS FACT. THE \u000aRECOMMENDED LANGUAGE IS &quot;NOTE: THIS CLASS HAS A NATURAL ORDERING THAT IS \u000aINCONSISTENT WITH EQUALS.&quot;,COVARIANT EQUALS() METHOD DEFINED FOR ENUMENUM {0} DEFINES EQUALS({0.GIVENCLASS})CORRECTNESSTHIS CLASS DEFINES AN ENUMERATION, AND EQUALITY ON ENUMERATIONS ARE DEFINED \u000aUSING OBJECT IDENTITY. DEFINING A COVARIANT EQUALS METHOD FOR AN ENUMERATION \u000aVALUE IS EXCEPTIONALLY BAD PRACTICE, SINCE IT WOULD LIKELY RESULT IN HAVING \u000aTWO DIFFERENT ENUMERATION VALUES THAT COMPARE AS EQUALS USING THE COVARIANT \u000aENUM METHOD, AND AS NOT EQUAL WHEN COMPARED NORMALLY. DON&apos;T DO IT.\u000a,COMPLICATED, SUBTLE OR WRONG INCREMENT IN FOR-LOOP COMPLICATED, SUBTLE OR WRONG INCREMENT IN FOR-LOOP {1} STYLEARE YOU SURE THIS FOR LOOP IS INCREMENTING THE CORRECT VARIABLE? IT APPEARS \u000aTHAT ANOTHER VARIABLE IS BEING INITIALIZED AND CHECKED BY THE FOR LOOP.\u000a,METHOD DOES NOT CHECK FOR NULL ARGUMENT{1} DOES NOT CHECK FOR NULL ARGUMENTCORRECTNESSA PARAMETER TO THIS METHOD HAS BEEN IDENTIFIED AS A VALUE THAT SHOULD ALWAYS \u000aBE CHECKED TO SEE WHETHER OR NOT IT IS NULL, BUT IT IS BEING DEREFERENCED \u000aWITHOUT A PRECEDING NULL CHECK.\u000a,FIELD ISN&apos;T FINAL AND CAN&apos;T BE PROTECTED FROM MALICIOUS CODE{1} ISN&apos;T FINAL AND CAN&apos;T BE PROTECTED FROM MALICIOUS CODE MALICIOUS_CODEA MUTABLE STATIC FIELD COULD BE CHANGED BY MALICIOUS CODE OR BY ACCIDENT FROM \u000aANOTHER PACKAGE. UNFORTUNATELY, THE WAY THE FIELD IS USED DOESN&apos;T ALLOW ANY \u000aEASY FIX TO THIS PROBLEM.\u000a,SERIALVERSIONUID ISN&apos;T FINAL{1} ISN&apos;T FINALBAD_PRACTICETHIS CLASS DEFINES A SERIALVERSIONUID FIELD THAT IS NOT FINAL.  THE FIELD \u000aSHOULD BE MADE FINAL IF IT IS INTENDED TO SPECIFY THE VERSION UID FOR PURPOSES \u000aOF SERIALIZATION.\u000a,IMPOSSIBLE DOWNCASTIMPOSSIBLE DOWNCAST FROM {2} TO {3} IN {1}CORRECTNESSTHIS CAST WILL ALWAYS THROW A CLASSCASTEXCEPTION. THE ANALYSIS BELIEVES IT \u000aKNOWS THE PRECISE TYPE OF THE VALUE BEING CAST, AND THE ATTEMPT TO DOWNCAST IT \u000aTO A SUBTYPE WILL ALWAYS FAIL BY THROWING A CLASSCASTEXCEPTION.\u000a,DOOMED ATTEMPT TO APPEND TO AN OBJECT OUTPUT STREAMDOOMED ATTEMPT TO APPEND TO AN OBJECT OUTPUT STREAM IN {1}CORRECTNESSTHIS CODE OPENS A FILE IN APPEND MODE AND THEN WRAPS THE RESULT IN AN OBJECT \u000aOUTPUT STREAM. THIS WON&apos;T ALLOW YOU TO APPEND TO AN EXISTING OBJECT OUTPUT \u000aSTREAM STORED IN A FILE. IF YOU WANT TO BE ABLE TO APPEND TO AN OBJECT OUTPUT \u000aSTREAM, YOU NEED TO KEEP THE OBJECT OUTPUT STREAM OPEN. \u000aTHE ONLY SITUATION IN WHICH OPENING A FILE IN APPEND MODE AND THE WRITING AN \u000aOBJECT OUTPUT STREAM COULD WORK IS IF ON READING THE FILE YOU PLAN TO OPEN IT \u000aIN RANDOM ACCESS MODE AND SEEK TO THE BYTE OFFSET WHERE THE APPEND STARTED. \u000aTODO: EXAMPLE.\u000a,UNCHECKED TYPE IN GENERIC CALLUNCHECKED ARGUMENT OF TYPE OBJECT PROVIDED WHERE TYPE {3.GIVENCLASS} IS EXPECTED IN {1}BAD_PRACTICETHIS CALL TO A GENERIC COLLECTION METHOD PASSES AN ARGUMENT WHILE COMPILE TYPE \u000aOBJECT WHERE A SPECIFIC TYPE FROM THE GENERIC TYPE PARAMETERS IS EXPECTED. \u000aTHUS, NEITHER THE STANDARD JAVA TYPE SYSTEM NOR STATIC ANALYSIS CAN PROVIDE \u000aUSEFUL INFORMATION ON WHETHER THE OBJECT BEING PASSED AS A PARAMETER IS OF AN \u000aAPPROPRIATE TYPE.\u000a,PRIVATE METHOD IS NEVER CALLEDPRIVATE METHOD {1} IS NEVER CALLEDPERFORMANCETHIS PRIVATE METHOD IS NEVER CALLED. ALTHOUGH IT IS POSSIBLE THAT THE METHOD \u000aWILL BE INVOKED THROUGH REFLECTION, IT IS MORE LIKELY THAT THE METHOD IS NEVER \u000aUSED, AND SHOULD BE REMOVED.\u000a,INVOCATION OF TOSTRING ON AN ARRAYINVOCATION OF TOSTRING ON {2.GIVENCLASS} IN {1}CORRECTNESSTHE CODE INVOKES TOSTRING ON AN ARRAY, WHICH WILL GENERATE A FAIRLY USELESS \u000aRESULT SUCH AS [C@16F0472. CONSIDER USING ARRAYS.TOSTRING TO CONVERT THE ARRAY \u000aINTO A READABLE STRING THAT GIVES THE CONTENTS OF THE ARRAY. SEE PROGRAMMING \u000aPUZZLERS, CHAPTER 3, PUZZLE 12.\u000a,USELESS ASSIGNMENT IN RETURN STATEMENTUSELESS ASSIGNMENT IN RETURN FROM {1}STYLETHIS STATEMENT ASSIGNS TO A LOCAL VARIABLE IN A RETURN STATEMENT. THIS \u000aASSIGNMENT HAS EFFECT. PLEASE VERIFY THAT THIS STATEMENT DOES THE RIGHT THING.\u000a,METHOD CALLS THREAD.SLEEP() WITH A LOCK HELD{1} CALLS THREAD.SLEEP() WITH A LOCK HELDMT_CORRECTNESSTHIS METHOD CALLS THREAD.SLEEP() WITH A LOCK HELD. THIS MAY RESULT IN VERY \u000aPOOR PERFORMANCE AND SCALABILITY, OR A DEADLOCK, SINCE OTHER THREADS MAY BE \u000aWAITING TO ACQUIRE THE LOCK. IT IS A MUCH BETTER IDEA TO CALL WAIT() ON THE \u000aLOCK, WHICH RELEASES THE LOCK AND ALLOWS OTHER THREADS TO RUN.\u000a,DOUBLE ASSIGNMENT OF FIELDDOUBLE ASSIGNMENT OF FIELD {2.GIVENCLASS} IN {1}STYLETHIS METHOD CONTAINS A DOUBLE ASSIGNMENT OF A FIELD; E.G. \u000a  INT X,Y;\u000a  PUBLIC VOID FOO() {\u000a    X = X = 17;\u000a  }\u000aASSIGNING TO A FIELD TWICE IS USELESS, AND MAY INDICATE A LOGIC ERROR OR TYPO.\u000a,NULL POINTER DEREFERENCE IN METHOD ON EXCEPTION PATHNULL POINTER DEREFERENCE OF {2.GIVENCLASS} IN {1} ON EXCEPTION PATHCORRECTNESSA POINTER WHICH IS NULL ON AN EXCEPTION PATH IS DEREFERENCED HERE.  THIS WILL \u000aLEAD TO A NULLPOINTEREXCEPTION WHEN THE CODE IS EXECUTED.  NOTE THAT BECAUSE \u000aFINDBUGS CURRENTLY DOES NOT PRUNE INFEASIBLE EXCEPTION PATHS, THIS MAY BE A \u000aFALSE WARNING. \u000aALSO NOTE THAT FINDBUGS CONSIDERS THE DEFAULT CASE OF A SWITCH STATEMENT TO BE \u000aAN EXCEPTION PATH, SINCE THE DEFAULT CASE IS OFTEN INFEASIBLE.\u000a,METHOD MIGHT IGNORE EXCEPTION{1} MIGHT IGNORE {2}BAD_PRACTICETHIS METHOD MIGHT IGNORE AN EXCEPTION.  IN GENERAL, EXCEPTIONS SHOULD BE \u000aHANDLED OR REPORTED IN SOME WAY, OR THEY SHOULD BE THROWN OUT OF THE METHOD.\u000a,BAD COMPARISON OF SIGNED BYTEBAD COMPARISON OF SIGNED BYTE WITH {2} IN {1}CORRECTNESSSIGNED BYTES CAN ONLY HAVE A VALUE IN THE RANGE -128 TO 127. COMPARING A \u000aSIGNED BYTE WITH A VALUE OUTSIDE THAT RANGE IS VACUOUS AND LIKELY TO BE \u000aINCORRECT. TO CONVERT A SIGNED BYTE B TO AN UNSIGNED VALUE IN THE RANGE \u000a0..255, USE 0XFF &amp; B\u000a,JUNIT ASSERTION IN RUN METHOD WILL NOT BE NOTICED BY JUNITJUNIT ASSERTION IN {1} WILL NOT BE NOTICED BY JUNITCORRECTNESSA JUNIT ASSERTION IS PERFORMED IN A RUN METHOD. FAILED JUNIT ASSERTIONS JUST \u000aRESULT IN EXCEPTIONS BEING THROWN. THUS, IF THIS EXCEPTION OCCURS IN A THREAD \u000aOTHER THAN THE THREAD THAT INVOKES THE TEST METHOD, THE EXCEPTION WILL \u000aTERMINATE THE THREAD BUT NOT RESULT IN THE TEST FAILING.\u000a,METHOD INVOKES DANGEROUS METHOD RUNFINALIZERSONEXIT{1} INVOKES DANGEROUS METHOD RUNFINALIZERSONEXITBAD_PRACTICENEVER CALL SYSTEM.RUNFINALIZERSONEXIT OR RUNTIME.RUNFINALIZERSONEXIT FOR ANY \u000aREASON: THEY ARE AMONG THE MOST DANGEROUS METHODS IN THE JAVA LIBRARIES. -- \u000aJOSHUA BLOCH\u000a,UNREAD FIELDUNREAD FIELD: {1}PERFORMANCETHIS FIELD IS NEVER READ.  CONSIDER REMOVING IT FROM THE CLASS.\u000a,MISSING EXPECTED OR DESIRED WARNING FROM FINDBUGSMISSING EXPECTED OR DESIRED {2} FINDBUGS WARNING IN {1}CORRECTNESSFINDBUGS DIDN&apos;T GENERATE GENERATED A WARNING THAT, ACCORDING TO A \u000a@EXPECTEDWARNING ANNOTATED, IS EXPECTED OR DESIRED\u000a,NULLCHECK OF VALUE PREVIOUSLY DEREFERENCEDNULLCHECK OF {2.GIVENCLASS} AT {4.LINENUMBER} OF VALUE PREVIOUSLY DEREFERENCED IN {1}CORRECTNESSA VALUE IS CHECKED HERE TO SEE WHETHER IT IS NULL, BUT THIS VALUE CAN&apos;T BE \u000aNULL BECAUSE IT WAS PREVIOUSLY DEREFERENCED AND IF IT WERE NULL A NULL POINTER \u000aEXCEPTION WOULD HAVE OCCURRED AT THE EARLIER DEREFERENCE. ESSENTIALLY, THIS \u000aCODE AND THE PREVIOUS DEREFERENCE DISAGREE AS TO WHETHER THIS VALUE IS ALLOWED \u000aTO BE NULL. EITHER THE CHECK IS REDUNDANT OR THE PREVIOUS DEREFERENCE IS \u000aERRONEOUS.\u000a,INT VALUE CONVERTED TO LONG AND USED AS ABSOLUTE TIMEINT CONVERTED TO LONG AND PASSED AS ABSOLUTE TIME TO {2} IN {1}CORRECTNESSTHIS CODE CONVERTS A 32-BIT INT VALUE TO A 64-BIT LONG VALUE, AND THEN PASSES \u000aTHAT VALUE FOR A METHOD PARAMETER THAT REQUIRES AN ABSOLUTE TIME VALUE. AN \u000aABSOLUTE TIME VALUE IS THE NUMBER OF MILLISECONDS SINCE THE STANDARD BASE TIME \u000aKNOWN AS &quot;THE EPOCH&quot;, NAMELY JANUARY 1, 1970, 00:00:00 GMT. FOR EXAMPLE, THE \u000aFOLLOWING METHOD, INTENDED TO CONVERT SECONDS SINCE THE EPOC INTO A DATE, IS \u000aBADLY BROKEN: \u000aDATE GETDATE(INT SECONDS) { RETURN NEW DATE(SECONDS * 1000); }\u000aTHE MULTIPLICATION IS DONE USING 32-BIT ARITHMETIC, AND THEN CONVERTED TO A \u000a64-BIT VALUE. WHEN A 32-BIT VALUE IS CONVERTED TO 64-BITS AND USED TO EXPRESS \u000aAN ABSOLUTE TIME VALUE, ONLY DATES IN DECEMBER 1969 AND JANUARY 1970 CAN BE \u000aREPRESENTED. \u000aCORRECT IMPLEMENTATIONS FOR THE ABOVE METHOD ARE: \u000a// FAILS FOR DATES AFTER 2037\u000aDATE GETDATE(INT SECONDS) { RETURN NEW DATE(SECONDS * 1000L); }\u000a\u000a// BETTER, WORKS FOR ALL DATES\u000aDATE GETDATE(LONG SECONDS) { RETURN NEW DATE(SECONDS * 1000); },METHOD PERFORMS MATH USING FLOATING POINT PRECISION{1} PERFORMS MATH USING FLOATING POINT PRECISIONCORRECTNESSTHE METHOD PERFORMS MATH OPERATIONS USING FLOATING POINT PRECISION. FLOATING \u000aPOINT PRECISION IS VERY IMPRECISE. FOR EXAMPLE, 16777216.0F + 1.0F = \u000a16777216.0F. CONSIDER USING DOUBLE MATH INSTEAD.\u000a,UNINITIALIZED READ OF FIELD METHOD CALLED FROM CONSTRUCTOR OF SUPERCLASS{2.NAME} ISN&apos;T INITIALIZED IN {1} WHEN INVOKED FROM CONSTRUCTOR FOR SUPERCLASSCORRECTNESSTHIS METHOD IS INVOKED IN THE CONSTRUCTOR OF OF THE SUPERCLASS. AT THIS POINT, \u000aTHE FIELDS OF THE CLASS HAVE NOT YET INITIALIZED. \u000aTO MAKE THIS MORE CONCRETE, CONSIDER THE FOLLOWING CLASSES: \u000aABSTRACT CLASS A {\u000a  INT HASHCODE;\u000a  ABSTRACT OBJECT GETVALUE();\u000a  A() {\u000a    HASHCODE = GETVALUE().HASHCODE();\u000a    }\u000a  }\u000aCLASS B EXTENDS A {\u000a  OBJECT VALUE;\u000a  B(OBJECT V) {\u000a    THIS.VALUE = V;\u000a    }\u000a  OBJECT GETVALUE() {\u000a    RETURN VALUE;\u000a  }\u000a  }\u000aWHEN A B IS CONSTRUCTED, THE CONSTRUCTOR FOR THE A CLASS IS INVOKED BEFORE THE \u000aCONSTRUCTOR FOR B SETS VALUE. THUS, WHEN THE CONSTRUCTOR FOR A INVOKES GETVALUE, \u000aAN UNINITIALIZED VALUE IS READ FOR VALUE\u000a,EXPLICIT INVOCATION OF FINALIZEREXPLICIT INVOCATION OF {2} IN {1}BAD_PRACTICETHIS METHOD CONTAINS AN EXPLICIT INVOCATION OF THE FINALIZE() METHOD ON AN \u000aOBJECT.  BECAUSE FINALIZER METHODS ARE SUPPOSED TO BE EXECUTED ONCE, AND ONLY \u000aBY THE VM, THIS IS A BAD IDEA. \u000aIF A CONNECTED SET OF OBJECTS BEINGS FINALIZABLE, THEN THE VM WILL INVOKE THE \u000aFINALIZE METHOD ON ALL THE FINALIZABLE OBJECT, POSSIBLY AT THE SAME TIME IN \u000aDIFFERENT THREADS. THUS, IT IS A PARTICULARLY BAD IDEA, IN THE FINALIZE METHOD \u000aFOR A CLASS X, INVOKE FINALIZE ON OBJECTS REFERENCED BY X, BECAUSE THEY MAY \u000aALREADY BE GETTING FINALIZED IN A SEPARATE THREAD.\u000a,DEAD STORE DUE TO SWITCH STATEMENT FALL THROUGHVALUE OF {2.GIVENCLASS} FROM PREVIOUS CASE IS OVERWRITTEN HERE DUE TO SWITCH STATEMENT FALL THROUGHCORRECTNESSA VALUE STORED IN THE PREVIOUS SWITCH CASE IS OVERWRITTEN HERE DUE TO A SWITCH \u000aFALL THROUGH. IT IS LIKELY THAT YOU FORGOT TO PUT A BREAK OR RETURN AT THE END \u000aOF THE PREVIOUS CASE.\u000a,HUGE STRING CONSTANTS IS DUPLICATED ACROSS MULTIPLE CLASS FILES{1} IS INITIALIZED TO A STRING CONSTANT {2} CHARACTERS LONG THAT IS DUPLICATED IN {3} OTHER CLASS FILESPERFORMANCEA LARGE STRING CONSTANT IS DUPLICATED ACROSS MULTIPLE CLASS FILES. THIS IS \u000aLIKELY BECAUSE A FINAL FIELD IS INITIALIZED TO A STRING CONSTANT, AND THE JAVA \u000aLANGUAGE MANDATES THAT ALL REFERENCES TO A FINAL FIELD FROM OTHER CLASSES BE \u000aINLINED INTO THAT CLASSFILE. SEE JDK BUG 6447475 FOR A DESCRIPTION OF AN \u000aOCCURRENCE OF THIS BUG IN THE JDK AND HOW RESOLVING IT REDUCED THE SIZE OF THE \u000aJDK BY 1 MEGABYTE.\u000a,UNUSED PUBLIC OR PROTECTED FIELDUNUSED PUBLIC OR PROTECTED FIELD: {1}STYLETHIS FIELD IS NEVER USED.  THE FIELD IS PUBLIC OR PROTECTED, SO PERHAPS IT IS \u000aINTENDED TO BE USED WITH CLASSES NOT SEEN AS PART OF THE ANALYSIS. IF NOT, \u000aCONSIDER REMOVING IT FROM THE CLASS.\u000a,NOTIFY WITH TWO LOCKS HELDNOTIFY() OR NOTIFYALL*() WITH TWO LOCKS HELD IN {1}MT_CORRECTNESSTHE CODE CALLS NOTIFY() OR NOTIFYALL() WHILE TWO LOCKS ARE HELD. IF THIS \u000aNOTIFICATION IS INTENDED TO WAKE UP A WAIT() THAT IS HOLDING THE SAME LOCKS, \u000aIT MAY DEADLOCK, SINCE THE WAIT WILL ONLY GIVE UP ONE LOCK AND THE NOTIFY WILL \u000aBE UNABLE TO GET BOTH LOCKS, AND THUS THE NOTIFY WILL NOT SUCCEED.   IF THERE \u000aIS ALSO A WARNING ABOUT A TWO LOCK WAIT, THE PROBABLY OF A BUG IS QUITE HIGH.\u000a,METHOD SUPERFLUOUSLY DELEGATES TO PARENT CLASS METHOD{1} SUPERFLUOUSLY DELEGATES TO PARENT CLASS METHODSTYLETHIS DERIVED METHOD MERELY CALLS THE SAME SUPERCLASS METHOD PASSING IN THE \u000aEXACT PARAMETERS RECEIVED. THIS METHOD CAN BE REMOVED, AS IT PROVIDES NO \u000aADDITIONAL VALUE.\u000a,METHOD DOESN&apos;T OVERRIDE METHOD IN SUPERCLASS DUE TO WRONG PACKAGE FOR PARAMETER{1} DOESN&apos;T OVERRIDE METHOD IN SUPERCLASS BECAUSE PARAMETER TYPE {4} DOESN&apos;T MATCH SUPERCLASS PARAMETER TYPE {5}CORRECTNESSTHE METHOD IN THE SUBCLASS DOESN&apos;T OVERRIDE A SIMILAR METHOD IN A SUPERCLASS \u000aBECAUSE THE TYPE OF A PARAMETER DOESN&apos;T EXACTLY MATCH THE TYPE OF THE \u000aCORRESPONDING PARAMETER IN THE SUPERCLASS. FOR EXAMPLE, IF YOU HAVE: \u000aIMPORT ALPHA.FOO;\u000aPUBLIC CLASS A {\u000a  PUBLIC INT F(FOO X) { RETURN 17; }\u000a}\u000a----\u000aIMPORT BETA.FOO;\u000aPUBLIC CLASS B EXTENDS A {\u000a  PUBLIC INT F(FOO X) { RETURN 42; }\u000a}\u000aTHE F(FOO) METHOD DEFINED IN CLASS B DOESN&apos;T OVERRIDE THE F(FOO) METHOD \u000aDEFINED IN CLASS A, BECAUSE THE ARGUMENT TYPES ARE FOO&apos;S FROM DIFFERENT \u000aPACKAGES.\u000a,UNNEEDED USE OF CURRENTTHREAD() CALL, TO CALL INTERRUPTED() {1} MAKES AN UNNEEDED CALL TO CURRENTTHREAD() JUST TO CALL INTERRUPTED()CORRECTNESSTHIS METHOD INVOKES THE THREAD.CURRENTTHREAD() CALL, JUST TO CALL THE \u000aINTERRUPTED() METHOD. AS INTERRUPTED() IS A STATIC METHOD, IS MORE SIMPLE AND \u000aCLEAR TO USE THREAD.INTERRUPTED().\u000a,EXPLICIT GARBAGE COLLECTION; EXTREMELY DUBIOUS EXCEPT IN BENCHMARKING CODE{1} FORCES GARBAGE COLLECTION; EXTREMELY DUBIOUS EXCEPT IN BENCHMARKING CODEPERFORMANCECODE EXPLICITLY INVOKES GARBAGE COLLECTION. EXCEPT FOR SPECIFIC USE IN \u000aBENCHMARKING, THIS IS VERY DUBIOUS. \u000aIN THE PAST, SITUATIONS WHERE PEOPLE HAVE EXPLICITLY INVOKED THE GARBAGE \u000aCOLLECTOR IN ROUTINES SUCH AS CLOSE OR FINALIZE METHODS HAS LED TO HUGE \u000aPERFORMANCE BLACK HOLES. GARBAGE COLLECTION CAN BE EXPENSIVE. ANY SITUATION \u000aTHAT FORCES HUNDREDS OR THOUSANDS OF GARBAGE COLLECTIONS WILL BRING THE \u000aMACHINE TO A CRAWL.\u000a,METHOD DEFINES A VARIABLE THAT OBSCURES A FIELD{1} DEFINES A VARIABLE THAT OBSCURES FIELD {2.GIVENCLASS}CORRECTNESSTHIS METHOD DEFINES A LOCAL VARIABLE WITH THE SAME NAME AS A FIELD IN THIS \u000aCLASS OR A SUPERCLASS. THIS MAY CAUSE THE METHOD TO READ AN UNINITIALIZED \u000aVALUE FROM THE FIELD, LEAVE THE FIELD UNINITIALIZED, OR BOTH.\u000a,PARAMETER MUST BE NONNULL BUT IS MARKED AS NULLABLE{2} MUST BE NONNULL BUT IS MARKED AS NULLABLESTYLETHIS PARAMETER IS ALWAYS USED IN A WAY THAT REQUIRES IT TO BE NONNULL, BUT THE \u000aPARAMETER IS EXPLICITLY ANNOTATED AS BEING NULLABLE. EITHER THE USE OF THE \u000aPARAMETER OR THE ANNOTATION IS WRONG.\u000a,CALL TO UNSUPPORTED METHODCALL TO UNSUPPORTED METHOD {2} IN {1}STYLEALL TARGETS OF THIS METHOD INVOCATION THROW AN UNSUPPORTEDOPERATIONEXCEPTION.\u000a,CONFUSING METHOD NAMESCONFUSING TO HAVE METHODS {1} AND {3}BAD_PRACTICETHE REFERENCED METHODS HAVE NAMES THAT DIFFER ONLY BY CAPITALIZATION.\u000a,METHOD CALL PASSES NULL FOR NONNULL PARAMETERNULL PASSED FOR NONNULL PARAMETER OF {2.GIVENCLASS} IN {1}CORRECTNESSA POSSIBLY-NULL VALUE IS PASSED AT A CALL SITE WHERE ALL KNOWN TARGET METHODS \u000aREQUIRE THE PARAMETER TO BE NONNULL. EITHER THE PARAMETER IS ANNOTATED AS A \u000aPARAMETER THAT SHOULD ALWAYS BE NONNULL, OR ANALYSIS HAS SHOWN THAT IT WILL \u000aALWAYS BE DEREFERENCED.\u000a,COMPARING VALUES WITH INCOMPATIBLE TYPE QUALIFIERSVALUE ANNOTATED AS HAVING THE TYPE QUALIFIER {2.SIMPLENAME} IS COMPARED FOR EQUALITY WITH A VALUE THAT NEVER HAS THAT QUALIFIER CORRECTNESSA VALUE SPECIFIED AS CARRYING A TYPE QUALIFIER ANNOTATION IS COMPARED WITH A \u000aVALUE THAT DOESN&apos;T EVER CARRY THAT QUALIFIER. \u000aMORE PRECISELY, A VALUE ANNOTATED WITH A TYPE QUALIFIER SPECIFYING WHEN=ALWAYS \u000aIS COMPARED WITH A VALUE THAT WHERE THE SAME TYPE QUALIFIER SPECIFIES \u000aWHEN=NEVER. \u000aFOR EXAMPLE, SAY THAT @NONNEGATIVE IS A NICKNAME FOR THE TYPE QUALIFIER \u000aANNOTATION @NEGATIVE(WHEN=WHEN.NEVER). THE FOLLOWING CODE WILL GENERATE THIS \u000aWARNING BECAUSE THE RETURN STATEMENT REQUIRES A @NONNEGATIVE VALUE, BUT \u000aRECEIVES ONE THAT IS MARKED AS @NEGATIVE. \u000aPUBLIC BOOLEAN EXAMPLE(@NEGATIVE INTEGER VALUE1, @NONNEGATIVE INTEGER VALUE2) {\u000a    RETURN VALUE1.EQUALS(VALUE2);\u000a},REDUNDANT NULLCHECK OF VALUE KNOWN TO BE NULLREDUNDANT NULLCHECK OF {2} WHICH IS KNOWN TO BE NULL IN {1}STYLETHIS METHOD CONTAINS A REDUNDANT CHECK OF A KNOWN NULL VALUE AGAINST THE \u000aCONSTANT NULL.\u000a,UNCHECKED/UNCONFIRMED CASTUNCHECKED/UNCONFIRMED CAST FROM {2} TO {3} IN {1}STYLETHIS CAST IS UNCHECKED, AND NOT ALL INSTANCES OF THE TYPE CASTED FROM CAN BE \u000aCAST TO THE TYPE IT IS BEING CAST TO. CHECK THAT YOUR PROGRAM LOGIC ENSURES \u000aTHAT THIS CAST WILL NOT FAIL.\u000a,REDUNDANT COMPARISON OF TWO NULL VALUESREDUNDANT COMPARISON OF TWO NULL VALUES IN {1}STYLETHIS METHOD CONTAINS A REDUNDANT COMPARISON OF TWO REFERENCES KNOWN TO BOTH BE \u000aDEFINITELY NULL.\u000a,STATIC CALENDAR FIELD{1} IS STATIC FIELD OF TYPE JAVA.UTIL.CALENDAR, WHICH ISN&apos;T THREAD SAFEMT_CORRECTNESSEVEN THOUGH THE JAVADOC DOES NOT CONTAIN A HINT ABOUT IT, CALENDARS ARE \u000aINHERENTLY UNSAFE FOR MULTIHTREADED USE. SHARING A SINGLE INSTANCE ACROSS \u000aTHREAD BOUNDARIES WITHOUT PROPER SYNCHRONIZATION WILL RESULT IN ERRATIC \u000aBEHAVIOR OF THE APPLICATION. UNDER 1.4 PROBLEMS SEEM TO SURFACE LESS OFTEN \u000aTHAN UNDER JAVA 5 WHERE YOU WILL PROBABLY SEE RANDOM \u000aARRAYINDEXOUTOFBOUNDSEXCEPTIONS OR INDEXOUTOFBOUNDSEXCEPTIONS IN \u000aSUN.UTIL.CALENDAR.BASECALENDAR.GETCALENDARDATEFROMFIXEDDATE(). \u000aYOU MAY ALSO EXPERIENCE SERIALIZATION PROBLEMS. \u000aUSING AN INSTANCE FIELD IS RECOMMENDED. \u000aFOR MORE INFORMATION ON THIS SEE SUN BUG #6231579 AND SUN BUG #6178997.\u000a,FINALIZER NULLS FIELDS{3} IS SET TO NULL INSIDE FINALIZE METHOD IN {1.CLASS}BAD_PRACTICETHIS FINALIZER NULLS OUT FIELDS. THIS IS USUALLY AN ERROR, AS IT DOES NOT AID \u000aGARBAGE COLLECTION, AND THE OBJECT IS GOING TO BE GARBAGE COLLECTED ANYWAY.\u000a,FIELD SHOULD BE MOVED OUT OF AN INTERFACE AND MADE PACKAGE PROTECTED{1} SHOULD BE MOVED OUT OF AN INTERFACE AND MADE PACKAGE PROTECTEDMALICIOUS_CODEA FINAL STATIC FIELD THAT IS DEFINED IN AN INTERFACE REFERENCES A MUTABLE \u000aOBJECT SUCH AS AN ARRAY OR HASHTABLE. THIS MUTABLE OBJECT COULD BE CHANGED BY \u000aMALICIOUS CODE OR BY ACCIDENT FROM ANOTHER PACKAGE. TO SOLVE THIS, THE FIELD \u000aNEEDS TO BE MOVED TO A CLASS AND MADE PACKAGE PROTECTED TO AVOID THIS \u000aVULNERABILITY.\u000a,METHOD INVOKES INEFFICIENT NUMBER CONSTRUCTOR; USE STATIC VALUEOF INSTEAD{1} INVOKES INEFFICIENT {2} CONSTRUCTOR; USE {3} INSTEADPERFORMANCEUSING NEW INTEGER(INT) IS GUARANTEED TO ALWAYS RESULT IN A NEW OBJECT WHEREAS INTEGER.VALUEOF(INT) \u000aALLOWS CACHING OF VALUES TO BE DONE BY THE COMPILER, CLASS LIBRARY, OR JVM. \u000aUSING OF CACHED VALUES AVOIDS OBJECT ALLOCATION AND THE CODE WILL BE FASTER. \u000aVALUES BETWEEN -128 AND 127 ARE GUARANTEED TO HAVE CORRESPONDING CACHED \u000aINSTANCES AND USING VALUEOF IS APPROXIMATELY 3.5 TIMES FASTER THAN USING \u000aCONSTRUCTOR. FOR VALUES OUTSIDE THE CONSTANT RANGE THE PERFORMANCE OF BOTH \u000aSTYLES IS THE SAME. \u000aUNLESS THE CLASS MUST BE COMPATIBLE WITH JVMS PREDATING JAVA 1.5, USE EITHER \u000aAUTOBOXING OR THE VALUEOF() METHOD WHEN CREATING INSTANCES OF LONG, INTEGER, SHORT, \u000aCHARACTER, AND BYTE.\u000a,FILE.SEPARATOR USED FOR REGULAR EXPRESSIONFILE.SEPARATOR USED FOR REGULAR EXPRESSION IN {1}CORRECTNESSTHE CODE HERE USES FILE.SEPARATOR WHERE A REGULAR EXPRESSION IS REQUIRED. THIS \u000aWILL FAIL ON WINDOWS PLATFORMS, WHERE THE FILE.SEPARATOR IS A BACKSLASH, WHICH \u000aIS INTERPRETED IN A REGULAR EXPRESSION AS AN ESCAPE CHARACTER. AMOUNG OTHER \u000aOPTIONS, YOU CAN JUST USE FILE.SEPARATORCHAR==&apos;\\&apos; ? &quot;\\\\&quot; : FILE.SEPARATOR \u000aINSTEAD OF FILE.SEPARATOR\u000a,INCOMPATIBLE BIT MASKSINCOMPATIBLE BIT MASKS IN (E &amp; {2} == {3}) YIELDS A CONSTANT RESULT IN {1}CORRECTNESSTHIS METHOD COMPARES AN EXPRESSION OF THE FORM (E &amp; C) TO D, WHICH WILL ALWAYS \u000aCOMPARE UNEQUAL DUE TO THE SPECIFIC VALUES OF CONSTANTS C AND D. THIS MAY \u000aINDICATE A LOGIC ERROR OR TYPO.\u000a,POSSIBLE NULL POINTER DEREFERENCEPOSSIBLE NULL POINTER DEREFERENCE OF {2.GIVENCLASS} IN {1}CORRECTNESSTHERE IS A BRANCH OF STATEMENT THAT, IF EXECUTED, GUARANTEES THAT A NULL VALUE \u000aWILL BE DEREFERENCED, WHICH WOULD GENERATE A NULLPOINTEREXCEPTION WHEN THE \u000aCODE IS EXECUTED. OF COURSE, THE PROBLEM MIGHT BE THAT THE BRANCH OR STATEMENT \u000aIS INFEASIBLE AND THAT THE NULL POINTER EXCEPTION CAN&apos;T EVER BE EXECUTED; \u000aDECIDING THAT IS BEYOND THE ABILITY OF FINDBUGS.\u000a,SELF ASSIGNMENT OF LOCAL VARIABLESELF ASSIGNMENT OF {2} IN {1}STYLETHIS METHOD CONTAINS A SELF ASSIGNMENT OF A LOCAL VARIABLE; E.G. \u000a  PUBLIC VOID FOO() {\u000a    INT X = 3;\u000a    X = X;\u000a  }\u000aSUCH ASSIGNMENTS ARE USELESS, AND MAY INDICATE A LOGIC ERROR OR TYPO.\u000a,COVARIANT EQUALS() METHOD DEFINED, OBJECT.EQUALS(OBJECT) INHERITED{0} DEFINES EQUALS({0.GIVENCLASS}) METHOD AND USES OBJECT.EQUALS(OBJECT)CORRECTNESSTHIS CLASS DEFINES A COVARIANT VERSION OF THE EQUALS() METHOD, BUT INHERITS \u000aTHE NORMAL EQUALS(OBJECT) METHOD DEFINED IN THE BASE JAVA.LANG.OBJECT CLASS.  \u000aTHE CLASS SHOULD PROBABLY DEFINE A BOOLEAN EQUALS(OBJECT) METHOD.\u000a,METHOD DISCARDS RESULT OF READLINE AFTER CHECKING IF IT IS NONNULL{1} DISCARDS RESULT OF READLINE AFTER CHECKING IF IT IS NONNULLSTYLETHE VALUE RETURNED BY READLINE IS DISCARDED AFTER CHECKING TO SEE IF THE \u000aRETURN VALUE IS NON-NULL. IN ALMOST ALL SITUATIONS, IF THE RESULT IS NON-NULL, \u000aYOU WILL WANT TO USE THAT NON-NULL VALUE. CALLING READLINE AGAIN WILL GIVE YOU \u000aA DIFFERENT LINE.\u000a,POTENTIALLY DANGEROUS USE OF NON-SHORT-CIRCUIT LOGICPOTENTIALLY DANGEROUS USE OF NON-SHORT-CIRCUIT LOGIC IN {1}STYLETHIS CODE SEEMS TO BE USING NON-SHORT-CIRCUIT LOGIC (E.G., &amp; OR |) RATHER THAN \u000aSHORT-CIRCUIT LOGIC (&amp;&amp; OR ||). IN ADDITION, IT SEEM POSSIBLE THAT, DEPENDING \u000aON THE VALUE OF THE LEFT HAND SIDE, YOU MIGHT NOT WANT TO EVALUATE THE RIGHT \u000aHAND SIDE (BECAUSE IT WOULD HAVE SIDE EFFECTS, COULD CAUSE AN EXCEPTION OR \u000aCOULD BE EXPENSIVE. \u000aNON-SHORT-CIRCUIT LOGIC CAUSES BOTH SIDES OF THE EXPRESSION TO BE EVALUATED \u000aEVEN WHEN THE RESULT CAN BE INFERRED FROM KNOWING THE LEFT-HAND SIDE. THIS CAN \u000aBE LESS EFFICIENT AND CAN RESULT IN ERRORS IF THE LEFT-HAND SIDE GUARDS CASES \u000aWHEN EVALUATING THE RIGHT-HAND SIDE CAN GENERATE AN ERROR. \u000aSEE THE JAVA LANGUAGE SPECIFICATION FOR DETAILS\u000a,TESTCASE DECLARES A BAD SUITE METHOD BAD DECLARATION FOR SUITE METHOD IN {0}CORRECTNESSCLASS IS A JUNIT TESTCASE AND DEFINES A SUITE() METHOD. HOWEVER, THE SUITE \u000aMETHOD NEEDS TO BE DECLARED AS EITHER \u000aPUBLIC STATIC JUNIT.FRAMEWORK.TEST SUITE()\u000aOR PUBLIC STATIC JUNIT.FRAMEWORK.TESTSUITE SUITE(),FUTILE ATTEMPT TO CHANGE MAX POOL SIZE OF SCHEDULEDTHREADPOOLEXECUTORFUTILE ATTEMPT TO CHANGE MAX POOL SIZE OF SCHEDULEDTHREADPOOLEXECUTOR IN {1}CORRECTNESS(JAVADOC) WHILE SCHEDULEDTHREADPOOLEXECUTOR INHERITS FROM THREADPOOLEXECUTOR, \u000aA FEW OF THE INHERITED TUNING METHODS ARE NOT USEFUL FOR IT. IN PARTICULAR, \u000aBECAUSE IT ACTS AS A FIXED-SIZED POOL USING COREPOOLSIZE THREADS AND AN \u000aUNBOUNDED QUEUE, ADJUSTMENTS TO MAXIMUMPOOLSIZE HAVE NO USEFUL EFFECT.\u000a,SYNCHRONIZATION ON GETCLASS RATHER THAN CLASS LITERALSYNCHRONIZATION ON GETCLASS RATHER THAN CLASS LITERAL IN {1}MT_CORRECTNESSTHIS INSTANCE METHOD SYNCHRONIZES ON THIS.GETCLASS(). IF THIS CLASS IS \u000aSUBCLASSED, SUBCLASSES WILL SYNCHRONIZE ON THE CLASS OBJECT FOR THE SUBCLASS, \u000aWHICH ISN&apos;T LIKELY WHAT WAS INTENDED. FOR EXAMPLE, CONSIDER THIS CODE FROM \u000aJAVA.AWT.LABEL: \u000a     PRIVATE STATIC FINAL STRING BASE = &quot;LABEL&quot;;\u000a     PRIVATE STATIC INT NAMECOUNTER = 0;\u000a     STRING CONSTRUCTCOMPONENTNAME() {\u000a        SYNCHRONIZED (GETCLASS()) {\u000a            RETURN BASE + NAMECOUNTER++;\u000a        }\u000a     }\u000a     \u000aSUBCLASSES OF LABEL WON&apos;T SYNCHRONIZE ON THE SAME SUBCLASS, GIVING RISE TO A \u000aDATARACE. INSTEAD, THIS CODE SHOULD BE SYNCHRONIZING ON LABEL.CLASS \u000a     PRIVATE STATIC FINAL STRING BASE = &quot;LABEL&quot;;\u000a     PRIVATE STATIC INT NAMECOUNTER = 0;\u000a     STRING CONSTRUCTCOMPONENTNAME() {\u000a        SYNCHRONIZED (LABEL.CLASS) {\u000a            RETURN BASE + NAMECOUNTER++;\u000a        }\u000a     }\u000a     \u000aBUG PATTERN CONTRIBUTED BY JASON MEHRENS\u000a,INCORRECT LAZY INITIALIZATION AND UPDATE OF STATIC FIELDINCORRECT LAZY INITIALIZATION AND UPDATE OF STATIC FIELD {2} IN {1}MT_CORRECTNESSTHIS METHOD CONTAINS AN UNSYNCHRONIZED LAZY INITIALIZATION OF A STATIC FIELD. \u000aAFTER THE FIELD IS SET, THE OBJECT STORED INTO THAT LOCATION IS FURTHER \u000aUPDATED OR ACCESSED. THE SETTING OF THE FIELD IS VISIBLE TO OTHER THREADS AS \u000aSOON AS IT IS SET. IF THE FUTHER ACCESSES IN THE METHOD THAT SET THE FIELD \u000aSERVE TO INITIALIZE THE OBJECT, THEN YOU HAVE A VERY SERIOUS MULTITHREADING \u000aBUG, UNLESS SOMETHING ELSE PREVENTS ANY OTHER THREAD FROM ACCESSING THE STORED \u000aOBJECT UNTIL IT IS FULLY INITIALIZED. \u000aEVEN IF YOU FEEL CONFIDENT THAT THE METHOD IS NEVER CALLED BY MULTIPLE \u000aTHREADS, IT MIGHT BE BETTER TO NOT SET THE STATIC FIELD UNTIL THE VALUE YOU \u000aARE SETTING IT TO IS FULLY POPULATED/INITIALIZED.\u000a,TESTINGTEST WARNING GENERATED IN {1}EXPERIMENTALTHIS BUG PATTERN IS ONLY GENERATED BY NEW, INCOMPLETELY IMPLEMENTED BUG \u000aDETECTORS.\u000a,METHOD MAY FAIL TO CLOSE DATABASE RESOURCE ON EXCEPTION{1} MAY FAIL TO CLOSE DATABASE RESOURCE ON EXCEPTIONBAD_PRACTICETHE METHOD CREATES A DATABASE RESOURCE (SUCH AS A DATABASE CONNECTION OR ROW \u000aSET), DOES NOT ASSIGN IT TO ANY FIELDS, PASS IT TO OTHER METHODS, OR RETURN \u000aIT, AND DOES NOT APPEAR TO CLOSE THE OBJECT ON ALL EXCEPTION PATHS OUT OF THE \u000aMETHOD.  FAILURE TO CLOSE DATABASE RESOURCES ON ALL PATHS OUT OF A METHOD MAY \u000aRESULT IN POOR PERFORMANCE, AND COULD CAUSE THE APPLICATION TO HAVE PROBLEMS \u000aCOMMUNICATING WITH THE DATABASE.\u000a,INTEGER MULTIPLY OF RESULT OF INTEGER REMAINDERINTEGER MULTIPLE OF RESULT OF INTEGER REMAINDER IN {1}CORRECTNESSTHE CODE MULTIPLIES THE RESULT OF AN INTEGER REMAINING BY AN INTEGER CONSTANT. \u000aBE SURE YOU DON&apos;T HAVE YOUR OPERATOR PRECEDENCE CONFUSED. FOR EXAMPLE I % 60 * \u000a1000 IS (I % 60) * 1000, NOT I % (60 * 1000).\u000a,CLASS DEFINES HASHCODE(); SHOULD IT BE HASHCODE()?CLASS {0} DEFINES HASHCODE(); SHOULD IT BE HASHCODE()?CORRECTNESSTHIS CLASS DEFINES A METHOD CALLED HASHCODE().  THIS METHOD DOES NOT OVERRIDE \u000aTHE HASHCODE() METHOD IN JAVA.LANG.OBJECT, WHICH IS PROBABLY WHAT WAS INTENDED.\u000a,CREATION OF SCHEDULEDTHREADPOOLEXECUTOR WITH ZERO CORE THREADSCREATION OF SCHEDULEDTHREADPOOLEXECUTOR WITH ZERO CORE THREADS IN {1}CORRECTNESS(JAVADOC) A SCHEDULEDTHREADPOOLEXECUTOR WITH ZERO CORE THREADS WILL NEVER \u000aEXECUTE ANYTHING; CHANGES TO THE MAX POOL SIZE ARE IGNORED.\u000a,"/>
        <attr name="location" stringvalue="Editor"/>
        <attr name="tabTitle" stringvalue="Hints"/>
        <attr name="version" intvalue="1"/>
    </fileobject>
</attributes>
